{"name":"marvinthang","settings":"{\"settings\":\"{\\r\\n    \\\"workbench.colorTheme\\\": \\\"Monokai Pro (Filter Spectrum)\\\",\\r\\n    \\\"workbench.iconTheme\\\": \\\"material-icon-theme\\\",\\r\\n    \\\"editor.inlineSuggest.enabled\\\": true,\\r\\n    \\\"code-runner.saveAllFilesBeforeRun\\\": true,\\r\\n    // \\\"editor.fontFamily\\\": \\\"\\\\\\\"Fira Code\\\\\\\"\\\",\\r\\n    \\\"editor.fontLigatures\\\": \\\"'ss02'\\\",\\r\\n    \\\"editor.fontFamily\\\": \\\"JetBrains Mono\\\",\\r\\n    \\\"editor.fontSize\\\": 15,\\r\\n    \\\"github.copilot.enable\\\": {\\r\\n        \\\"*\\\": true,\\r\\n        \\\"plaintext\\\": true,\\r\\n        \\\"markdown\\\": false,\\r\\n        \\\"yaml\\\": false\\r\\n    },\\r\\n    \\\"editor.codeActionsOnSave\\\": {},\\r\\n    \\\"code-runner.executorMap\\\": {\\r\\n\\r\\n        \\\"javascript\\\": \\\"node\\\",\\r\\n        \\\"java\\\": \\\"cd $dir && javac $fileName && java $fileNameWithoutExt\\\",\\r\\n        \\\"c\\\": \\\"cd $dir && gcc $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt\\\",\\r\\n        \\\"zig\\\": \\\"zig run\\\",\\r\\n        \\\"cpp\\\": \\\"cd $dir\\\\nclear\\\\ng++ -DLOCAL -ID:/code/_archive_/lib -std=c++20 -Wall \\\\\\\"-Wl,--stack=100000000\\\\\\\" $fileName -o $fileNameWithoutExt && .\\\\\\\\$fileNameWithoutExt\\\",\\r\\n        \\\"objective-c\\\": \\\"cd $dir && gcc -framework Cocoa $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt\\\",\\r\\n        \\\"php\\\": \\\"php\\\",\\r\\n        \\\"python\\\": \\\"cd $dir\\\\nclear\\\\npython -u $fileName\\\",\\r\\n        \\\"perl\\\": \\\"perl\\\",\\r\\n        \\\"perl6\\\": \\\"perl6\\\",\\r\\n        \\\"ruby\\\": \\\"ruby\\\",\\r\\n        \\\"go\\\": \\\"go run\\\",\\r\\n        \\\"lua\\\": \\\"lua\\\",\\r\\n        \\\"groovy\\\": \\\"groovy\\\",\\r\\n        \\\"powershell\\\": \\\"powershell -ExecutionPolicy ByPass -File\\\",\\r\\n        \\\"bat\\\": \\\"cmd /c\\\",\\r\\n        \\\"shellscript\\\": \\\"bash\\\",\\r\\n        \\\"fsharp\\\": \\\"fsi\\\",\\r\\n        \\\"csharp\\\": \\\"scriptcs\\\",\\r\\n        \\\"vbscript\\\": \\\"cscript //Nologo\\\",\\r\\n        \\\"typescript\\\": \\\"ts-node\\\",\\r\\n        \\\"coffeescript\\\": \\\"coffee\\\",\\r\\n        \\\"scala\\\": \\\"scala\\\",\\r\\n        \\\"swift\\\": \\\"swift\\\",\\r\\n        \\\"julia\\\": \\\"julia\\\",\\r\\n        \\\"crystal\\\": \\\"crystal\\\",\\r\\n        \\\"ocaml\\\": \\\"ocaml\\\",\\r\\n        \\\"r\\\": \\\"Rscript\\\",\\r\\n        \\\"applescript\\\": \\\"osascript\\\",\\r\\n        \\\"clojure\\\": \\\"lein exec\\\",\\r\\n        \\\"haxe\\\": \\\"haxe --cwd $dirWithoutTrailingSlash --run $fileNameWithoutExt\\\",\\r\\n        \\\"rust\\\": \\\"cd $dir && rustc $fileName && $dir$fileNameWithoutExt\\\",\\r\\n        \\\"racket\\\": \\\"racket\\\",\\r\\n        \\\"scheme\\\": \\\"csi -script\\\",\\r\\n        \\\"ahk\\\": \\\"autohotkey\\\",\\r\\n        \\\"autoit\\\": \\\"autoit3\\\",\\r\\n        \\\"dart\\\": \\\"dart\\\",\\r\\n        \\\"pascal\\\": \\\"cd $dir && fpc $fileName && $dir$fileNameWithoutExt\\\",\\r\\n        \\\"d\\\": \\\"cd $dir && dmd $fileName && $dir$fileNameWithoutExt\\\",\\r\\n        \\\"haskell\\\": \\\"runghc\\\",\\r\\n        \\\"nim\\\": \\\"nim compile --verbosity:0 --hints:off --run\\\",\\r\\n        \\\"lisp\\\": \\\"sbcl --script\\\",\\r\\n        \\\"kit\\\": \\\"kitc --run\\\",\\r\\n        \\\"v\\\": \\\"v run\\\",\\r\\n        \\\"sass\\\": \\\"sass --style expanded\\\",\\r\\n        \\\"scss\\\": \\\"scss --style expanded\\\",\\r\\n        \\\"less\\\": \\\"cd $dir && lessc $fileName $fileNameWithoutExt.css\\\",\\r\\n        \\\"FortranFreeForm\\\": \\\"cd $dir && gfortran $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt\\\",\\r\\n        \\\"fortran-modern\\\": \\\"cd $dir && gfortran $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt\\\",\\r\\n        \\\"fortran_fixed-form\\\": \\\"cd $dir && gfortran $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt\\\",\\r\\n        \\\"fortran\\\": \\\"cd $dir && gfortran $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt\\\",\\r\\n        \\\"sml\\\": \\\"cd $dir && sml $fileName\\\",\\r\\n        \\\"mojo\\\": \\\"mojo run\\\"\\r\\n    },\\r\\n    \\\"extensions.ignoreRecommendations\\\": true,\\r\\n    \\\"workbench.colorCustomizations\\\": {\\r\\n        \\\"terminal.background\\\": \\\"#000000\\\"\\r\\n    },\\r\\n    \\\"code-runner.runInTerminal\\\": true,\\r\\n    \\\"code-runner.ignoreSelection\\\": true,\\r\\n    \\\"material-icon-theme.files.associations\\\": {\\r\\n        \\\"**.inp\\\": \\\"log\\\",\\r\\n        \\\"**.out\\\": \\\"log\\\",\\r\\n        \\\"**.ans\\\": \\\"log\\\",\\r\\n    },\\r\\n    \\\"background.autoInstall\\\": false,\\r\\n    \\\"code-runner.clearPreviousOutput\\\": true,\\r\\n    \\\"[cpp]\\\": {\\r\\n        \\\"editor.defaultFormatter\\\": \\\"ms-vscode.cpptools\\\"\\r\\n    },\\r\\n    \\\"C_Cpp.clang_format_fallbackStyle\\\": \\\"{ BasedOnStyle: Google,IndentWidth: 4,TabWidth: 4, UseTab: Always, ColumnLimit: 80 }\\\",\\r\\n    \\\"cph.general.defaultLanguage\\\": \\\"cpp\\\",\\r\\n    \\\"cph.language.cpp.SubmissionCompiler\\\": \\\"GNU G++20 13.2 (64 bit, winlibs)\\\",\\r\\n    \\\"files.defaultLanguage\\\": \\\"cpp\\\",\\r\\n    \\\"cph.general.saveLocation\\\": \\\"D:\\\\\\\\code\\\\\\\\practice\\\\\\\\codeforces\\\\\\\\trash\\\",\\r\\n    \\\"cph.general.useShortCodeForcesName\\\": true,\\r\\n    \\\"cph.language.cpp.Args\\\": \\\"-DLOCAL -ID:/code/_archive_/lib -std=c++20 -Wall -Wl,--stack=100000000\\\",\\r\\n    \\\"markdown-preview-enhanced.codeBlockTheme\\\": \\\"monokai.css\\\",\\r\\n    \\\"markdown-preview-enhanced.previewTheme\\\": \\\"monokai.css\\\",\\r\\n    \\\"chatgpt.lang\\\": \\\"en\\\",\\r\\n    \\\"editor.insertSpaces\\\": false,\\r\\n    \\\"C_Cpp.default.cppStandard\\\": \\\"c++20\\\",\\r\\n    \\\"terminal.integrated.enableMultiLinePasteWarning\\\": false,\\r\\n    \\\"editor.wordWrap\\\": \\\"on\\\",\\r\\n    \\\"settingsSync.ignoredSettings\\\": [\\r\\n        \\\"-C_Cpp.default.defines\\\",\\r\\n        \\\"-C_Cpp.default.customConfigurationVariables\\\",\\r\\n        \\\"-C_Cpp.default.includePath\\\",\\r\\n        \\\"-C_Cpp.default.compilerPath\\\"\\r\\n    ],\\r\\n}\"}","keybindings":"{\"keybindings\":\"// Place your key bindings in this file to override the defaultsauto[]\\r\\n[\\r\\n    {\\r\\n        \\\"key\\\": \\\"ctrl+t\\\",\\r\\n        \\\"command\\\": \\\"trailing-spaces.deleteTrailingSpaces\\\",\\r\\n        \\\"when\\\": \\\"editorTextFocus\\\"\\r\\n    },\\r\\n    {\\r\\n        \\\"key\\\": \\\"ctrl+alt+x ctrl+alt+x\\\",\\r\\n        \\\"command\\\": \\\"editor.action.changeAll\\\",\\r\\n        \\\"when\\\": \\\"editorTextFocus && !editorReadonly\\\"\\r\\n    },\\r\\n    {\\r\\n        \\\"key\\\": \\\"ctrl+f2\\\",\\r\\n        \\\"command\\\": \\\"-editor.action.changeAll\\\",\\r\\n        \\\"when\\\": \\\"editorTextFocus && !editorReadonly\\\"\\r\\n    },\\r\\n    {\\r\\n        \\\"key\\\": \\\"ctrl+f2\\\",\\r\\n        \\\"command\\\": \\\"bookmarks.toggle\\\",\\r\\n        \\\"when\\\": \\\"editorTextFocus\\\"\\r\\n    },\\r\\n    {\\r\\n        \\\"key\\\": \\\"ctrl+alt+k\\\",\\r\\n        \\\"command\\\": \\\"-bookmarks.toggle\\\",\\r\\n        \\\"when\\\": \\\"editorTextFocus\\\"\\r\\n    },\\r\\n    {\\r\\n        \\\"key\\\": \\\"f2\\\",\\r\\n        \\\"command\\\": \\\"editor.action.rename\\\",\\r\\n        \\\"when\\\": \\\"editorHasRenameProvider && editorTextFocus && !editorReadonly\\\"\\r\\n    },\\r\\n    {\\r\\n        \\\"key\\\": \\\"f2\\\",\\r\\n        \\\"command\\\": \\\"-editor.action.rename\\\",\\r\\n        \\\"when\\\": \\\"editorHasRenameProvider && editorTextFocus && !editorReadonly\\\"\\r\\n    },\\r\\n    {\\r\\n        \\\"key\\\": \\\"ctrl+u ctrl+s\\\",\\r\\n        \\\"command\\\": \\\"workbench.action.openSnippets\\\"\\r\\n    },\\r\\n    {\\r\\n        \\\"key\\\": \\\"f2\\\",\\r\\n        \\\"command\\\": \\\"renameFile\\\",\\r\\n        \\\"when\\\": \\\"explorerViewletVisible && filesExplorerFocus && !explorerResourceIsRoot && !explorerResourceReadonly && !inputFocus\\\"\\r\\n    },\\r\\n    {\\r\\n        \\\"key\\\": \\\"f2\\\",\\r\\n        \\\"command\\\": \\\"-renameFile\\\",\\r\\n        \\\"when\\\": \\\"explorerViewletVisible && filesExplorerFocus && !explorerResourceIsRoot && !explorerResourceReadonly && !inputFocus\\\"\\r\\n    },\\r\\n    {\\r\\n        \\\"key\\\": \\\"ctrl+shift+c ctrl+shift+d\\\",\\r\\n        \\\"command\\\": \\\"workbench.view.debug\\\",\\r\\n        \\\"when\\\": \\\"viewContainer.workbench.view.debug.enabled\\\"\\r\\n    },\\r\\n    {\\r\\n        \\\"key\\\": \\\"ctrl+b\\\",\\r\\n        \\\"command\\\": \\\"github.copilot.generate\\\",\\r\\n        \\\"when\\\": \\\"editorTextFocus && github.copilot.activated && !commentEditorFocused && !inInteractiveInput && !interactiveEditorFocused\\\"\\r\\n    },\\r\\n    {\\r\\n        \\\"key\\\": \\\"ctrl+enter\\\",\\r\\n        \\\"command\\\": \\\"-github.copilot.generate\\\",\\r\\n        \\\"when\\\": \\\"editorTextFocus && github.copilot.activated && !commentEditorFocused && !inInteractiveInput && !interactiveEditorFocused\\\"\\r\\n    },\\r\\n]\",\"platform\":3}","snippets":"{\"snippets\":{\"marvinthang.code-snippets\":\"{\\r\\n    \\\"START\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"START\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"/*************************************\\\",\\r\\n            \\\"*    author: marvinthang             *\\\",\\r\\n            \\\"*    created: $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND    *\\\",\\r\\n            \\\"*************************************/\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"#include <bits/stdc++.h>\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"using namespace std;\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"#define             fi  first\\\",\\r\\n            \\\"#define             se  second\\\",\\r\\n            \\\"#define           left  ___left___\\\",\\r\\n            \\\"#define          right  ___right___\\\",\\r\\n            \\\"#define   scan_op(...)  istream & operator >> (istream &in, __VA_ARGS__ &u)\\\",\\r\\n            \\\"#define  print_op(...)  ostream & operator << (ostream &out, const __VA_ARGS__ &u)\\\",\\r\\n            \\\"#define     file(name)  if (fopen(name\\\\\\\".inp\\\\\\\", \\\\\\\"r\\\\\\\")) { freopen(name\\\\\\\".inp\\\\\\\", \\\\\\\"r\\\\\\\", stdin); freopen(name\\\\\\\".out\\\\\\\", \\\\\\\"w\\\\\\\", stdout); }\\\",\\r\\n            \\\"#ifdef LOCAL\\\",\\r\\n            \\\"\\\\t#include \\\\\\\"debug.h\\\\\\\"\\\",\\r\\n            \\\"#else\\\",\\r\\n            \\\"\\\\t#define DB(...)\\\",\\r\\n            \\\"\\\\t#define db(...) \\\\\\\"\\\\\\\"\\\",\\r\\n            \\\"\\\\t#define debug(...)\\\",\\r\\n            \\\"#endif\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"namespace std {\\\",\\r\\n            \\\"template <class U, class V> scan_op(pair <U, V>) { return in >> u.first >> u.second; }\\\",\\r\\n            \\\"template <class T> scan_op(vector <T>) { for (size_t i = 0; i < u.size(); ++i) in >> u[i]; return in; }\\\",\\r\\n            \\\"template <class U, class V> print_op(pair <U, V>) { return out << '(' << u.first << \\\\\\\", \\\\\\\" << u.second << ')'; }\\\",\\r\\n            \\\"template <size_t i, class T> ostream &print_tuple_utils(ostream &out, const T &tup) { if constexpr(i == tuple_size<T>::value) return out << \\\\\\\")\\\\\\\"; else return print_tuple_utils<i + 1, T>(out << (i ? \\\\\\\", \\\\\\\" : \\\\\\\"(\\\\\\\") << get<i>(tup), tup); }\\\",\\r\\n            \\\"template <class...U> print_op(tuple <U...>) { return print_tuple_utils<0, tuple <U...>>(out, u); }\\\",\\r\\n            \\\"template <class Con, class = decltype(begin(declval<Con>()))>typename enable_if <!is_same<Con, string>::value, ostream &>::type operator << (ostream &out, const Con &con) { out << '{'; for (__typeof(con.begin()) it = con.begin(); it != con.end(); ++it) out << (it == con.begin() ? \\\\\\\"\\\\\\\" : \\\\\\\", \\\\\\\") << *it; return out << '}'; }\\\",\\r\\n            \\\"template <class T> print_op(stack <T>) { vector <T> v; stack <T> st = u; while (!st.empty()) v.push_back(st.top()), st.pop(); reverse(v.begin(), v.end()); return out << v; }\\\",\\r\\n            \\\"template <class T> print_op(queue <T>) { queue <T> q = u; out << '{'; while (!q.empty()) { out << q.front(); q.pop(); if (!q.empty()) out << \\\\\\\", \\\\\\\"; } out << '}'; return out; }\\\",\\r\\n            \\\"template <class T, class X, class Y> print_op(priority_queue <T, X, Y>) { priority_queue <T, X, Y> pq = u; out << '{'; while (!pq.empty()) { out << pq.top(); pq.pop(); if (!pq.empty()) out << \\\\\\\", \\\\\\\"; } out << '}'; return out; }\\\",\\r\\n            \\\"template <class Fun> class y_combinator_result { Fun fun_; public: template <class T> explicit y_combinator_result(T &&fun): fun_(forward<T>(fun)) {} template <class...Args> decltype(auto)operator()(Args &&...args) { return fun_(ref(*this), forward<Args>(args)...); } };\\\",\\r\\n            \\\"template <class Fun> decltype(auto)y_combinator(Fun &&fun) { return y_combinator_result<decay_t<Fun>>(forward<Fun>(fun)); }\\\",\\r\\n            \\\"template <typename T, int D> struct Vec: public vector <Vec<T, D - 1>> { static_assert(D >= 1, \\\\\\\"Vector dimension must be greater than zero!\\\\\\\"); template <typename ...Args> Vec(int n = 0, Args ...args): vector <Vec<T, D - 1>>(n, Vec<T, D - 1>(args...)) {} };\\\",\\r\\n            \\\"template <typename T> struct Vec<T, 1>: public vector<T>{ Vec(int n = 0, const T &val = T()): vector<T>(n, val) {} };\\\",\\r\\n            \\\"#if __cplusplus < 202002L\\\",\\r\\n            \\\"\\\\ttemplate <class T> int ssize(const T &a) { return a.size(); }\\\",\\r\\n            \\\"#endif\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"void process(void) {\\\",\\r\\n            \\\"\\\\t$0\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"int main(void) {\\\",\\r\\n            \\\"\\\\tios_base::sync_with_stdio(false); cin.tie(nullptr);\\\",\\r\\n            \\\"\\\\tfile(\\\\\\\"${TM_DIRECTORY/^.+[\\\\\\\\/\\\\\\\\\\\\\\\\]+(.*)$/$1/}\\\\\\\");\\\",\\r\\n            \\\"\\\\t// int t; cin >> t; while (t--)\\\",\\r\\n            \\\"\\\\tprocess();\\\",\\r\\n            \\\"\\\\treturn (0^0);\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"START\\\"\\r\\n    },\\r\\n    \\\"AHO_CORASICK_ARR\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"AHO_CORASICK_ARR\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"const int ALPHABET_SIZE = 26;\\\",\\r\\n            \\\"struct Node {\\\",\\r\\n            \\\"\\\\tint parent, parChar;\\\",\\r\\n            \\\"\\\\tint children[ALPHABET_SIZE];\\\",\\r\\n            \\\"\\\\tint fail, nxt[ALPHABET_SIZE];\\\",\\r\\n            \\\"\\\\tint cnt;\\\",\\r\\n            \\\"\\\\tNode(int parent = -1, int parChar = -1): parent(parent), parChar(parChar) {\\\",\\r\\n            \\\"\\\\t\\\\tfail = -1;\\\",\\r\\n            \\\"\\\\t\\\\tcnt = 0;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < ALPHABET_SIZE; ++i) children[i] = nxt[i] = -1;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\" \\\",\\r\\n            \\\"vector <Node> nodes;\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"void addString(const string &s) {\\\",\\r\\n            \\\"\\\\tint p = 0;\\\",\\r\\n            \\\"\\\\tREP(i, s.size()) {\\\",\\r\\n            \\\"\\\\t\\\\tint c = s[i] - 'a';\\\",\\r\\n            \\\"\\\\t\\\\tif (!~nodes[p].children[c]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tnodes[p].children[c] = nodes.size();\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tnodes.push_back(Node(p, c));\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tp = nodes[p].children[c];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\t++nodes[p].cnt;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\" \\\",\\r\\n            \\\"void AC_BFS(void) {\\\",\\r\\n            \\\"\\\\tqueue <int> q;\\\",\\r\\n            \\\"\\\\tnodes[0].fail = 0;\\\",\\r\\n            \\\"\\\\tnodes[0].cnt = 0;\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < ALPHABET_SIZE; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tif (~nodes[0].children[i]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tnodes[0].nxt[i] = nodes[0].children[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tq.push(nodes[0].children[i]);\\\",\\r\\n            \\\"\\\\t\\\\t} else nodes[0].nxt[i] = 0;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\twhile (!q.empty()) {\\\",\\r\\n            \\\"\\\\t\\\\tint p = q.front(); q.pop();\\\",\\r\\n            \\\"\\\\t\\\\tnodes[p].fail = !nodes[p].parent ? 0 : nodes[nodes[nodes[p].parent].fail].nxt[nodes[p].parChar];\\\",\\r\\n            \\\"\\\\t\\\\tnodes[p].cnt += nodes[nodes[p].fail].cnt;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < ALPHABET_SIZE; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (~nodes[p].children[i]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tnodes[p].nxt[i] = nodes[p].children[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tq.push(nodes[p].children[i]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t} else nodes[p].nxt[i] = nodes[nodes[p].fail].nxt[i];\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"AHO_CORASICK_ARR\\\"\\r\\n    },\\r\\n    \\\"AHO_CORASICK_PTR\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"AHO_CORASICK_PTR\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"const int ALPHABET_SIZE = 26;\\\",\\r\\n            \\\"struct Node {\\\",\\r\\n            \\\"\\\\tNode *parent;\\\",\\r\\n            \\\"\\\\tint parChar;\\\",\\r\\n            \\\"\\\\tNode *children[ALPHABET_SIZE];\\\",\\r\\n            \\\"\\\\tNode *fail, *nxt[ALPHABET_SIZE];\\\",\\r\\n            \\\"\\\\tint cnt;\\\",\\r\\n            \\\"\\\\tNode(Node *parent = nullptr, int parChar = -1): parent(parent), parChar(parChar) {\\\",\\r\\n            \\\"\\\\t\\\\tfail = nullptr;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < ALPHABET_SIZE; ++i) children[i] = nxt[i] = nullptr;\\\",\\r\\n            \\\"\\\\t\\\\tcnt = 0;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\" \\\",\\r\\n            \\\"int numNode;\\\",\\r\\n            \\\"Node *root;\\\",\\r\\n            \\\" \\\",\\r\\n            \\\"void addString(const string &s) {\\\",\\r\\n            \\\"\\\\tNode *p = root;\\\",\\r\\n            \\\"\\\\tREP(i, s.size()) {\\\",\\r\\n            \\\"\\\\t\\\\tint c = s[i] - 'a';\\\",\\r\\n            \\\"\\\\t\\\\tif (p->children[c] == nullptr) p->children[c] = new Node(p, c);\\\",\\r\\n            \\\"\\\\t\\\\tp = p->children[c];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\t++p->cnt;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\" \\\",\\r\\n            \\\"void AC_BFS(void) {\\\",\\r\\n            \\\"\\\\tqueue <Node*> q;\\\",\\r\\n            \\\"\\\\troot->fail = root;\\\",\\r\\n            \\\"\\\\troot->cnt = 0;\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < ALPHABET_SIZE; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tif (root->children[i] != nullptr) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\troot->nxt[i] = root->children[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tq.push(root->children[i]);\\\",\\r\\n            \\\"\\\\t\\\\t} else root->nxt[i] = root;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\twhile (!q.empty()) {\\\",\\r\\n            \\\"\\\\t\\\\tNode *p = q.front(); q.pop();\\\",\\r\\n            \\\"\\\\t\\\\tp->fail = p->parent == root ? root : p->parent->fail->nxt[p->parChar];\\\",\\r\\n            \\\"\\\\t\\\\tp->cnt += p->fail->cnt;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < ALPHABET_SIZE; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (p->children[i] != nullptr) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tp->nxt[i] = p->children[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tq.push(p->children[i]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t} else p->nxt[i] = p->fail->nxt[i];\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"AHO_CORASICK_PTR\\\"\\r\\n    },\\r\\n    \\\"SPARSE_TABLE\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"SPARSE_TABLE\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"template <class T, T (*op) (T, T)> class SparseTable {\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tSparseTable() = default;\\\",\\r\\n            \\\"\\\\tSparseTable(const vector <T> &v): table{v}, n(v.size()) {\\\",\\r\\n            \\\"\\\\t\\\\tfor (int k = 1; (1 << k) <= n; ++k) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\ttable.emplace_back(n - (1 << k) + 1);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int i = 0; i + (1 << k) <= n; i++) table[k][i] = op(table[k - 1][i], table[k - 1][i + (1 << (k - 1))]);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tT get(int l, int r) { // [l, r - 1]\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= l && l < r && r <= n);\\\",\\r\\n            \\\"\\\\t\\\\tint k = __lg(r - l);\\\",\\r\\n            \\\"\\\\t\\\\treturn op(table[k][l], table[k][r - (1 << k)]);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"private:\\\",\\r\\n            \\\"\\\\tvector <vector <T>> table;\\\",\\r\\n            \\\"\\\\tint n;\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <class T> T _min(T x, T y) { return x < y ? x : y; }\\\",\\r\\n            \\\"template <class T> T _max(T x, T y) { return x > y ? x : y; }\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"SPARSE_TABLE\\\"\\r\\n    },\\r\\n    \\\"SEGTREE\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"SEGTREE\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"template<\\\",\\r\\n            \\\"\\\\tclass T,        // data type for nodes\\\",\\r\\n            \\\"\\\\tT (*op) (T, T), // operator to combine 2 nodes\\\",\\r\\n            \\\"\\\\tT (*e)()        // identity element\\\",\\r\\n            \\\"\\\\t>\\\",\\r\\n            \\\"struct SegTree {\\\",\\r\\n            \\\"\\\\tSegTree(): SegTree(0) {}\\\",\\r\\n            \\\"\\\\tSegTree(int n) : SegTree(vector<T>(n, e())) {}\\\",\\r\\n            \\\"\\\\tSegTree(const vector <T>& v) : n(v.size()) {\\\",\\r\\n            \\\"\\\\t\\\\tlog = 0;\\\",\\r\\n            \\\"\\\\t\\\\twhile ((1 << log) < n) ++log;\\\",\\r\\n            \\\"\\\\t\\\\tsize = 1 << log;\\\",\\r\\n            \\\"\\\\t\\\\td = vector<T>(size << 1, e());\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) d[size + i] = v[i];\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = size - 1; i > 0; --i) update(i);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\t// 0 <= p < n\\\",\\r\\n            \\\"\\\\tvoid set(int p, T x) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= p && p < n);\\\",\\r\\n            \\\"\\\\t\\\\tp += size; d[p] = x;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 1; i <= log; ++i) update(p >> i);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\t// 0 <= p < n\\\",\\r\\n            \\\"\\\\tT get(int p) const {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= p && p < n);\\\",\\r\\n            \\\"\\\\t\\\\treturn d[p + size];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\t// Get product in range [l, r-1]\\\",\\r\\n            \\\"\\\\t// 0 <= l <= r <= n\\\",\\r\\n            \\\"\\\\t// For empty segment (l == r) -> return e()\\\",\\r\\n            \\\"\\\\tT prod(int l, int r) const {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= l && l <= r && r <= n);\\\",\\r\\n            \\\"\\\\t\\\\tT sml = e(), smr = e();\\\",\\r\\n            \\\"\\\\t\\\\tl += size; r += size;\\\",\\r\\n            \\\"\\\\t\\\\twhile (l < r) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (l & 1) sml = op(sml, d[l++]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (r & 1) smr = op(d[--r], smr);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tl >>= 1; r >>= 1;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn op(sml, smr);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tT all_prod() const { return d[1]; }\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\t// Binary search on SegTree to find largest r:\\\",\\r\\n            \\\"\\\\t//\\\\tf(op(a[l] .. a[r-1])) = true   (assuming empty array is always true)\\\",\\r\\n            \\\"\\\\t//\\\\tf(op(a[l] .. a[r])) = false\\\\t(assuming op(..., a[n]), which is out of bound, is always false)\\\",\\r\\n            \\\"\\\\ttemplate <bool (*f)(T)> int max_right(int l) const { return max_right(l, [](T x) { return f(x); }); }\\\",\\r\\n            \\\"\\\\ttemplate <class F> int max_right(int l, F f) const {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= l && l <= n);\\\",\\r\\n            \\\"\\\\t\\\\tassert(f(e()));\\\",\\r\\n            \\\"\\\\t\\\\tif (l == n) return n;\\\",\\r\\n            \\\"\\\\t\\\\tl += size;\\\",\\r\\n            \\\"\\\\t\\\\tT sm = e();\\\",\\r\\n            \\\"\\\\t\\\\tdo {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\twhile (!(l & 1)) l >>= 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (!f(op(sm, d[l]))) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\twhile (l < size) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tl = l << 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (f(op(sm, d[l]))) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsm = op(sm, d[l]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tl++;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\treturn l - size;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tsm = op(sm, d[l]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tl++;\\\",\\r\\n            \\\"\\\\t\\\\t} while ((l & -l) != l);\\\",\\r\\n            \\\"\\\\t\\\\treturn n;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\t// Binary search on SegTree to find smallest l:\\\",\\r\\n            \\\"\\\\t//\\\\tf(op(a[l] .. a[r-1])) = true\\\\t  (assuming empty array is always true)\\\",\\r\\n            \\\"\\\\t//\\\\tf(op(a[l-1] .. a[r-1])) = false   (assuming op(a[-1], ..), which is out of bound, is always false)\\\",\\r\\n            \\\"\\\\ttemplate <bool (*f)(T)> int min_left(int r) const { return min_left(r, [](T x) { return f(x); }); }\\\",\\r\\n            \\\"\\\\ttemplate <class F> int min_left(int r, F f) const {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= r && r <= n);\\\",\\r\\n            \\\"\\\\t\\\\tassert(f(e()));\\\",\\r\\n            \\\"\\\\t\\\\tif (r == 0) return 0;\\\",\\r\\n            \\\"\\\\t\\\\tr += size;\\\",\\r\\n            \\\"\\\\t\\\\tT sm = e();\\\",\\r\\n            \\\"\\\\t\\\\tdo {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tr--;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\twhile (r > 1 && (r & 1)) r >>= 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (!f(op(d[r], sm))) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\twhile (r < size) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tr = r << 1 | 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (f(op(d[r], sm))) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsm = op(d[r], sm);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tr--;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\treturn r + 1 - size;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tsm = op(d[r], sm);\\\",\\r\\n            \\\"\\\\t\\\\t} while ((r & -r) != r);\\\",\\r\\n            \\\"\\\\t\\\\treturn 0;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"private:\\\",\\r\\n            \\\"\\\\tint n, size, log;\\\",\\r\\n            \\\"\\\\tvector <T> d;\\\",\\r\\n            \\\"\\\\tvoid update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"SEGTREE\\\"\\r\\n    },\\r\\n    \\\"RANDOM\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"RANDOM\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"mt19937_64 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\\\",\\r\\n            \\\"template <class T> T rand(T l, T h) { return uniform_int_distribution <T> (l, h) (rng); }\\\",\\r\\n            \\\"template <class T> T rand(T h) { return uniform_int_distribution <T> (0, h - 1) (rng); }\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"RANDOM\\\"\\r\\n    },\\r\\n    \\\"PARTIALLY_PERSISTENT_DSU\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"PARTIALLY_PERSISTENT_DSU\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"struct PartiallyPersistentDisjointSet {\\\",\\r\\n            \\\"\\\\tvector <int> lab, t_unite;\\\",\\r\\n            \\\"\\\\tPartiallyPersistentDisjointSet(int n = 0): lab(n + 1, -1), t_unite(n + 1, (int) 1e9) {}\\\",\\r\\n            \\\"\\\\tvoid reset(void) {\\\",\\r\\n            \\\"\\\\t\\\\tfill(lab.begin(), lab.end(), -1);\\\",\\r\\n            \\\"\\\\t\\\\tfill(t_unite.begin(), t_unite.end(), (int) 1e9);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid resize(int n) {\\\",\\r\\n            \\\"\\\\t\\\\tlab.assign(n + 1, -1);\\\",\\r\\n            \\\"\\\\t\\\\tt_unite.assign(n + 1, (int) 1e9);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tbool connected(int t, int u, int v) { return find(t, u) == find(t, v); }\\\",\\r\\n            \\\"\\\\tbool isRoot(int t, int u) { return t_unite[u] > t; }\\\",\\r\\n            \\\"\\\\tint size(int t, int u) { return -lab[find(t, u)]; }\\\",\\r\\n            \\\"\\\\tint find(int t, int u) { return t_unite[u] > t ? u : find(t, lab[u]); }\\\",\\r\\n            \\\"\\\\tbool join(int t, int u, int v) {\\\",\\r\\n            \\\"\\\\t\\\\tif ((u = find(t, u)) == (v = find(t, v))) return false;\\\",\\r\\n            \\\"\\\\t\\\\tif (lab[u] > lab[v]) swap(u, v);\\\",\\r\\n            \\\"\\\\t\\\\tlab[u] += lab[v]; lab[v] = u; t_unite[v] = t;\\\",\\r\\n            \\\"\\\\t\\\\treturn true;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"using PPDS = PartiallyPersistentDisjointSet;\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"PARTIALLY_PERSISTENT_DSU\\\"\\r\\n    },\\r\\n    \\\"ORDERED_SET\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"ORDERED_SET\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"#include <ext/pb_ds/assoc_container.hpp>\\\",\\r\\n            \\\"#include <ext/pb_ds/tree_policy.hpp>\\\",\\r\\n            \\\"using namespace __gnu_pbds;\\\",\\r\\n            \\\"template <typename T>\\\",\\r\\n            \\\"using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"ORDERED_SET\\\"\\r\\n    },\\r\\n    \\\"OFFSET_VECTOR\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"OFFSET_VECTOR\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"template <typename V> struct OffsetVector {\\\",\\r\\n            \\\"\\\\t// Index should be in [minIndex, maxIndex].\\\",\\r\\n            \\\"\\\\t// minIndex and maxIndex can be negative.\\\",\\r\\n            \\\"\\\\tOffsetVector(int minIndex, int maxIndex): x(maxIndex - minIndex + 1), offset(minIndex) {}\\\",\\r\\n            \\\"\\\\tV & operator [] (int index) { return x[index - offset]; }\\\",\\r\\n            \\\"\\\\tauto begin() { return x.begin(); }\\\",\\r\\n            \\\"\\\\tauto end() { return x.end(); }\\\",\\r\\n            \\\"\\\\tauto size() { return x.size(); }\\\",\\r\\n            \\\"private:\\\",\\r\\n            \\\"\\\\tvector <V> x;\\\",\\r\\n            \\\"\\\\tint offset;\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"OFFSET_VECTOR\\\"\\r\\n    },\\r\\n    \\\"RABIN_MILLER\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"RABIN_MILLER\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"namespace RABIN_MILLER {\\\",\\r\\n            \\\"unsigned mod_mult(unsigned a, unsigned b, unsigned m) { return (uint64_t) a * b % m; }\\\",\\r\\n            \\\"uint64_t mod_mult64(uint64_t a, uint64_t b, uint64_t m) { return __int128_t(a) * b % m; }\\\",\\r\\n            \\\"unsigned mod_pow(unsigned a, uint64_t b, unsigned m) {\\\",\\r\\n            \\\"\\\\tunsigned ret = 1;\\\",\\r\\n            \\\"\\\\tfor (; b; b >>= 1, a = mod_mult(a, a, m)) if (b & 1) ret = mod_mult(ret, a, m);\\\",\\r\\n            \\\"\\\\treturn ret;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"uint64_t mod_pow64(uint64_t a, uint64_t b, uint64_t m) {\\\",\\r\\n            \\\"\\\\tuint64_t ret = 1;\\\",\\r\\n            \\\"\\\\tfor (; b; b >>= 1, a = mod_mult64(a, a, m)) if (b & 1) ret = mod_mult64(ret, a, m);\\\",\\r\\n            \\\"\\\\treturn ret;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"bool is_prime32(unsigned n) {\\\",\\r\\n            \\\"\\\\tif (n <= 3) return (n >= 2);\\\",\\r\\n            \\\"\\\\tstatic const unsigned small[] = {\\\",\\r\\n            \\\"\\\\t\\\\t2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\\\",\\r\\n            \\\"\\\\t\\\\t71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139,\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tfor (size_t i = 0; i < 34; ++i) if (n%small[i] == 0) return n == small[i];\\\",\\r\\n            \\\"\\\\tstatic const unsigned millerrabin[] = {2, 7, 61};\\\",\\r\\n            \\\"\\\\tunsigned s = n - 1, r = 0;\\\",\\r\\n            \\\"\\\\twhile (!(s & 1)) s >>= 1, ++r;\\\",\\r\\n            \\\"\\\\tfor (size_t i = 0, j; i < 3; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tunsigned md = mod_pow(millerrabin[i], s, n);\\\",\\r\\n            \\\"\\\\t\\\\tif (md == 1) continue;\\\",\\r\\n            \\\"\\\\t\\\\tfor (j = 1; j < r && md != n - 1; ++j) md = mod_mult(md, md, n);\\\",\\r\\n            \\\"\\\\t\\\\tif (md != n - 1) return false;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn true;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"bool is_prime64(uint64_t n) {\\\",\\r\\n            \\\"\\\\tif (n <= 3) return (n >= 2);\\\",\\r\\n            \\\"\\\\tstatic const uint64_t small[] = {\\\",\\r\\n            \\\"\\\\t\\\\t2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\\\",\\r\\n            \\\"\\\\t\\\\t71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139,\\\",\\r\\n            \\\"\\\\t\\\\t149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tfor (size_t i = 0; i < 46; ++i) if (n % small[i] == 0) return n == small[i];\\\",\\r\\n            \\\"\\\\tstatic const uint64_t millerrabin[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};\\\",\\r\\n            \\\"\\\\tstatic const uint64_t A014233[] = {\\\",\\r\\n            \\\"\\\\t\\\\t2047LL, 1373653LL, 25326001LL, 3215031751LL, 2152302898747LL,\\\",\\r\\n            \\\"\\\\t\\\\t3474749660383LL, 341550071728321LL, 341550071728321LL,\\\",\\r\\n            \\\"\\\\t\\\\t3825123056546413051LL, 3825123056546413051LL, 3825123056546413051LL, 0\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tuint64_t s = n - 1, r = 0;\\\",\\r\\n            \\\"\\\\twhile (!(s & 1)) s >>= 1, ++r;\\\",\\r\\n            \\\"\\\\tfor (size_t i = 0, j; i < 11; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tuint64_t md = mod_pow64(millerrabin[i], s, n);\\\",\\r\\n            \\\"\\\\t\\\\tif (md != 1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (j = 1; j < r && md != n - 1; ++j) md = mod_mult64(md, md, n);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (md != n - 1) return false;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tif (n < A014233[i]) return true;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn true;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"} using namespace RABIN_MILLER;\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"RABIN_MILLER\\\"\\r\\n    },\\r\\n    \\\"NUMBER_THEORETIC_TRANSFORM\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"NUMBER_THEORETIC_TRANSFORM\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"namespace NUMBER_THEORETIC_TRANSFORM {\\\",\\r\\n            \\\"template <typename Modular> class NTT {\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tstatic int md, base, max_base;\\\",\\r\\n            \\\"\\\\tstatic Modular root;\\\",\\r\\n            \\\"\\\\tstatic vector <Modular> roots;\\\",\\r\\n            \\\"\\\\tstatic vector <int> rev;\\\",\\r\\n            \\\"\\\\tstatic void clear() {\\\",\\r\\n            \\\"\\\\t\\\\troot = base = max_base = 0;\\\",\\r\\n            \\\"\\\\t\\\\troots.clear();\\\",\\r\\n            \\\"\\\\t\\\\trev.clear();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tstatic void init() {\\\",\\r\\n            \\\"\\\\t\\\\tmd = Modular::mod();\\\",\\r\\n            \\\"\\\\t\\\\tassert(md >= 3 && md % 2 == 1);\\\",\\r\\n            \\\"\\\\t\\\\tauto tmp = md - 1;\\\",\\r\\n            \\\"\\\\t\\\\tmax_base = 0;\\\",\\r\\n            \\\"\\\\t\\\\twhile (!(tmp & 1)) tmp >>= 1, ++max_base;\\\",\\r\\n            \\\"\\\\t\\\\troot = 2;\\\",\\r\\n            \\\"\\\\t\\\\twhile (root.pow((md - 1) >> 1).val() == 1) ++root;\\\",\\r\\n            \\\"\\\\t\\\\tassert(root.pow(md - 1) == 1);\\\",\\r\\n            \\\"\\\\t\\\\troot = root.pow((md - 1) >> max_base);\\\",\\r\\n            \\\"\\\\t\\\\tbase = 1; rev = {0, 1}; roots = {0, 1};\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tstatic void ensure_base(int nbase) {\\\",\\r\\n            \\\"\\\\t\\\\tif (md != Modular::mod()) clear();\\\",\\r\\n            \\\"\\\\t\\\\tif (roots.empty()) init();\\\",\\r\\n            \\\"\\\\t\\\\tif (nbase <= base) return;\\\",\\r\\n            \\\"\\\\t\\\\tassert(nbase <= max_base);\\\",\\r\\n            \\\"\\\\t\\\\trev.resize(1 << nbase);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < (1 << nbase); ++i) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\\\",\\r\\n            \\\"\\\\t\\\\troots.resize(1 << nbase);\\\",\\r\\n            \\\"\\\\t\\\\twhile (base < nbase) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tModular z = root.pow(1 << (max_base - 1 - base));\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int i = 1 << (base - 1); i < (1 << base); ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\troots[i << 1] = roots[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\troots[i << 1 | 1] = roots[i] * z;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t++base;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tstatic void fft(vector <Modular> &a) {\\\",\\r\\n            \\\"\\\\t\\\\tint n = (int) a.size();\\\",\\r\\n            \\\"\\\\t\\\\tassert((n & (n - 1)) == 0);\\\",\\r\\n            \\\"\\\\t\\\\tint zeros = __builtin_ctz(n);\\\",\\r\\n            \\\"\\\\t\\\\tensure_base(zeros);\\\",\\r\\n            \\\"\\\\t\\\\tint shift = base - zeros;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) if (i < (rev[i] >> shift)) swap(a[i], a[rev[i] >> shift]);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int k = 1; k < n; k <<= 1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int i = 0; i < n; i += k << 1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfor (int j = 0; j < k; j++) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tModular x = a[i + j];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tModular y = a[i + j + k] * roots[j + k];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\ta[i + j] = x + y;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\ta[i + j + k] = x - y;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tstatic vector <Modular> multiply(vector <Modular> a, vector <Modular> b) {\\\",\\r\\n            \\\"\\\\t\\\\tif (a.empty() || b.empty()) return {};\\\",\\r\\n            \\\"\\\\t\\\\tint eq = (a == b);\\\",\\r\\n            \\\"\\\\t\\\\tint need = (int) a.size() + (int) b.size() - 1;\\\",\\r\\n            \\\"\\\\t\\\\tint nbase = 0;\\\",\\r\\n            \\\"\\\\t\\\\twhile ((1 << nbase) < need) ++nbase;\\\",\\r\\n            \\\"\\\\t\\\\tensure_base(nbase);\\\",\\r\\n            \\\"\\\\t\\\\tint sz = 1 << nbase;\\\",\\r\\n            \\\"\\\\t\\\\ta.resize(sz); b.resize(sz);\\\",\\r\\n            \\\"\\\\t\\\\tfft(a);\\\",\\r\\n            \\\"\\\\t\\\\tif (eq) b = a;\\\",\\r\\n            \\\"\\\\t\\\\telse fft(b);\\\",\\r\\n            \\\"\\\\t\\\\tModular inv_sz = static_cast<Modular>(sz).inv();\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < sz; ++i) a[i] *= b[i] * inv_sz;\\\",\\r\\n            \\\"\\\\t\\\\treverse(a.begin() + 1, a.end());\\\",\\r\\n            \\\"\\\\t\\\\tfft(a);\\\",\\r\\n            \\\"\\\\t\\\\ta.resize(need);\\\",\\r\\n            \\\"\\\\t\\\\treturn a;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <typename Modular> int NTT<Modular>::md;\\\",\\r\\n            \\\"template <typename Modular> Modular NTT<Modular>::root;\\\",\\r\\n            \\\"template <typename Modular> int NTT<Modular>::base;\\\",\\r\\n            \\\"template <typename Modular> int NTT<Modular>::max_base;\\\",\\r\\n            \\\"template <typename Modular> vector<Modular> NTT<Modular>::roots;\\\",\\r\\n            \\\"template <typename Modular> vector<int> NTT<Modular>::rev;\\\",\\r\\n            \\\"template <typename Modular> vector <Modular> inverse(const vector <Modular> &a) {\\\",\\r\\n            \\\"\\\\tassert(!a.empty());\\\",\\r\\n            \\\"\\\\tint n = (int) a.size();\\\",\\r\\n            \\\"\\\\tvector <Modular> b = {a[0].inv()};\\\",\\r\\n            \\\"\\\\twhile ((int) b.size() < n) {\\\",\\r\\n            \\\"\\\\t\\\\tvector <Modular> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\\\",\\r\\n            \\\"\\\\t\\\\tx.resize(b.size() << 1); b.resize(b.size() << 1);\\\",\\r\\n            \\\"\\\\t\\\\tvector <Modular> c = b;\\\",\\r\\n            \\\"\\\\t\\\\tNTT<Modular>::fft(c); NTT<Modular>::fft(x);\\\",\\r\\n            \\\"\\\\t\\\\tModular inv = static_cast<Modular>((int)x.size()).inv();\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < (int) x.size(); ++i) x[i] *= c[i] * inv;\\\",\\r\\n            \\\"\\\\t\\\\treverse(x.begin() + 1, x.end());\\\",\\r\\n            \\\"\\\\t\\\\tNTT<Modular>::fft(x);\\\",\\r\\n            \\\"\\\\t\\\\trotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\\\",\\r\\n            \\\"\\\\t\\\\tfill(x.begin() + (x.size() >> 1), x.end(), 0);\\\",\\r\\n            \\\"\\\\t\\\\tNTT<Modular>::fft(x);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < (int) x.size(); ++i) x[i] *= c[i] * inv;\\\",\\r\\n            \\\"\\\\t\\\\treverse(x.begin() + 1, x.end());\\\",\\r\\n            \\\"\\\\t\\\\tNTT<Modular>::fft(x);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < (int) x.size() >> 1; ++i) b[i + ((int)x.size() >> 1)] = -x[i];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tb.resize(n);\\\",\\r\\n            \\\"\\\\treturn b;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename Modular> vector <Modular> inverse_old(vector <Modular> a) {\\\",\\r\\n            \\\"\\\\tassert(!a.empty());\\\",\\r\\n            \\\"\\\\tint n = a.size();\\\",\\r\\n            \\\"\\\\tif (n == 1) return { a[0].inv() };\\\",\\r\\n            \\\"\\\\tint m = (n + 1) >> 1;\\\",\\r\\n            \\\"\\\\tvector <Modular> b = inverse(vector<Modular>(a.begin(), a.begin() + m));\\\",\\r\\n            \\\"\\\\tint need = n << 1, nbase = 0;\\\",\\r\\n            \\\"\\\\twhile ((1 << nbase) < need) ++nbase;\\\",\\r\\n            \\\"\\\\tNTT<Modular>::ensure_base(nbase);\\\",\\r\\n            \\\"\\\\tint size = 1 << nbase;\\\",\\r\\n            \\\"\\\\ta.resize(size); b.resize(size);\\\",\\r\\n            \\\"\\\\tNTT<Modular>::fft(a); NTT<Modular>::fft(b);\\\",\\r\\n            \\\"\\\\tModular inv = static_cast<Modular>(size).inv();\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < size; ++i) a[i] = (2 - a[i] * b[i]) * b[i] * inv;\\\",\\r\\n            \\\"\\\\treverse(a.begin() + 1, a.end());\\\",\\r\\n            \\\"\\\\tNTT<Modular>::fft(a);\\\",\\r\\n            \\\"\\\\ta.resize(n);\\\",\\r\\n            \\\"\\\\treturn a;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename Modular> vector <Modular> operator * (const vector <Modular> &a, const vector <Modular> &b) {\\\",\\r\\n            \\\"\\\\tif (a.empty() || b.empty()) return {};\\\",\\r\\n            \\\"\\\\tif (min(a.size(), b.size()) < 150) {\\\",\\r\\n            \\\"\\\\t\\\\tvector <Modular> c(a.size() + b.size() - 1, 0);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < (int) a.size(); ++i)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int j = 0; j < (int) b.size(); j++)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tc[i + j] += a[i] * b[j];\\\",\\r\\n            \\\"\\\\t\\\\treturn c;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn NTT<Modular>::multiply(a, b);\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename Modular> vector <Modular> & operator *= (vector<Modular> &a, const vector <Modular> &b) { return a = a * b; }\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"using NUMBER_THEORETIC_TRANSFORM::operator *;\\\",\\r\\n            \\\"using NUMBER_THEORETIC_TRANSFORM::operator *=;\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"NUMBER_THEORETIC_TRANSFORM\\\"\\r\\n    },\\r\\n    \\\"FAST_FOURIER_TRANSFORM\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"FAST_FOURIER_TRANSFORM\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"namespace FAST_FOURIER_TRANSFORM {\\\",\\r\\n            \\\"typedef long double dbl;\\\",\\r\\n            \\\"struct num {\\\",\\r\\n            \\\"\\\\tdbl x, y;\\\",\\r\\n            \\\"\\\\tnum() { x = y = 0; }\\\",\\r\\n            \\\"\\\\tnum(dbl x_, dbl y_) : x(x_), y(y_) {}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"num operator + (num a, num b) { return num(a.x + b.x, a.y + b.y); }\\\",\\r\\n            \\\"num operator - (num a, num b) { return num(a.x - b.x, a.y - b.y); }\\\",\\r\\n            \\\"num operator * (num a, num b) { return num(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\\\",\\r\\n            \\\"num conj(num a) { return num(a.x, -a.y); }\\\",\\r\\n            \\\"int base = 1;\\\",\\r\\n            \\\"vector <num> roots = {{0, 0}, {1, 0}};\\\",\\r\\n            \\\"vector <int> rev = {0, 1};\\\",\\r\\n            \\\"const dbl PI = static_cast<dbl>(acosl(-1.0));\\\",\\r\\n            \\\"void ensure_base(int nbase) {\\\",\\r\\n            \\\"\\\\tif (nbase <= base) return;\\\",\\r\\n            \\\"\\\\trev.resize(1 << nbase);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < (1 << nbase); ++i) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\\\",\\r\\n            \\\"\\\\troots.resize(1 << nbase);\\\",\\r\\n            \\\"\\\\twhile (base < nbase) {\\\",\\r\\n            \\\"\\\\t\\\\tdbl angle = 2 * PI / (1 << (base + 1));\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 1 << (base - 1); i < (1 << base); ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\troots[i << 1] = roots[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tdbl angle_i = angle * (2 * i + 1 - (1 << base));\\\",\\r\\n            \\\"\\\\t\\\\t\\\\troots[(i << 1) + 1] = num(cos(angle_i), sin(angle_i));\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tbase++;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"void fft(vector <num> &a, int n = -1) {\\\",\\r\\n            \\\"\\\\tif (n == -1) n = (int) a.size();\\\",\\r\\n            \\\"\\\\tassert((n & (n - 1)) == 0);\\\",\\r\\n            \\\"\\\\tint zeros = __builtin_ctz(n);\\\",\\r\\n            \\\"\\\\tensure_base(zeros);\\\",\\r\\n            \\\"\\\\tint shift = base - zeros;\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < n; ++i) if (i < (rev[i] >> shift)) swap(a[i], a[rev[i] >> shift]);\\\",\\r\\n            \\\"\\\\tfor (int k = 1; k < n; k <<= 1) {\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; i += k << 1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int j = 0; j < k; ++j) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tnum z = a[i + j + k] * roots[j + k];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\ta[i + j + k] = a[i + j] - z;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\ta[i + j] = a[i + j] + z;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"vector <num> fa, fb;\\\",\\r\\n            \\\"vector <long long> square(const vector <int> &a) {\\\",\\r\\n            \\\"\\\\tif (a.empty()) return {};\\\",\\r\\n            \\\"\\\\tint need = (int) a.size() + (int) a.size() - 1, nbase = 1;\\\",\\r\\n            \\\"\\\\twhile ((1 << nbase) < need) ++nbase;\\\",\\r\\n            \\\"\\\\tensure_base(nbase);\\\",\\r\\n            \\\"\\\\tint sz = 1 << nbase;\\\",\\r\\n            \\\"\\\\tif ((sz >> 1) > (int) fa.size()) fa.resize(sz >> 1);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < (sz >> 1); ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tint x = (2 * i < (int)a.size() ? a[2 * i] : 0);\\\",\\r\\n            \\\"\\\\t\\\\tint y = (2 * i + 1 < (int)a.size() ? a[2 * i + 1] : 0);\\\",\\r\\n            \\\"\\\\t\\\\tfa[i] = num(x, y);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tfft(fa, sz >> 1);\\\",\\r\\n            \\\"\\\\tnum r(1.0 / (sz >> 1), 0.0);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i <= (sz >> 2); ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tint j = ((sz >> 1) - i) & ((sz >> 1) - 1);\\\",\\r\\n            \\\"\\\\t\\\\tnum fe = (fa[i] + conj(fa[j])) * num(0.5, 0);\\\",\\r\\n            \\\"\\\\t\\\\tnum fo = (fa[i] - conj(fa[j])) * num(0, -0.5);\\\",\\r\\n            \\\"\\\\t\\\\tnum aux = fe * fe + fo * fo * roots[(sz >> 1) + i] * roots[(sz >> 1) + i];\\\",\\r\\n            \\\"\\\\t\\\\tnum tmp = fe * fo;\\\",\\r\\n            \\\"\\\\t\\\\tfa[i] = r * (conj(aux) + num(0, 2) * conj(tmp));\\\",\\r\\n            \\\"\\\\t\\\\tfa[j] = r * (aux + num(0, 2) * tmp);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tfft(fa, sz >> 1);\\\",\\r\\n            \\\"\\\\tvector<long long> res(need);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < need; ++i) res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);\\\",\\r\\n            \\\"\\\\treturn res;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"vector <long long> multiply(const vector <int> &a, const vector <int> &b) {\\\",\\r\\n            \\\"\\\\tif (a.empty() || b.empty()) return {};\\\",\\r\\n            \\\"\\\\tif (a == b) return square(a);\\\",\\r\\n            \\\"\\\\tint need = (int) a.size() + (int) b.size() - 1, nbase = 1;\\\",\\r\\n            \\\"\\\\twhile ((1 << nbase) < need) ++nbase;\\\",\\r\\n            \\\"\\\\tensure_base(nbase);\\\",\\r\\n            \\\"\\\\tint sz = 1 << nbase;\\\",\\r\\n            \\\"\\\\tif (sz > (int) fa.size()) fa.resize(sz);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < sz; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tint x = (i < (int)a.size() ? a[i] : 0);\\\",\\r\\n            \\\"\\\\t\\\\tint y = (i < (int)b.size() ? b[i] : 0);\\\",\\r\\n            \\\"\\\\t\\\\tfa[i] = num(x, y);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tfft(fa, sz);\\\",\\r\\n            \\\"\\\\tnum r(0, -0.25 / (sz >> 1));\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i <= (sz >> 1); ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tint j = (sz - i) & (sz - 1);\\\",\\r\\n            \\\"\\\\t\\\\tnum z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r;\\\",\\r\\n            \\\"\\\\t\\\\tfa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r;\\\",\\r\\n            \\\"\\\\t\\\\tfa[i] = z;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < (sz >> 1); ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tnum A0 = (fa[i] + fa[i + (sz >> 1)]) * num(0.5, 0);\\\",\\r\\n            \\\"\\\\t\\\\tnum A1 = (fa[i] - fa[i + (sz >> 1)]) * num(0.5, 0) * roots[(sz >> 1) + i];\\\",\\r\\n            \\\"\\\\t\\\\tfa[i] = A0 + A1 * num(0, 1);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tfft(fa, sz >> 1);\\\",\\r\\n            \\\"\\\\tvector <long long> res(need);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < need; ++i) res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);\\\",\\r\\n            \\\"\\\\treturn res;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"vector <int> multiply_mod(const vector<int> &a, const vector<int> &b, int m) {\\\",\\r\\n            \\\"\\\\tif (a.empty() || b.empty()) return {};\\\",\\r\\n            \\\"\\\\tint eq = (a.size() == b.size() && a == b);\\\",\\r\\n            \\\"\\\\tint need = (int)a.size() + (int)b.size() - 1, nbase = 0;\\\",\\r\\n            \\\"\\\\twhile ((1 << nbase) < need) ++nbase;\\\",\\r\\n            \\\"\\\\tensure_base(nbase);\\\",\\r\\n            \\\"\\\\tint sz = 1 << nbase;\\\",\\r\\n            \\\"\\\\tif (sz > (int) fa.size()) fa.resize(sz);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < (int) a.size(); ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tint x = (a[i] % m + m) % m;\\\",\\r\\n            \\\"\\\\t\\\\tfa[i] = num(x & ((1 << 15) - 1), x >> 15);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tfill(fa.begin() + a.size(), fa.begin() + sz, num{0, 0});\\\",\\r\\n            \\\"\\\\tfft(fa, sz);\\\",\\r\\n            \\\"\\\\tif (sz > (int) fb.size()) fb.resize(sz);\\\",\\r\\n            \\\"\\\\tif (eq) copy(fa.begin(), fa.begin() + sz, fb.begin());\\\",\\r\\n            \\\"\\\\telse {\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < (int)b.size(); ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint x = (b[i] % m + m) % m;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfb[i] = num(x & ((1 << 15) - 1), x >> 15);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tfill(fb.begin() + b.size(), fb.begin() + sz, num{0, 0});\\\",\\r\\n            \\\"\\\\t\\\\tfft(fb, sz);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tdbl ratio = 0.25 / sz;\\\",\\r\\n            \\\"\\\\tnum r2(0, -1);\\\",\\r\\n            \\\"\\\\tnum r3(ratio, 0);\\\",\\r\\n            \\\"\\\\tnum r4(0, -ratio);\\\",\\r\\n            \\\"\\\\tnum r5(0, 1);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i <= (sz >> 1); ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tint j = (sz - i) & (sz - 1);\\\",\\r\\n            \\\"\\\\t\\\\tnum a1 = (fa[i] + conj(fa[j]));\\\",\\r\\n            \\\"\\\\t\\\\tnum a2 = (fa[i] - conj(fa[j])) * r2;\\\",\\r\\n            \\\"\\\\t\\\\tnum b1 = (fb[i] + conj(fb[j])) * r3;\\\",\\r\\n            \\\"\\\\t\\\\tnum b2 = (fb[i] - conj(fb[j])) * r4;\\\",\\r\\n            \\\"\\\\t\\\\tif (i != j) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tnum c1 = (fa[j] + conj(fa[i]));\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tnum c2 = (fa[j] - conj(fa[i])) * r2;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tnum d1 = (fb[j] + conj(fb[i])) * r3;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tnum d2 = (fb[j] - conj(fb[i])) * r4;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfa[i] = c1 * d1 + c2 * d2 * r5;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfb[i] = c1 * d2 + c2 * d1;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tfa[j] = a1 * b1 + a2 * b2 * r5;\\\",\\r\\n            \\\"\\\\t\\\\tfb[j] = a1 * b2 + a2 * b1;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tfft(fa, sz);\\\",\\r\\n            \\\"\\\\tfft(fb, sz);\\\",\\r\\n            \\\"\\\\tvector<int> res(need);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < need; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tlong long aa = llround(fa[i].x);\\\",\\r\\n            \\\"\\\\t\\\\tlong long bb = llround(fb[i].x);\\\",\\r\\n            \\\"\\\\t\\\\tlong long cc = llround(fa[i].y);\\\",\\r\\n            \\\"\\\\t\\\\tres[i] = static_cast<int>((aa + ((bb % m) << 15) + ((cc % m) << 30)) % m);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn res;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename Modular> vector <Modular> operator * (const vector <Modular> &a, const vector <Modular> &b) {\\\",\\r\\n            \\\"\\\\tif (a.empty() || b.empty()) return {};\\\",\\r\\n            \\\"\\\\tif (min(a.size(), b.size()) < 150) {\\\",\\r\\n            \\\"\\\\t\\\\tvector <Modular> c(a.size() + b.size() - 1, 0);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < (int)a.size(); ++i)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int j = 0; j < (int)b.size(); ++j)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tc[i + j] += a[i] * b[j];\\\",\\r\\n            \\\"\\\\t\\\\treturn c;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvector <int> a_mul(a.size());\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < (int) a.size(); ++i) a_mul[i] = static_cast<int>(a[i]);\\\",\\r\\n            \\\"\\\\tvector <int> b_mul(b.size());\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < (int) b.size(); ++i) b_mul[i] = static_cast<int>(b[i]);\\\",\\r\\n            \\\"\\\\tvector <int> c_mul = multiply_mod(a_mul, b_mul, Modular::mod());\\\",\\r\\n            \\\"\\\\tvector <Modular> c(c_mul.size());\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < (int) c.size(); ++i) c[i] = c_mul[i];\\\",\\r\\n            \\\"\\\\treturn c;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename Modular> vector <Modular> & operator *= (vector <Modular> &a, const vector <Modular> &b) { return a = a * b; }\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"using FAST_FOURIER_TRANSFORM::square;\\\",\\r\\n            \\\"using FAST_FOURIER_TRANSFORM::multiply;\\\",\\r\\n            \\\"using FAST_FOURIER_TRANSFORM::multiply_mod;\\\",\\r\\n            \\\"using FAST_FOURIER_TRANSFORM::operator *;\\\",\\r\\n            \\\"using FAST_FOURIER_TRANSFORM::operator *=;\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"FAST_FOURIER_TRANSFORM\\\"\\r\\n    },\\r\\n    \\\"MODINT\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"MODINT\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"namespace MODINT {\\\",\\r\\n            \\\"struct barrett {\\\",\\r\\n            \\\"\\\\tunsigned int _m;\\\",\\r\\n            \\\"\\\\tunsigned long long im;\\\",\\r\\n            \\\"\\\\texplicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\\\",\\r\\n            \\\"\\\\tunsigned int umod() const { return _m; };\\\",\\r\\n            \\\"\\\\tunsigned int mul(unsigned int a, unsigned int b) const {\\\",\\r\\n            \\\"\\\\t\\\\tunsigned long long z = a; z *= b;\\\",\\r\\n            \\\"\\\\t\\\\tunsigned long long x = (unsigned long long)(((unsigned __int128) z * im) >> 64);\\\",\\r\\n            \\\"\\\\t\\\\tunsigned long long y = x * _m;\\\",\\r\\n            \\\"\\\\t\\\\treturn (unsigned int)(z - y + (z < y ? _m : 0));\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <class T> T invGeneral(T a, T b) {\\\",\\r\\n            \\\"\\\\ta %= b;\\\",\\r\\n            \\\"\\\\tif (!a) return b == 1 ? 0 : -1;\\\",\\r\\n            \\\"\\\\tT x = invGeneral(b, a);\\\",\\r\\n            \\\"\\\\treturn x == -1 ? -1 : ((1 - 1LL * b * x) / a + b) % b;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <int m, enable_if_t<1 <= m>* = nullptr>\\\",\\r\\n            \\\"struct static_modint {\\\",\\r\\n            \\\"using mint = static_modint;\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tstatic constexpr int mod() { return m; }\\\",\\r\\n            \\\"\\\\tstatic mint raw(int v) {\\\",\\r\\n            \\\"\\\\t\\\\tmint x; x.v = v;\\\",\\r\\n            \\\"\\\\t\\\\treturn x;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tstatic_modint(): v(0) {}\\\",\\r\\n            \\\"\\\\ttemplate <class T> static_modint(T x) {\\\",\\r\\n            \\\"\\\\t\\\\tint y;\\\",\\r\\n            \\\"\\\\t\\\\tif (x < 0) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (x < -mod()) y = x % mod();\\\",\\r\\n            \\\"\\\\t\\\\t\\\\telse y = x;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (y < 0) y += mod();\\\",\\r\\n            \\\"\\\\t\\\\t} else {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (x < mod()) y = x;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\telse y = x % mod();\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tv = y;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tunsigned int val() const { return v; }\\\",\\r\\n            \\\"\\\\tunsigned int operator () () const { return v; }\\\",\\r\\n            \\\"\\\\tmint & operator ++ () { if (++v == umod()) v = 0; return *this; }\\\",\\r\\n            \\\"\\\\tmint & operator -- () { if (!v) v = umod(); --v; return *this; }\\\",\\r\\n            \\\"\\\\tmint operator ++ (int) { mint old = *this; ++*this; return old; }\\\",\\r\\n            \\\"\\\\tmint operator -- (int) { mint old = *this; --*this; return old; }\\\",\\r\\n            \\\"\\\\tmint operator + () { return *this; }\\\",\\r\\n            \\\"\\\\tmint operator - () { return raw(!v ? 0 : umod() - v); }\\\",\\r\\n            \\\"\\\\tmint & operator += (const mint &rhs) { v += rhs.v; if (v >= umod()) v -= umod(); return *this; }\\\",\\r\\n            \\\"\\\\tmint & operator -= (const mint &rhs) { v -= rhs.v; if (v >= umod()) v += umod(); return *this; }\\\",\\r\\n            \\\"\\\\tmint & operator *= (const mint &rhs) {\\\",\\r\\n            \\\"\\\\t\\\\tunsigned long long z = v; z *= rhs.v; v = z % umod();\\\",\\r\\n            \\\"\\\\t\\\\treturn *this;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tmint & operator /= (const mint &rhs) { return *this *= rhs.inv(); }\\\",\\r\\n            \\\"\\\\tfriend mint operator + (const mint &lhs, const mint &rhs) { return mint(lhs) += rhs; }\\\",\\r\\n            \\\"\\\\tfriend mint operator - (const mint &lhs, const mint &rhs) { return mint(lhs) -= rhs; }\\\",\\r\\n            \\\"\\\\tfriend mint operator * (const mint &lhs, const mint &rhs) { return mint(lhs) *= rhs; }\\\",\\r\\n            \\\"\\\\tfriend mint operator / (const mint &lhs, const mint &rhs) { return mint(lhs) /= rhs; }\\\",\\r\\n            \\\"\\\\tmint pow(long long n) const {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= n);\\\",\\r\\n            \\\"\\\\t\\\\tmint res = 1, a = *this;\\\",\\r\\n            \\\"\\\\t\\\\tfor (; n; n >>= 1, a *= a) if (n & 1) res *= a;\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tmint inv() const {\\\",\\r\\n            \\\"\\\\t\\\\tint i = invGeneral((int) v, mod());\\\",\\r\\n            \\\"\\\\t\\\\tassert(~i);\\\",\\r\\n            \\\"\\\\t\\\\treturn i;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tfriend bool operator == (const mint& lhs, const mint& rhs) { return lhs.v == rhs.v; }\\\",\\r\\n            \\\"\\\\tfriend bool operator != (const mint& lhs, const mint& rhs) { return lhs.v != rhs.v; }\\\",\\r\\n            \\\"\\\\tfriend ostream & operator << (ostream &out, const mint &x) { return out << x.v; }\\\",\\r\\n            \\\"\\\\tfriend istream & operator >> (istream &in, mint &x) { long long a; in >> a; x = a; return in; }\\\",\\r\\n            \\\"\\\\texplicit operator bool() const { return v; }\\\",\\r\\n            \\\"\\\\texplicit operator int() const { return v; }\\\",\\r\\n            \\\"private:\\\",\\r\\n            \\\"\\\\tunsigned int v;\\\",\\r\\n            \\\"\\\\tstatic constexpr unsigned int umod() { return m; }\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <int id> struct dynamic_modint {\\\",\\r\\n            \\\"using mint = dynamic_modint;\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tstatic int mod() { return (int) bt.umod(); }\\\",\\r\\n            \\\"\\\\tstatic void set_mod(int m) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(1 <= m);\\\",\\r\\n            \\\"\\\\t\\\\tbt = barrett(m);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tstatic mint raw(int v) {\\\",\\r\\n            \\\"\\\\t\\\\tmint x; x.v = v;\\\",\\r\\n            \\\"\\\\t\\\\treturn x;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tdynamic_modint(): v(0) {}\\\",\\r\\n            \\\"\\\\ttemplate <class T> dynamic_modint(T x) {\\\",\\r\\n            \\\"\\\\t\\\\tint y;\\\",\\r\\n            \\\"\\\\t\\\\tif (x < 0) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (x < -mod()) y = x % mod();\\\",\\r\\n            \\\"\\\\t\\\\t\\\\telse y = x;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (y < 0) y += mod();\\\",\\r\\n            \\\"\\\\t\\\\t} else {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (x < mod()) y = x;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\telse y = x % mod();\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tv = y;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tunsigned int val() const { return v; }\\\",\\r\\n            \\\"\\\\tunsigned int operator () () const { return v; }\\\",\\r\\n            \\\"\\\\tmint & operator ++ () { if (++v == umod()) v = 0; return *this; }\\\",\\r\\n            \\\"\\\\tmint & operator -- () { if (!v) v = umod(); --v; return *this; }\\\",\\r\\n            \\\"\\\\tmint operator ++ (int) { mint old = *this; ++*this; return old; }\\\",\\r\\n            \\\"\\\\tmint operator -- (int) { mint old = *this; --*this; return old; }\\\",\\r\\n            \\\"\\\\tmint operator + () { return *this; }\\\",\\r\\n            \\\"\\\\tmint operator - () { return raw(!v ? 0 : umod() - v); }\\\",\\r\\n            \\\"\\\\tmint & operator += (const mint &rhs) { v += rhs.v; if (v >= umod()) v -= umod(); return *this; }\\\",\\r\\n            \\\"\\\\tmint & operator -= (const mint &rhs) { v -= rhs.v; if (v >= umod()) v += umod(); return *this; }\\\",\\r\\n            \\\"\\\\tmint & operator *= (const mint &rhs) {\\\",\\r\\n            \\\"\\\\t\\\\tv = bt.mul(v, rhs.v);\\\",\\r\\n            \\\"\\\\t\\\\treturn *this;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tmint & operator /= (const mint &rhs) { return *this *= rhs.inv(); }\\\",\\r\\n            \\\"\\\\tfriend mint operator + (const mint &lhs, const mint &rhs) { return mint(lhs) += rhs; }\\\",\\r\\n            \\\"\\\\tfriend mint operator - (const mint &lhs, const mint &rhs) { return mint(lhs) -= rhs; }\\\",\\r\\n            \\\"\\\\tfriend mint operator * (const mint &lhs, const mint &rhs) { return mint(lhs) *= rhs; }\\\",\\r\\n            \\\"\\\\tfriend mint operator / (const mint &lhs, const mint &rhs) { return mint(lhs) /= rhs; }\\\",\\r\\n            \\\"\\\\tmint pow(long long n) const {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= n);\\\",\\r\\n            \\\"\\\\t\\\\tmint res = 1, a = *this;\\\",\\r\\n            \\\"\\\\t\\\\tfor (; n; n >>= 1, a *= a) if (n & 1) res *= a;\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tmint inv() const {\\\",\\r\\n            \\\"\\\\t\\\\tint i = invGeneral((int) v, mod());\\\",\\r\\n            \\\"\\\\t\\\\tassert(~i);\\\",\\r\\n            \\\"\\\\t\\\\treturn i;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tfriend bool operator == (const mint& lhs, const mint& rhs) { return lhs.v == rhs.v; }\\\",\\r\\n            \\\"\\\\tfriend bool operator != (const mint& lhs, const mint& rhs) { return lhs.v != rhs.v; }\\\",\\r\\n            \\\"\\\\tfriend ostream & operator << (ostream &out, const mint &x) { return out << x.v; }\\\",\\r\\n            \\\"\\\\tfriend istream & operator >> (istream &in, mint &x) { long long a; in >> a; x = a; return in; }\\\",\\r\\n            \\\"\\\\texplicit operator bool() const { return v; }\\\",\\r\\n            \\\"\\\\texplicit operator int() const { return v; }\\\",\\r\\n            \\\"private:\\\",\\r\\n            \\\"\\\\tunsigned int v;\\\",\\r\\n            \\\"\\\\tstatic barrett bt;\\\",\\r\\n            \\\"\\\\tstatic unsigned int umod() { return bt.umod(); }\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <int id> barrett dynamic_modint<id>::bt(998244353);\\\",\\r\\n            \\\"using modint998244353 = static_modint<998244353>;\\\",\\r\\n            \\\"using modint1000000007 = static_modint<1000000007>;\\\",\\r\\n            \\\"using modint = dynamic_modint <-1>;\\\",\\r\\n            \\\"using Modular = modint1000000007;\\\",\\r\\n            \\\"} using namespace MODINT;\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"MODINT\\\"\\r\\n    },\\r\\n    \\\"MO_ALGORITHM\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"MO_ALGORITHM\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"long long gilbertOrder(int x, int y, int p, int r) {\\\",\\r\\n            \\\"\\\\tif (p == 0) return 0;\\\",\\r\\n            \\\"\\\\tint h = 1 << (p - 1);\\\",\\r\\n            \\\"\\\\tint s = x < h ? y < h ? 0 : 3 : y < h ? 1 : 2;\\\",\\r\\n            \\\"\\\\ts = (s + r) & 3;\\\",\\r\\n            \\\"\\\\tconst int d[4] = {3, 0, 0, 1};\\\",\\r\\n            \\\"\\\\tint nx = x & (x ^ h), ny = y & (y ^ h);\\\",\\r\\n            \\\"\\\\tint nrot = (r + d[s]) & 3;\\\",\\r\\n            \\\"\\\\tlong long t = 1LL << (2 * p - 2);\\\",\\r\\n            \\\"\\\\tlong long ans = s * t;\\\",\\r\\n            \\\"\\\\tlong long add = gilbertOrder(nx, ny, p - 1, nrot);\\\",\\r\\n            \\\"\\\\tans += s == 1 || s == 2 ? add : t - add - 1;\\\",\\r\\n            \\\"\\\\treturn ans;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"struct Query {\\\",\\r\\n            \\\"\\\\tint l, r, idx;\\\",\\r\\n            \\\"\\\\tlong long ord;\\\",\\r\\n            \\\"\\\\tvoid calcOrder() { ord = gilbertOrder(l, r, 21, 0); }\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"MO_ALGORITHM\\\"\\r\\n    },\\r\\n    \\\"MIN_COST_FLOW\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"MIN_COST_FLOW\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"struct MaxFlowMinCost {\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tstatic const long long FLOW_INF = 1e18;\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tstruct Edge {\\\",\\r\\n            \\\"\\\\t\\\\tint from, to;\\\",\\r\\n            \\\"\\\\t\\\\tlong long flow, cost, capa;\\\",\\r\\n            \\\"\\\\t\\\\tEdge(int u = 0, int v = 0, long long ca = 0, long long co = 0):\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfrom(u), to(v), capa(ca), cost(co), flow(0) {};\\\",\\r\\n            \\\"\\\\t\\\\tlong long residual(void) const { return capa - flow; }\\\",\\r\\n            \\\"\\\\t\\\\tbool saturating(void) { return !residual(); }\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tint n;\\\",\\r\\n            \\\"\\\\tvector <vector <int>> adj;\\\",\\r\\n            \\\"\\\\tvector <Edge> edges;\\\",\\r\\n            \\\"\\\\tvector <long long> dist, trace;\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tMaxFlowMinCost(int _n = 0) {\\\",\\r\\n            \\\"\\\\t\\\\tn = _n;\\\",\\r\\n            \\\"\\\\t\\\\tadj.assign(n + 5, vector <int> ());\\\",\\r\\n            \\\"\\\\t\\\\tdist.assign(n + 5, 0);\\\",\\r\\n            \\\"\\\\t\\\\ttrace.assign(n + 5, 0);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tint addEdge(int u, int v, long long ca, long long co) {\\\",\\r\\n            \\\"\\\\t\\\\tadj[u].push_back(edges.size());\\\",\\r\\n            \\\"\\\\t\\\\tedges.push_back(Edge(u, v, ca, co));\\\",\\r\\n            \\\"\\\\t\\\\tadj[v].push_back(edges.size());\\\",\\r\\n            \\\"\\\\t\\\\tedges.push_back(Edge(v, u, 0, -co));\\\",\\r\\n            \\\"\\\\t\\\\treturn edges.size() - 2;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tbool FordBellman(int s, int t) {\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i <= n; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tdist[i] = FLOW_INF;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\ttrace[i] = -1;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tvector <int> inQueue(n + 5, false);\\\",\\r\\n            \\\"\\\\t\\\\tqueue <int> q;\\\",\\r\\n            \\\"\\\\t\\\\tdist[s] = 0; q.push(s), inQueue[s] = true;\\\",\\r\\n            \\\"\\\\t\\\\twhile (!q.empty()) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint u = q.front(); q.pop(); inQueue[u] = false;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int id: adj[u]) if (edges[id].residual() > 0) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint v = edges[id].to;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (dist[v] > dist[u] + edges[id].cost) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tdist[v] = dist[u] + edges[id].cost;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\ttrace[v] = id;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (!inQueue[v]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tq.push(v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tinQueue[v] = true;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn dist[t] < FLOW_INF;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tpair <long long, long long> getFlow(int s, int t) {\\\",\\r\\n            \\\"\\\\t\\\\tfor (Edge &e: edges) e.flow = 0;\\\",\\r\\n            \\\"\\\\t\\\\tlong long totFlow = 0, totCost = 0;\\\",\\r\\n            \\\"\\\\t\\\\twhile (FordBellman(s, t)) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tlong long delta = FLOW_INF;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int u = t; u != s; u = edges[trace[u]].from) \\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tdelta = min(delta, edges[trace[u]].residual());\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int u = t; u != s; u = edges[trace[u]].from) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tedges[trace[u]].flow += delta;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tedges[trace[u] ^ 1].flow -= delta;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\ttotFlow += delta;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\ttotCost += delta * dist[t];\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn make_pair(totFlow, totCost);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tbool saturating(int s, int t) {\\\",\\r\\n            \\\"\\\\t\\\\tgetFlow(s, t);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int &id: adj[s]) if (!edges[id].saturating()) return false;\\\",\\r\\n            \\\"\\\\t\\\\treturn true;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"MIN_COST_FLOW\\\"\\r\\n    },\\r\\n    \\\"MAXMIN\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"MAXMIN\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"template <class A, class B> bool minimize(A &a, B b)  { return a > b ? a = b, true : false; }\\\",\\r\\n            \\\"template <class A, class B> bool maximize(A &a, B b)  { return a < b ? a = b, true : false; }\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"MAXMIN\\\"\\r\\n    },\\r\\n    \\\"MATRIX\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"MATRIX\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"template <class T> struct Matrix {\\\",\\r\\n            \\\"\\\\tint numRow, numCol; vector <T> val;\\\",\\r\\n            \\\"\\\\t// accessors\\\",\\r\\n            \\\"\\\\ttypename vector<T>::iterator operator [] (int r) { return val.begin() + r * numCol; }\\\",\\r\\n            \\\"\\\\tinline T & at(int r, int c) { return val[r * numCol + c]; }\\\",\\r\\n            \\\"\\\\tinline T get(int r, int c) const { return val[r * numCol + c]; }\\\",\\r\\n            \\\"\\\\t// constructors\\\",\\r\\n            \\\"\\\\tMatrix() {}\\\",\\r\\n            \\\"\\\\tMatrix(int r, int c): numRow(r), numCol(c), val(r * c) {}\\\",\\r\\n            \\\"\\\\tMatrix(const vector <vector <T>> &d) {\\\",\\r\\n            \\\"\\\\t\\\\tnumRow = d.size();\\\",\\r\\n            \\\"\\\\t\\\\tnumCol = numRow ? d[0].size() : 0;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < numRow; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tassert((int) d[i].size() == numCol);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tcopy(d[i].begin(), d[i].end(), back_inserter(val));\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tMatrix & set_value(T v) {\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < numRow * numCol; ++i) val[i] = v;\\\",\\r\\n            \\\"\\\\t\\\\treturn *this;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\t// convert to 2D vector\\\",\\r\\n            \\\"\\\\tvector <vector <T>> vecvec(void) const {\\\",\\r\\n            \\\"\\\\t\\\\tvector <vector <T>> res(numRow);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < numRow; ++i)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tcopy(val.begin() + i * numCol, val.begin() + (i + 1) * numCol, back_inserter(res[i]));\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\toperator vector <vector <T>> () const { return vecvec(); }\\\",\\r\\n            \\\"\\\\tstatic Matrix identity(int n) {\\\",\\r\\n            \\\"\\\\t\\\\tMatrix res(n, n);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) res.at(i, i) = T(1);\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tfriend istream & operator >> (istream &in, Matrix &res) {\\\",\\r\\n            \\\"\\\\t\\\\tfor (T &x: res.val) in >> x;\\\",\\r\\n            \\\"\\\\t\\\\treturn in;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tfriend ostream & operator << (ostream &out, const Matrix &res) {\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < res.numRow * res.numCol; ++i)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tcout << res.val[i] << \\\\\\\" \\\\\\\\n\\\\\\\"[i % res.numCol == res.numCol - 1];\\\",\\r\\n            \\\"\\\\t\\\\treturn out;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tMatrix operator - (void) {\\\",\\r\\n            \\\"\\\\t\\\\tMatrix res(numRow, numCol);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < numRow * numCol; ++i) res.val[i] = -val[i];\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tMatrix operator * (const T &v) {\\\",\\r\\n            \\\"\\\\t\\\\tMatrix res = *this;\\\",\\r\\n            \\\"\\\\t\\\\tfor (T &x: res.val) x *= v;\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t} \\\",\\r\\n            \\\"\\\\tMatrix operator / (const T &v) {\\\",\\r\\n            \\\"\\\\t\\\\tMatrix res = *this;\\\",\\r\\n            \\\"\\\\t\\\\tconst T inv = T(1) / v;\\\",\\r\\n            \\\"\\\\t\\\\tfor (T &x: res.val) x *= inv;\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tMatrix operator + (const Matrix &other) const {\\\",\\r\\n            \\\"\\\\t\\\\tint M = numRow, N = numCol;\\\",\\r\\n            \\\"\\\\t\\\\tassert(M == other.numRow); assert(N == other.numCol);\\\",\\r\\n            \\\"\\\\t\\\\tMatrix res = *this;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < numRow * numCol; ++i) res.val[i] += other.val[i];\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tMatrix operator - (const Matrix &other) const {\\\",\\r\\n            \\\"\\\\t\\\\tint M = numRow, N = numCol;\\\",\\r\\n            \\\"\\\\t\\\\tassert(M == other.numRow); assert(N == other.numCol);\\\",\\r\\n            \\\"\\\\t\\\\tMatrix res = *this;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < numRow * numCol; ++i) res.val[i] -= other.val[i];\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tMatrix operator * (const Matrix &other) const {\\\",\\r\\n            \\\"\\\\t\\\\tint M = numRow, N = numCol, P = other.numCol;\\\",\\r\\n            \\\"\\\\t\\\\tassert(N == other.numRow);\\\",\\r\\n            \\\"\\\\t\\\\tMatrix t_other = other.transpose();\\\",\\r\\n            \\\"\\\\t\\\\tMatrix res(M, P);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < M; ++i)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int j = 0; j < P; ++j)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tres.at(i, j) = inner_product(this->val.begin() + N * i, this->val.begin() + N * (i + 1), t_other.val.begin() + t_other.numCol * j, T(0));\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tMatrix & operator *= (const T &v) { return *this = *this * v; }\\\",\\r\\n            \\\"\\\\tMatrix & operator /= (const T &v) { return *this = *this / v; }\\\",\\r\\n            \\\"\\\\tMatrix & operator += (const Matrix &other) { return *this = *this + other; }\\\",\\r\\n            \\\"\\\\tMatrix & operator -= (const Matrix &other) { return *this = *this - other; }\\\",\\r\\n            \\\"\\\\tMatrix & operator *= (const Matrix &other) { return *this = *this * other; }\\\",\\r\\n            \\\"\\\\tMatrix pow(long long Exp) const {\\\",\\r\\n            \\\"\\\\t\\\\tint M = numRow;\\\",\\r\\n            \\\"\\\\t\\\\tassert(M == numCol); assert(Exp >= 0);\\\",\\r\\n            \\\"\\\\t\\\\tMatrix res = identity(M);\\\",\\r\\n            \\\"\\\\t\\\\tif (!Exp) return res;\\\",\\r\\n            \\\"\\\\t\\\\tbool is_id = true;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 63 - __builtin_clzll(Exp); i >= 0; --i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (!is_id) res *= res;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (Exp >> i & 1) res *= *this, is_id = false;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tMatrix transpose(void) const {\\\",\\r\\n            \\\"\\\\t\\\\tMatrix res(numCol, numRow);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < numRow; ++i)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int j = 0; j < numCol; ++j)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tres.at(j, i) = this->get(i, j);\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"MATRIX\\\"\\r\\n    },\\r\\n    \\\"LINE_CONTAINER\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"LINE_CONTAINER\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"struct Line {\\\",\\r\\n            \\\"\\\\tmutable long long k, m, p;\\\",\\r\\n            \\\"\\\\tLine(long long k, long long m, long long p): k(k), m(m), p(p) {}\\\",\\r\\n            \\\"\\\\tbool operator < (const Line& o) const { return k < o.k; }\\\",\\r\\n            \\\"\\\\tbool operator < (long long x) const { return p < x; }\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"struct LineContainer: multiset <Line, less<>> {\\\",\\r\\n            \\\"\\\\t// (for doubles, use inf = 1/.0, div(a,b) = a/b)\\\",\\r\\n            \\\"\\\\tstatic const long long inf = 4e18;\\\",\\r\\n            \\\"\\\\tlong long div(long long a, long long b) { // floored division\\\",\\r\\n            \\\"\\\\t\\\\treturn a / b - ((a ^ b) < 0 && a % b);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tbool isect(iterator x, iterator y) {\\\",\\r\\n            \\\"\\\\t\\\\tif (y == end()) return x->p = inf, 0;\\\",\\r\\n            \\\"\\\\t\\\\tif (x->k == y->k) x->p = x->m > y->m ? inf : -inf;\\\",\\r\\n            \\\"\\\\t\\\\telse x->p = div(y->m - x->m, x->k - y->k);\\\",\\r\\n            \\\"\\\\t\\\\treturn x->p >= y->p;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid add(long long k, long long m) {\\\",\\r\\n            \\\"\\\\t\\\\tauto z = emplace(k, m, 0), y = z++, x = y;\\\",\\r\\n            \\\"\\\\t\\\\twhile (isect(y, z)) z = erase(z);\\\",\\r\\n            \\\"\\\\t\\\\tif (x != begin() && isect(--x, y)) isect(x, y = erase(y));\\\",\\r\\n            \\\"\\\\t\\\\twhile ((y = x) != begin() && (--x)->p >= y->p)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tisect(x, erase(y));\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tlong long query(long long x) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(!empty());\\\",\\r\\n            \\\"\\\\t\\\\tauto l = *lower_bound(x);\\\",\\r\\n            \\\"\\\\t\\\\treturn l.k * x + l.m;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"LINE_CONTAINER\\\"\\r\\n    },\\r\\n    \\\"LICHAO_TREE\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"LICHAO_TREE\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"// not tested yet\\\",\\r\\n            \\\"template<\\\",\\r\\n            \\\"\\\\tclass T,  // for segment & coordinates data types, e.g. long long\\\",\\r\\n            \\\"\\\\tclass TM  // for intermediate computations, e.g. __int128_t\\\",\\r\\n            \\\"> \\\",\\r\\n            \\\"struct LichaoTree {\\\",\\r\\n            \\\"\\\\tstruct Line {\\\",\\r\\n            \\\"\\\\t\\\\tT a, b;\\\",\\r\\n            \\\"\\\\t\\\\tint id;\\\",\\r\\n            \\\"\\\\t\\\\tbool is_valid;\\\",\\r\\n            \\\"\\\\t\\\\tLine(T a, T b, int id, bool is_valid): a(a), b(b), id(id), is_valid(is_valid) {}\\\",\\r\\n            \\\"\\\\t\\\\tTM eval(T x) { return TM(a) * x + b; }\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tstruct Result {\\\",\\r\\n            \\\"\\\\t\\\\tT line_a, line_b;\\\",\\r\\n            \\\"\\\\t\\\\tint line_id;\\\",\\r\\n            \\\"\\\\t\\\\tbool is_valid;\\\",\\r\\n            \\\"\\\\t\\\\tTM min_val;\\\",\\r\\n            \\\"\\\\t\\\\tResult(T a, T b, int id, bool iv, TM m): line_a(a), line_b(b), line_id(id), is_valid(iv), min_val(m) {}\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tint n, size, log;\\\",\\r\\n            \\\"\\\\tvector <T> xs;\\\",\\r\\n            \\\"\\\\tvector <Line> lines;\\\",\\r\\n            \\\"\\\\tLichaoTree(const vector <T> &_xs): xs(_xs) {\\\",\\r\\n            \\\"\\\\t\\\\tsort(xs.begin(), xs.end());\\\",\\r\\n            \\\"\\\\t\\\\txs.erase(unique(ALL(xs)), xs.end());\\\",\\r\\n            \\\"\\\\t\\\\tn = xs.size();\\\",\\r\\n            \\\"\\\\t\\\\tlog = 0;\\\",\\r\\n            \\\"\\\\t\\\\twhile ((1 << log) < n) ++log;\\\",\\r\\n            \\\"\\\\t\\\\tsize = 1 << log;\\\",\\r\\n            \\\"\\\\t\\\\txs.resize(size, xs.back());\\\",\\r\\n            \\\"\\\\t\\\\tlines.assign(size << 1, Line(0, 0, -1, false));\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid update(int i, int l, int r, int u, int v, Line line) {\\\",\\r\\n            \\\"\\\\t\\\\tif (l >= v || r <= u) return;\\\",\\r\\n            \\\"\\\\t\\\\tif (u <= l && r <= v) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (!lines[i].is_valid) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tlines[i] = line;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\treturn;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint m = l + r >> 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tbool lef = line.eval(l) < lines[i].eval(l);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tbool mid = line.eval(m) < lines[i].eval(m);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (mid) swap(lines[i], line);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (r - l == 1) return;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\ti << 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (lef != mid) i <<= 1, r = m;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\telse i = i << 1 | 1, l = m;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\treturn;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tint m = l + r >> 1;\\\",\\r\\n            \\\"\\\\t\\\\tupdate(i << 1, l, m, u, v, line);\\\",\\r\\n            \\\"\\\\t\\\\tupdate(i << 1 | 1, m, r, u, v, line);\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tvoid add_line(T a, T b, int id = -1) {\\\",\\r\\n            \\\"\\\\t\\\\tupdate(1, 0, size, 0, size, Line(a, b, id, true));\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid add_segment(T l, T r, T a, T b, int id = -1) {\\\",\\r\\n            \\\"\\\\t\\\\tl = lower_bound(ALL(xs), l) - xs.begin();\\\",\\r\\n            \\\"\\\\t\\\\tr = upper_bound(ALL(xs), r) - xs.begin();\\\",\\r\\n            \\\"\\\\t\\\\tif (l >= r) return;\\\",\\r\\n            \\\"\\\\t\\\\tupdate(1, 0, size, l, r, Line(a, b, id, true));\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tResult get(T x) {\\\",\\r\\n            \\\"\\\\t\\\\tint i = lower_bound(xs.begin(), xs.end(), x) - xs.begin();\\\",\\r\\n            \\\"\\\\t\\\\tLine res = lines[i];\\\",\\r\\n            \\\"\\\\t\\\\tTM val = res.eval(x);\\\",\\r\\n            \\\"\\\\t\\\\tfor (i += size; (i >>= 1) > 0; ) if (lines[i].is_valid) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tTM cur = lines[i].eval(x);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (!res.is_valid || val > cur) res = lines[i], val = cur;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn Result(res.a, res.b, res.id, res.is_valid, val);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"LICHAO_TREE\\\"\\r\\n    },\\r\\n    \\\"LCA_RMQ\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"LCA_RMQ\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"struct LCA {\\\",\\r\\n            \\\"\\\\tint n, root;\\\",\\r\\n            \\\"\\\\tvector <vector <int>> adj;\\\",\\r\\n            \\\"\\\\tvector <int> tin, tout, depth;\\\",\\r\\n            \\\"\\\\tvector <pair <int, int>> order;\\\",\\r\\n            \\\"\\\\tvector <vector <int>> rmq;\\\",\\r\\n            \\\"\\\\tLCA(const vector <vector <int>> & _adj, int _root): n(_adj.size()), root(_root), adj(_adj) { build(); }\\\",\\r\\n            \\\"\\\\tLCA(const vector <vector <pair <int, int>>> & _adj, int _root): n(_adj.size()), root(_root) {\\\",\\r\\n            \\\"\\\\t\\\\tadj.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int u = 0; u < (int) adj.size(); ++u) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tadj[u].reserve(_adj[u].size());\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (auto [w, v]: _adj[u]) adj[u].push_back(v);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tbuild();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid build(void) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= root && root < n);\\\",\\r\\n            \\\"\\\\t\\\\ttin.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\ttout.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\tdepth.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\torder.reserve(2 * n - 1);\\\",\\r\\n            \\\"\\\\t\\\\tdepth[root] = 0;\\\",\\r\\n            \\\"\\\\t\\\\trmq.emplace_back(0);\\\",\\r\\n            \\\"\\\\t\\\\tdfs(root, -1);\\\",\\r\\n            \\\"\\\\t\\\\tint m = rmq[0].size();\\\",\\r\\n            \\\"\\\\t\\\\tfor (int k = 1; (1 << k) <= m; ++k) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\trmq.emplace_back(m - (1 << k) + 1);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int i = 0; i + (1 << k) <= m; ++i) rmq[k][i] = op(rmq[k - 1][i], rmq[k - 1][i + (1 << (k - 1))]);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tbool is_anc(int x, int y) { return tin[x] <= tin[y] && tout[y] <= tout[x]; }\\\",\\r\\n            \\\"\\\\tint op(int x, int y) { return depth[x] < depth[y] ? x : y; }\\\",\\r\\n            \\\"\\\\tvoid dfs(int u, int par) {\\\",\\r\\n            \\\"\\\\t\\\\ttin[u] = rmq[0].size();\\\",\\r\\n            \\\"\\\\t\\\\trmq[0].push_back(u);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int v: adj[u]) if (v != par) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tdepth[v] = depth[u] + 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tdfs(v, u);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\trmq[0].push_back(u);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\ttout[u] = rmq[0].size();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tint lca(int u, int v) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= u && u < n);\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= v && v < n);\\\",\\r\\n            \\\"\\\\t\\\\tu = tin[u]; v = tin[v];\\\",\\r\\n            \\\"\\\\t\\\\tif (u > v) swap(u, v);\\\",\\r\\n            \\\"\\\\t\\\\tint h = __lg(v - u + 1);\\\",\\r\\n            \\\"\\\\t\\\\treturn op(rmq[h][u], rmq[h][v - (1 << h) + 1]);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"LCA_RMQ\\\"\\r\\n    },\\r\\n    \\\"LCA_BL\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"LCA_BL\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"struct LCA {\\\",\\r\\n            \\\"\\\\tint n, root, t, log;\\\",\\r\\n            \\\"\\\\tvector <vector <int>> adj, anc;\\\",\\r\\n            \\\"\\\\tvector <int> tin, tout, depth;\\\",\\r\\n            \\\"\\\\tLCA(const vector <vector <int>> & _adj, int _root): n(_adj.size()), root(_root), adj(_adj) { build(); }\\\",\\r\\n            \\\"\\\\tLCA(const vector <vector <pair <int, int>>> & _adj, int _root): n(_adj.size()), root(_root) {\\\",\\r\\n            \\\"\\\\t\\\\tadj.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int u = 0; u < (int) adj.size(); ++u) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tadj[u].reserve(_adj[u].size());\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (auto [w, v]: _adj[u]) adj[u].push_back(v);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tbuild();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid build(void) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= root && root < n);\\\",\\r\\n            \\\"\\\\t\\\\tlog = 1;\\\",\\r\\n            \\\"\\\\t\\\\twhile ((1 << log) < n) ++log;\\\",\\r\\n            \\\"\\\\t\\\\tanc.resize(n, vector<int>(log, -1));\\\",\\r\\n            \\\"\\\\t\\\\ttin.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\ttout.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\tdepth.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\tdepth[root] = 0;\\\",\\r\\n            \\\"\\\\t\\\\tt = 0;\\\",\\r\\n            \\\"\\\\t\\\\tdfs(root);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid dfs(int u) {\\\",\\r\\n            \\\"\\\\t\\\\ttin[u] = t++;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int v: adj[u]) if (v != anc[u][0]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tanc[v][0] = u;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int i = 1; i < log; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tanc[v][i] = anc[anc[v][i - 1]][i - 1];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (anc[v][i] == -1) break;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tdepth[v] = depth[u] + 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tdfs(v);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\ttout[u] = t;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tint lca(int u, int v) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= u && u < n);\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= v && v < n);\\\",\\r\\n            \\\"\\\\t\\\\tif (depth[u] < depth[v]) swap(u, v);\\\",\\r\\n            \\\"\\\\t\\\\tint h = depth[u] - depth[v];\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < log; ++i) if (h >> i & 1) u = anc[u][i];\\\",\\r\\n            \\\"\\\\t\\\\tif (u == v) return u;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = log - 1; i >= 0; --i) if (anc[u][i] != anc[v][i]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tu = anc[u][i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tv = anc[v][i];\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn anc[u][0];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"LCA_BL\\\"\\r\\n    },\\r\\n    \\\"LAZY_SEGTREE\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"LAZY_SEGTREE\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"template <\\\",\\r\\n            \\\"\\\\tclass S,                 // node data type\\\",\\r\\n            \\\"\\\\tS (*op) (S, S),          // combine 2 nodes\\\",\\r\\n            \\\"\\\\tS (*e) (),               // identity element\\\",\\r\\n            \\\"\\\\tclass F,                 // lazy propagation tag\\\",\\r\\n            \\\"\\\\tS (*mapping) (F, S),     // apply tag F on a node\\\",\\r\\n            \\\"\\\\tF (*composition) (F, F), // combine 2 tags\\\",\\r\\n            \\\"\\\\tF (*id)()                // identity tag\\\",\\r\\n            \\\"\\\\t>\\\",\\r\\n            \\\"struct LazySegTree {\\\",\\r\\n            \\\"\\\\tLazySegTree() : LazySegTree(0) {}\\\",\\r\\n            \\\"\\\\tLazySegTree(int n) : LazySegTree(vector<S>(n, e())) {}\\\",\\r\\n            \\\"\\\\tLazySegTree(const vector <S> &v) : n(v.size()) {\\\",\\r\\n            \\\"\\\\t\\\\tlog = 0;\\\",\\r\\n            \\\"\\\\t\\\\twhile ((1 << log) < n) ++log;\\\",\\r\\n            \\\"\\\\t\\\\tsize = 1 << log;\\\",\\r\\n            \\\"\\\\t\\\\td = vector<S>(size << 1, e());\\\",\\r\\n            \\\"\\\\t\\\\tlz = vector<F>(size, id());\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) d[i + size] = v[i];\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = size - 1; i > 0; --i) update(i);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\t// 0 <= p < n\\\",\\r\\n            \\\"\\\\tvoid set(int p, S x) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= p && p < n);\\\",\\r\\n            \\\"\\\\t\\\\tp += size;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = log; i > 0; --i) push(p >> i);\\\",\\r\\n            \\\"\\\\t\\\\td[p] = x;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 1; i <= log; ++i) update(p >> i);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\t// 0 <= p < n\\\",\\r\\n            \\\"\\\\tS get(int p) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= p && p < n);\\\",\\r\\n            \\\"\\\\t\\\\tp += size;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = log; i > 0; --i) push(p >> i);\\\",\\r\\n            \\\"\\\\t\\\\treturn d[p];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\t// Get product in range [l, r-1]\\\",\\r\\n            \\\"\\\\t// 0 <= l <= r <= n\\\",\\r\\n            \\\"\\\\t// For empty segment (l == r) -> return e()\\\",\\r\\n            \\\"\\\\tS prod(int l, int r) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= l && l <= r && r <= n);\\\",\\r\\n            \\\"\\\\t\\\\tif (l == r) return e();\\\",\\r\\n            \\\"\\\\t\\\\tl += size; r += size;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = log; i > 0; --i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (((l >> i) << i) != l) push(l >> i);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (((r >> i) << i) != r) push((r - 1) >> i);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tS sml = e(), smr = e();\\\",\\r\\n            \\\"\\\\t\\\\twhile (l < r) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (l & 1) sml = op(sml, d[l++]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (r & 1) smr = op(d[--r], smr);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tl >>= 1; r >>= 1;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn op(sml, smr);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tS all_prod() { return d[1]; }\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\t// 0 <= p < n\\\",\\r\\n            \\\"\\\\tvoid apply(int p, F f) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= p && p < n);\\\",\\r\\n            \\\"\\\\t\\\\tp += size;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = log; i > 0; --i) push(p >> i);\\\",\\r\\n            \\\"\\\\t\\\\td[p] = mapping(f, d[p]);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 1; i <= log; ++i) update(p >> i);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\t// Apply f on all elements in range [l, r-1]\\\",\\r\\n            \\\"\\\\t// 0 <= l <= r <= n\\\",\\r\\n            \\\"\\\\tvoid apply(int l, int r, F f) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= l && l <= r && r <= n);\\\",\\r\\n            \\\"\\\\t\\\\tif (l == r) return;\\\",\\r\\n            \\\"\\\\t\\\\tl += size; r += size;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = log; i > 0; --i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (((l >> i) << i) != l) push(l >> i);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (((r >> i) << i) != r) push((r - 1) >> i);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tint l2 = l, r2 = r;\\\",\\r\\n            \\\"\\\\t\\\\twhile (l < r) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (l & 1) all_apply(l++, f);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (r & 1) all_apply(--r, f);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tl >>= 1; r >>= 1;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tl = l2; r = r2;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 1; i <= log; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (((l >> i) << i) != l) update(l >> i);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (((r >> i) << i) != r) update((r - 1) >> i);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\t// Binary search on SegTree to find largest r:\\\",\\r\\n            \\\"\\\\t//\\\\tf(op(a[l] .. a[r-1])) = true   (assuming empty array is always true)\\\",\\r\\n            \\\"\\\\t//\\\\tf(op(a[l] .. a[r])) = false\\\\t(assuming op(..., a[n]), which is out of bound, is always false)\\\",\\r\\n            \\\"\\\\ttemplate <bool (*g)(S)> int max_right(int l) { return max_right(l, [](S x) { return g(x); }); }\\\",\\r\\n            \\\"\\\\ttemplate <class G> int max_right(int l, G g) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= l && l <= n);\\\",\\r\\n            \\\"\\\\t\\\\tassert(g(e()));\\\",\\r\\n            \\\"\\\\t\\\\tif (l == n) return n;\\\",\\r\\n            \\\"\\\\t\\\\tl += size;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = log; i > 0; --i) push(l >> i);\\\",\\r\\n            \\\"\\\\t\\\\tS sm = e();\\\",\\r\\n            \\\"\\\\t\\\\tdo {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\twhile (!(l & 1)) l >>= 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (!g(op(sm, d[l]))) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\twhile (l < size) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tpush(l);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tl = l << 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (g(op(sm, d[l]))) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsm = op(sm, d[l]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tl++;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\treturn l - size;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tsm = op(sm, d[l]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tl++;\\\",\\r\\n            \\\"\\\\t\\\\t} while ((l & -l) != l);\\\",\\r\\n            \\\"\\\\t\\\\treturn n;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\t// Binary search on SegTree to find smallest l:\\\",\\r\\n            \\\"\\\\t//\\\\tf(op(a[l] .. a[r-1])) = true\\\\t  (assuming empty array is always true)\\\",\\r\\n            \\\"\\\\t//\\\\tf(op(a[l-1] .. a[r-1])) = false   (assuming op(a[-1], ..), which is out of bound, is always false)\\\",\\r\\n            \\\"\\\\ttemplate <bool (*g)(S)> int min_left(int r) { return min_left(r, [](S x) { return g(x); }); }\\\",\\r\\n            \\\"\\\\ttemplate <class G> int min_left(int r, G g) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= r && r <= n);\\\",\\r\\n            \\\"\\\\t\\\\tassert(g(e()));\\\",\\r\\n            \\\"\\\\t\\\\tif (!r) return 0;\\\",\\r\\n            \\\"\\\\t\\\\tr += size;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = log; i > 0; --i) push((r - 1) >> i);\\\",\\r\\n            \\\"\\\\t\\\\tS sm = e();\\\",\\r\\n            \\\"\\\\t\\\\tdo {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tr--;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\twhile (r > 1 && (r & 1)) r >>= 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (!g(op(d[r], sm))) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\twhile (r < size) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tpush(r);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tr = r << 1 | 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (g(op(d[r], sm))) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsm = op(d[r], sm);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tr--;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\treturn r + 1 - size;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tsm = op(d[r], sm);\\\",\\r\\n            \\\"\\\\t\\\\t} while ((r & -r) != r);\\\",\\r\\n            \\\"\\\\t\\\\treturn 0;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"private:\\\",\\r\\n            \\\"\\\\tint n, size, log;\\\",\\r\\n            \\\"\\\\tvector<S> d;\\\",\\r\\n            \\\"\\\\tvector<F> lz;\\\",\\r\\n            \\\"\\\\tvoid update(int k) { d[k] = op(d[k << 1], d[k << 1 | 1]); }\\\",\\r\\n            \\\"\\\\tvoid all_apply(int k, F f) {\\\",\\r\\n            \\\"\\\\t\\\\td[k] = mapping(f, d[k]);\\\",\\r\\n            \\\"\\\\t\\\\tif (k < size) lz[k] = composition(f, lz[k]);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid push(int k) {\\\",\\r\\n            \\\"\\\\t\\\\tall_apply(k << 1, lz[k]);\\\",\\r\\n            \\\"\\\\t\\\\tall_apply(k << 1 | 1, lz[k]);\\\",\\r\\n            \\\"\\\\t\\\\tlz[k] = id();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"LAZY_SEGTREE\\\"\\r\\n    },\\r\\n    \\\"KNUTH_MORRIS_PRATT\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"KNUTH_MORRIS_PRATT\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"template <typename T> vector <int> kmp_table(int n, const T &s) {\\\",\\r\\n            \\\"\\\\tvector<int> pi(n);\\\",\\r\\n            \\\"\\\\tfor (int i = 1; i < n; i++) {\\\",\\r\\n            \\\"\\\\t\\\\tint &j = pi[i];\\\",\\r\\n            \\\"\\\\t\\\\tj = pi[i - 1];\\\",\\r\\n            \\\"\\\\t\\\\twhile (j > 0 && s[i] != s[j]) j = pi[j - 1];\\\",\\r\\n            \\\"\\\\t\\\\tif (s[i] == s[j]) j++;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn pi;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename T> vector <int> kmp_table(const T &s) { return kmp_table(s.size(), s); }\\\",\\r\\n            \\\"template <typename T> vector <int> kmp_search(int n, const T &s, int m, const T &w, const vector <int> &pi) {\\\",\\r\\n            \\\"\\\\tassert(n >= 1 && (int) pi.size() == n);\\\",\\r\\n            \\\"\\\\tvector <int> res;\\\",\\r\\n            \\\"\\\\tint j = 0;\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < m; i++) {\\\",\\r\\n            \\\"\\\\t\\\\twhile (j > 0 && (j == n || w[i] != s[j])) j = pi[j - 1];\\\",\\r\\n            \\\"\\\\t\\\\tif (w[i] == s[j]) j++;\\\",\\r\\n            \\\"\\\\t\\\\tif (j == n) res.push_back(i - n + 1);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn res;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename T> vector <int> kmp_search(const T &s, const T &w, const vector <int> &pi) { return kmp_search(s.size(), s, w.size(), w, pi); }\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"KNUTH_MORRIS_PRATT\\\"\\r\\n    },\\r\\n    \\\"GRAPH\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"GRAPH\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"namespace GRAPH {\\\",\\r\\n            \\\"template <typename T> class graph {\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tstruct edge {\\\",\\r\\n            \\\"\\\\t\\\\tint from, to; T cost;\\\",\\r\\n            \\\"\\\\t\\\\tedge(int from, int to, T cost): from(from), to(to), cost(cost) {}\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tvector <edge> edges;\\\",\\r\\n            \\\"\\\\tint n;\\\",\\r\\n            \\\"\\\\tvector <vector<int>> adj;\\\",\\r\\n            \\\"\\\\tgraph(int _n): n(_n), adj(_n) {}\\\",\\r\\n            \\\"\\\\tvirtual int add(int from, int to, T cost) = 0;\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <typename T> class undigraph: public graph<T> {\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tusing graph<T>::edges, graph<T>::adj, graph<T>::n;\\\",\\r\\n            \\\"\\\\tundigraph(int _n): graph<T>(_n) {}\\\",\\r\\n            \\\"\\\\tint add(int u, int v, T cost = 1) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= u && u < n && 0 <= v && v < n);\\\",\\r\\n            \\\"\\\\t\\\\tint i = (int) edges.size();\\\",\\r\\n            \\\"\\\\t\\\\tadj[u].push_back(i);\\\",\\r\\n            \\\"\\\\t\\\\tadj[v].push_back(i);\\\",\\r\\n            \\\"\\\\t\\\\tedges.emplace_back(u, v, cost);\\\",\\r\\n            \\\"\\\\t\\\\treturn i;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <typename T> class forest: public graph<T> {\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tusing graph<T>::edges, graph<T>::adj, graph<T>::n;\\\",\\r\\n            \\\"\\\\tforest(int _n): graph<T>(_n) {}\\\",\\r\\n            \\\"\\\\tint add(int u, int v, T cost = 1) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= u && u < n && 0 <= v && v < n);\\\",\\r\\n            \\\"\\\\t\\\\tint i = (int) edges.size();\\\",\\r\\n            \\\"\\\\t\\\\tadj[u].push_back(i);\\\",\\r\\n            \\\"\\\\t\\\\tadj[v].push_back(i);\\\",\\r\\n            \\\"\\\\t\\\\tedges.emplace_back(u, v, cost);\\\",\\r\\n            \\\"\\\\t\\\\treturn i;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <typename T> class dfs_undigraph: public undigraph<T> {\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tusing undigraph<T>::edges, undigraph<T>::adj, undigraph<T>::n;\\\",\\r\\n            \\\"\\\\tvector <int> par, par_e, order, tin, tout, sz, root, depth, min_depth, was;\\\",\\r\\n            \\\"\\\\tvector<T> dist;\\\",\\r\\n            \\\"\\\\tint attempt;\\\",\\r\\n            \\\"\\\\tdfs_undigraph(int _n): undigraph<T>(_n) {}\\\",\\r\\n            \\\"\\\\tvoid init() {\\\",\\r\\n            \\\"\\\\t\\\\tpar = par_e = tin = tout = root = depth = min_depth = was = vector<int>(n, -1);\\\",\\r\\n            \\\"\\\\t\\\\torder.clear();\\\",\\r\\n            \\\"\\\\t\\\\tsz = vector<int>(n, 0);\\\",\\r\\n            \\\"\\\\t\\\\tdist = vector<T>(n);\\\",\\r\\n            \\\"\\\\t\\\\tattempt = 0;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid clear() {\\\",\\r\\n            \\\"\\\\t\\\\tpar.clear(); par_e.clear(); order.clear(); tin.clear(); tout.clear(); sz.clear();\\\",\\r\\n            \\\"\\\\t\\\\troot.clear(); depth.clear(); min_depth.clear(); dist.clear(); was.clear();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"private:\\\",\\r\\n            \\\"\\\\tvoid do_dfs(int u) {\\\",\\r\\n            \\\"\\\\t\\\\twas[u] = attempt;\\\",\\r\\n            \\\"\\\\t\\\\ttin[u] = (int) order.size();\\\",\\r\\n            \\\"\\\\t\\\\torder.push_back(u);\\\",\\r\\n            \\\"\\\\t\\\\tsz[u] = 1;\\\",\\r\\n            \\\"\\\\t\\\\tmin_depth[u] = depth[u];\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i: adj[u]) if (i != par_e[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tauto &e = edges[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint v = e.from ^ e.to ^ u;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (was[v] == attempt) min_depth[u] = min(min_depth[u], depth[v]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\telse {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\troot[v] = root[u];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tpar[v] = u;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tpar_e[v] = i;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tdepth[v] = depth[u] + 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tdist[v] = dist[u] + e.cost;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tdo_dfs(v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tsz[u] += sz[v];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tmin_depth[u] = min(min_depth[u], min_depth[v]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\ttout[u] = order.size();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid dfs_from(int u) {\\\",\\r\\n            \\\"\\\\t\\\\t++attempt;\\\",\\r\\n            \\\"\\\\t\\\\tdepth[u] = 0; dist[u] = T{}; root[u] = u;\\\",\\r\\n            \\\"\\\\t\\\\tpar[u] = par_e[u] = -1;\\\",\\r\\n            \\\"\\\\t\\\\tdo_dfs(u);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tvoid dfs(int u, bool clear_order = true) {\\\",\\r\\n            \\\"\\\\t\\\\tif (par.empty()) init();\\\",\\r\\n            \\\"\\\\t\\\\telse if (clear_order) order.clear();\\\",\\r\\n            \\\"\\\\t\\\\tdfs_from(u);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid dfs_all() {\\\",\\r\\n            \\\"\\\\t\\\\tinit();\\\",\\r\\n            \\\"\\\\t\\\\tfor (int u = 0; u < n; u++) if (depth[u] == -1) dfs_from(u);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <typename T> class dfs_forest: public forest<T> {\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tusing forest<T>::edges, forest<T>::adj, forest<T>::n;\\\",\\r\\n            \\\"\\\\tvector <int> par, par_e, order, tin, tout, sz, root, depth;\\\",\\r\\n            \\\"\\\\tvector<T> dist;\\\",\\r\\n            \\\"\\\\tdfs_forest(int _n): forest<T>(_n) {}\\\",\\r\\n            \\\"\\\\tvoid init() {\\\",\\r\\n            \\\"\\\\t\\\\tpar = par_e = tin = tout = root = depth = vector<int>(n, -1);\\\",\\r\\n            \\\"\\\\t\\\\torder.clear();\\\",\\r\\n            \\\"\\\\t\\\\tsz = vector<int>(n, 0);\\\",\\r\\n            \\\"\\\\t\\\\tdist = vector<T>(n);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid clear() {\\\",\\r\\n            \\\"\\\\t\\\\tpar.clear(); par_e.clear(); order.clear(); tin.clear();\\\",\\r\\n            \\\"\\\\t\\\\ttout.clear(); sz.clear(); root.clear(); depth.clear();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"private:\\\",\\r\\n            \\\"\\\\tvoid do_dfs(int u) {\\\",\\r\\n            \\\"\\\\t\\\\ttin[u] = order.size();\\\",\\r\\n            \\\"\\\\t\\\\torder.push_back(u);\\\",\\r\\n            \\\"\\\\t\\\\tsz[u] = 1;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i: adj[u]) if (i != par_e[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tauto &e = edges[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint v = e.from ^ e.to ^ u;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\troot[v] = (root[u] != -1 ? root[u]: v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tpar[v] = u;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tpar_e[v] = i;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tdepth[v] = depth[u] + 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tdist[v] = dist[u] + e.cost;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tdo_dfs(v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tsz[u] += sz[v];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\ttout[u] = order.size();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid dfs_from(int u) {\\\",\\r\\n            \\\"\\\\t\\\\tdepth[u] = 0;\\\",\\r\\n            \\\"\\\\t\\\\tdist[u] = T{};\\\",\\r\\n            \\\"\\\\t\\\\troot[u] = u;\\\",\\r\\n            \\\"\\\\t\\\\tpar[u] = par_e[u] = -1;\\\",\\r\\n            \\\"\\\\t\\\\tdo_dfs(u);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tvoid dfs(int u, bool clear_order = true) {\\\",\\r\\n            \\\"\\\\t\\\\tif (par.empty()) init();\\\",\\r\\n            \\\"\\\\t\\\\telse if (clear_order) order.clear();\\\",\\r\\n            \\\"\\\\t\\\\tdfs_from(u);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid dfs_all() {\\\",\\r\\n            \\\"\\\\t\\\\tinit();\\\",\\r\\n            \\\"\\\\t\\\\tfor (int u = 0; u < n; u++) if (depth[u] == -1) dfs_from(u);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tbool is_anc(int x, int y) { return tin[x] <= tin[y] && tout[y] <= tout[x]; }\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <typename T> class lca_binlift_forest: public dfs_forest<T> {\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tusing dfs_forest<T>::adj, dfs_forest<T>::n, dfs_forest<T>::par, dfs_forest<T>::depth, dfs_forest<T>::is_anc, dfs_forest<T>::root;\\\",\\r\\n            \\\"\\\\tint h;\\\",\\r\\n            \\\"\\\\tvector <vector <int>> anc;\\\",\\r\\n            \\\"\\\\tlca_binlift_forest(int _n): dfs_forest<T>(_n) {}\\\",\\r\\n            \\\"\\\\tvoid build_lca() {\\\",\\r\\n            \\\"\\\\t\\\\tassert(!par.empty());\\\",\\r\\n            \\\"\\\\t\\\\tint max_depth = *max_element(depth.begin(), depth.end());\\\",\\r\\n            \\\"\\\\t\\\\th = 1; while ((1 << h) <= max_depth) h++;\\\",\\r\\n            \\\"\\\\t\\\\tanc.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tanc[i].resize(h);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tanc[i][0] = par[i];\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tfor (int j = 1; j < h; j++) for (int i = 0; i < n; ++i)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tanc[i][j] = (anc[i][j - 1] == -1 ? -1: anc[anc[i][j - 1]][j - 1]);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tint go_up(int x, int up) {\\\",\\r\\n            \\\"\\\\t\\\\tup = min(up, (1 << h) - 1);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int j = h; j-- > 0; ) if (up & (1 << j)) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tx = anc[x][j];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (x == -1) break;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn x;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tint lca(int x, int y) {\\\",\\r\\n            \\\"\\\\t\\\\tif (root[x] != root[y]) return -1;\\\",\\r\\n            \\\"\\\\t\\\\tif (is_anc(x, y)) return x;\\\",\\r\\n            \\\"\\\\t\\\\tif (is_anc(y, x)) return y;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int j = h; j-- > 0; ) if (anc[x][j] != -1 && !is_anc(anc[x][j], y)) x = anc[x][j];\\\",\\r\\n            \\\"\\\\t\\\\treturn anc[x][0];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <typename T> class lca_rmq_forest: public dfs_forest<T> {\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tusing dfs_forest<T>::edges, dfs_forest<T>::adj, dfs_forest<T>::n, dfs_forest<T>::par, dfs_forest<T>::depth, dfs_forest<T>::root;\\\",\\r\\n            \\\"\\\\tlca_rmq_forest(int _n): dfs_forest<T>(_n) {}\\\",\\r\\n            \\\"\\\\tvoid build_lca() {\\\",\\r\\n            \\\"\\\\t\\\\tassert(!par.empty());\\\",\\r\\n            \\\"\\\\t\\\\tpos.resize(n, -1);\\\",\\r\\n            \\\"\\\\t\\\\trmq.emplace_back(0);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) if (root[i] == i) do_dfs(i);\\\",\\r\\n            \\\"\\\\t\\\\tint m = rmq[0].size();\\\",\\r\\n            \\\"\\\\t\\\\tfor (int k = 1; (1 << k) <= m; ++k) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\trmq.emplace_back(m - (1 << k) + 1);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int i = 0; i + (1 << k) <= m; ++i) rmq[k][i] = op(rmq[k - 1][i], rmq[k - 1][i + (1 << (k - 1))]);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"private:\\\",\\r\\n            \\\"\\\\tint h;\\\",\\r\\n            \\\"\\\\tvector <vector <int>> rmq;\\\",\\r\\n            \\\"\\\\tvector <int> pos;\\\",\\r\\n            \\\"\\\\tint op(int x, int y) { return depth[x] < depth[y] ? x : y; }\\\",\\r\\n            \\\"\\\\tvoid do_dfs(int u) {\\\",\\r\\n            \\\"\\\\t\\\\tpos[u] = rmq[0].size();\\\",\\r\\n            \\\"\\\\t\\\\trmq[0].push_back(u);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i: adj[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tauto &e = edges[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint v = e.from ^ e.to ^ u;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (v == par[u]) continue;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tdo_dfs(v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\trmq[0].push_back(u);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tint lca(int u, int v) {\\\",\\r\\n            \\\"\\\\t\\\\tif (root[u] != root[v]) return -1;\\\",\\r\\n            \\\"\\\\t\\\\tu = pos[u]; v = pos[v];\\\",\\r\\n            \\\"\\\\t\\\\tif (u > v) swap(u, v);\\\",\\r\\n            \\\"\\\\t\\\\tint h = __lg(v - u + 1);\\\",\\r\\n            \\\"\\\\t\\\\treturn op(rmq[h][u], rmq[h][v - (1 << h) + 1]);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <typename T> class hld_forest: public dfs_forest<T> {\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tusing dfs_forest<T>::edges, dfs_forest<T>::adj, dfs_forest<T>::n, dfs_forest<T>::par, dfs_forest<T>::depth, dfs_forest<T>::sz, dfs_forest<T>::tin, dfs_forest<T>::order, dfs_forest<T>::root, dfs_forest<T>::dfs, dfs_forest<T>::dfs_all;\\\",\\r\\n            \\\"\\\\tvector <int> head, visited;\\\",\\r\\n            \\\"\\\\thld_forest(int _n) : dfs_forest<T>(_n), visited(_n) {}\\\",\\r\\n            \\\"\\\\tvoid build_hld(const vector <int> &vs) {\\\",\\r\\n            \\\"\\\\t\\\\tfor (int tries = 0; tries < 2; ++tries) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (vs.empty()) dfs_all();\\\",\\r\\n            \\\"\\\\t\\\\t\\\\telse {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\torder.clear();\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfor (int v: vs) dfs(v, false);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tassert((int) order.size() == n);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (tries) break;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int u = 0; u < n; ++u) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (adj[u].empty()) continue;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint best = -1, bid = 0;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfor (int i = 0; i < (int) adj[u].size(); ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tint id = adj[u][i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tint v = edges[id].from ^ edges[id].to ^ u;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (par[v] != u) continue;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (sz[v] > best) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbest = sz[v];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbid = i;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tswap(adj[u][0], adj[u][bid]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\thead.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\tiota(head.begin(), head.end(), 0);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n - 1; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint x = order[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint y = order[i + 1];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (par[y] == x) head[y] = head[x];\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid build_hld(int v) { build_hld(vector<int>(1, v)); }\\\",\\r\\n            \\\"\\\\tvoid build_hld_all() { build_hld(vector<int>()); }\\\",\\r\\n            \\\"\\\\tint lca(int u, int v) {\\\",\\r\\n            \\\"\\\\t\\\\tif (root[u] != root[v]) return -1;\\\",\\r\\n            \\\"\\\\t\\\\twhile (head[u] != head[v]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (depth[head[u]] < depth[head[v]]) swap(u, v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tu = par[head[u]];\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn tin[u] < tin[v] ? u : v;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tint go_up(int x, int up) {\\\",\\r\\n            \\\"\\\\t\\\\tint target = depth[x] - up;\\\",\\r\\n            \\\"\\\\t\\\\tif (target < 0) return -1;\\\",\\r\\n            \\\"\\\\t\\\\twhile (depth[head[x]] > target) x = par[head[x]];\\\",\\r\\n            \\\"\\\\t\\\\treturn order[tin[x] - depth[x] + target];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tbool apply_on_path(int u, int v, bool with_lca, function<void(int, int, bool)> f) {\\\",\\r\\n            \\\"\\\\t\\\\t// f(u, v, up): up -- whether this part of the path goes up\\\",\\r\\n            \\\"\\\\t\\\\tassert(!head.empty());\\\",\\r\\n            \\\"\\\\t\\\\tif (root[u] != root[v]) return false;\\\",\\r\\n            \\\"\\\\t\\\\tint cnt = 0;\\\",\\r\\n            \\\"\\\\t\\\\twhile (head[u] != head[v]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (depth[head[u]] > depth[head[v]]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tf(tin[head[u]], tin[u], true);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tu = par[head[u]];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t} else {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tvisited[cnt++] = v;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tv = par[head[v]];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tif (tin[u] > tin[v]) f(tin[v], tin[u] - !with_lca, true);\\\",\\r\\n            \\\"\\\\t\\\\telse if (tin[u] + !with_lca <= tin[v]) f(tin[u] + !with_lca, tin[v], false);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = cnt - 1; i >= 0; i--) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tv = visited[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tf(tin[head[v]], tin[v], false);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn true;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <typename T> class digraph: public graph<T> {\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tusing graph<T>::edges, graph<T>::adj, graph<T>::n;\\\",\\r\\n            \\\"\\\\tdigraph(int _n) : graph<T>(_n) {}\\\",\\r\\n            \\\"\\\\tint add(int from, int to, T cost = 1) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= from && from < n && 0 <= to && to < n);\\\",\\r\\n            \\\"\\\\t\\\\tint i = (int) edges.size();\\\",\\r\\n            \\\"\\\\t\\\\tadj[from].push_back(i);\\\",\\r\\n            \\\"\\\\t\\\\tedges.push_back({from, to, cost});\\\",\\r\\n            \\\"\\\\t\\\\treturn i;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tdigraph<T> reverse() const {\\\",\\r\\n            \\\"\\\\t\\\\tdigraph <T> rev(n);\\\",\\r\\n            \\\"\\\\t\\\\tfor (auto &e : edges) rev.add(e.to, e.from, e.cost);\\\",\\r\\n            \\\"\\\\t\\\\treturn rev;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <typename T> vector <bool> find_bridges(const dfs_undigraph <T> &g) {\\\",\\r\\n            \\\"\\\\tassert(!g.par.empty());\\\",\\r\\n            \\\"\\\\tvector <bool> bridge(g.edges.size());\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < g.n; ++i) if (g.par[i] != -1 && g.min_depth[i] == g.depth[i]) bridge[g.par_e[i]] = true;\\\",\\r\\n            \\\"\\\\treturn bridge;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename T> vector <bool> find_cutpoints(const dfs_undigraph <T> &g) {\\\",\\r\\n            \\\"\\\\tassert(!g.par.empty());\\\",\\r\\n            \\\"\\\\tvector <bool> cutpoint(g.n);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < g.n; ++i) if (g.par[i] != -1 && g.min_depth[i] >= g.depth[g.par[i]]) cutpoint[g.par[i]] = true;\\\",\\r\\n            \\\"\\\\tvector <int> children(g.n, 0);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < g.n; ++i) if (g.par[i] != -1) children[g.par[i]]++;\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < g.n; ++i) if (g.par[i] == -1 && children[i] < 2) cutpoint[i] = false;\\\",\\r\\n            \\\"\\\\treturn cutpoint;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename T> vector <int> find_bicone(const dfs_undigraph <T> &g, int &cnt) {\\\",\\r\\n            \\\"\\\\tassert(!g.par.empty());\\\",\\r\\n            \\\"\\\\tvector <int> groups(g.n);\\\",\\r\\n            \\\"\\\\tcnt = 0;\\\",\\r\\n            \\\"\\\\tfor (int u: g.order) {\\\",\\r\\n            \\\"\\\\t\\\\tif (g.par[u] == -1 || g.min_depth[u] == g.depth[u]) groups[u] = cnt++;\\\",\\r\\n            \\\"\\\\t\\\\telse groups[u] = groups[g.par[u]];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn groups;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename T> vector <int> find_biconv(const dfs_undigraph <T> &g, int &cnt) {\\\",\\r\\n            \\\"\\\\tassert(!g.par.empty());\\\",\\r\\n            \\\"\\\\tvector <int> vertex_comp(g.n);\\\",\\r\\n            \\\"\\\\tcnt = 0;\\\",\\r\\n            \\\"\\\\tfor (int u: g.order) {\\\",\\r\\n            \\\"\\\\t\\\\tif (g.par[u] == -1) vertex_comp[u] = -1;\\\",\\r\\n            \\\"\\\\t\\\\telse if (g.min_depth[u] >= g.depth[g.par[u]]) vertex_comp[u] = cnt++;\\\",\\r\\n            \\\"\\\\t\\\\telse vertex_comp[u] = vertex_comp[g.par[u]];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvector <int> edge_comp(g.edges.size(), -1);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < (int) g.edges.size(); ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tint x = g.edges[i].from;\\\",\\r\\n            \\\"\\\\t\\\\tint y = g.edges[i].to;\\\",\\r\\n            \\\"\\\\t\\\\tedge_comp[i] = vertex_comp[g.depth[x] > g.depth[y] ? x : y];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn edge_comp;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename T> vector <int> find_mst(const undigraph <T> &g, T &res) {\\\",\\r\\n            \\\"\\\\tvector <int> order(g.edges.size());\\\",\\r\\n            \\\"\\\\tiota(order.begin(), order.end(), 0);\\\",\\r\\n            \\\"\\\\tsort(order.begin(), order.end(), [&g] (int a, int b) {\\\",\\r\\n            \\\"\\\\t\\\\treturn g.edges[a].cost < g.edges[b].cost;\\\",\\r\\n            \\\"\\\\t});\\\",\\r\\n            \\\"\\\\tvector <int> par(g.n, -1);\\\",\\r\\n            \\\"\\\\tauto find = [&] (auto find, int u) -> int {\\\",\\r\\n            \\\"\\\\t\\\\treturn par[u] < 0 ? u : par[u] = find(find, par[u]);\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tauto join = [&] (int u, int v) -> bool {\\\",\\r\\n            \\\"\\\\t\\\\tif ((u = find(find, u)) == (v = find(find, v))) return false;\\\",\\r\\n            \\\"\\\\t\\\\tif (par[u] > par[v]) swap(u, v);\\\",\\r\\n            \\\"\\\\t\\\\tpar[u] += par[v];\\\",\\r\\n            \\\"\\\\t\\\\tpar[v] = u;\\\",\\r\\n            \\\"\\\\t\\\\treturn true;\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tvector <int> lst;\\\",\\r\\n            \\\"\\\\tres = 0;\\\",\\r\\n            \\\"\\\\tfor (int i: order) {\\\",\\r\\n            \\\"\\\\t\\\\tauto &e = g.edges[i];\\\",\\r\\n            \\\"\\\\t\\\\tif (join(e.from, e.to)) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tlst.push_back(i);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tres += e.cost;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn lst;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename T> vector <T> dijkstra(const graph <T> &g, int start) {\\\",\\r\\n            \\\"\\\\tassert(0 <= start && start < g.n);\\\",\\r\\n            \\\"\\\\tvector <T> dist(g.n, numeric_limits<T>::max());\\\",\\r\\n            \\\"\\\\tpriority_queue <pair <T, int>, vector <pair <T, int>>, greater <pair <T, int>>> pq;\\\",\\r\\n            \\\"\\\\tpq.emplace(dist[start] = 0, start);\\\",\\r\\n            \\\"\\\\twhile (!pq.empty()) {\\\",\\r\\n            \\\"\\\\t\\\\tauto [du, u] = pq.top(); pq.pop();\\\",\\r\\n            \\\"\\\\t\\\\tif (dist[u] != du) continue;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i: g.adj[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tauto &e = g.edges[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint v = e.from ^ e.to ^ u;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (dist[v] > du + e.cost) pq.emplace(dist[v] = du + e.cost, v);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn dist;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename T> vector <T> dijkstra(const graph <T> &g, int start, vector <int> &trace) {\\\",\\r\\n            \\\"\\\\tassert(0 <= start && start < g.n);\\\",\\r\\n            \\\"\\\\ttrace.assign(g.n, -1);\\\",\\r\\n            \\\"\\\\tvector <T> dist(g.n, numeric_limits<T>::max());\\\",\\r\\n            \\\"\\\\tpriority_queue <pair <T, int>, vector <pair <T, int>>, greater <pair <T, int>>> pq;\\\",\\r\\n            \\\"\\\\tpq.emplace(dist[start] = 0, start);\\\",\\r\\n            \\\"\\\\twhile (!pq.empty()) {\\\",\\r\\n            \\\"\\\\t\\\\tauto [du, u] = pq.top(); pq.pop();\\\",\\r\\n            \\\"\\\\t\\\\tif (dist[u] != du) continue;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i: g.adj[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tauto &e = g.edges[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint v = e.from ^ e.to ^ u;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (dist[v] > du + e.cost) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\ttrace[v] = i;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tpq.emplace(dist[v] = du + e.cost, v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn dist;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename T> vector <int> find_eulerian_path(const graph <T> &g, int &root) {\\\",\\r\\n            \\\"\\\\tif (g.edges.empty()) {\\\",\\r\\n            \\\"\\\\t\\\\troot = 0;\\\",\\r\\n            \\\"\\\\t\\\\treturn vector<int>();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvector <int> in_deg(g.n, 0), out_deg(g.n, 0);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < (int) g.edges.size(); ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tauto &e = g.edges[i];\\\",\\r\\n            \\\"\\\\t\\\\t++out_deg[e.from]; ++in_deg[e.to];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\troot = -1;\\\",\\r\\n            \\\"\\\\tint odd = 0;\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < g.n; ++i) if ((in_deg[i] + out_deg[i]) & 1) {\\\",\\r\\n            \\\"\\\\t\\\\todd++;\\\",\\r\\n            \\\"\\\\t\\\\tif (root == -1 || out_deg[i] - in_deg[i] > out_deg[root] - in_deg[root]) root = i;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tif (odd > 2) {\\\",\\r\\n            \\\"\\\\t\\\\troot = -1;\\\",\\r\\n            \\\"\\\\t\\\\treturn vector<int>();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tif (root == -1) {\\\",\\r\\n            \\\"\\\\t\\\\troot = 0;\\\",\\r\\n            \\\"\\\\t\\\\twhile (root < g.n && in_deg[root] + out_deg[root] == 0) root++;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvector <bool> used(g.edges.size(), false);\\\",\\r\\n            \\\"\\\\tvector <int> ptr(g.n, 0), balance(g.n, 0), res(g.edges.size());\\\",\\r\\n            \\\"\\\\tint stack_ptr = 0, write_ptr = g.edges.size(), u = root;\\\",\\r\\n            \\\"\\\\twhile (true) {\\\",\\r\\n            \\\"\\\\t\\\\tbool found = false;\\\",\\r\\n            \\\"\\\\t\\\\twhile (ptr[u] < (int) g.adj[u].size()) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint i = g.adj[u][ptr[u]++];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (used[i]) continue;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tused[i] = true;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tres[stack_ptr++] = i;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tauto &e = g.edges[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tbalance[u]++;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tu ^= e.from ^ e.to;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tbalance[u]--;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfound = true;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tbreak;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tif (!found) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (!stack_ptr) break;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint i = res[--stack_ptr];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tres[--write_ptr] = i;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tauto &e = g.edges[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tu ^= e.from ^ e.to;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tint disbalance = 0;\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < g.n; ++i) disbalance += abs(balance[i]);\\\",\\r\\n            \\\"\\\\tif (write_ptr != 0 || disbalance > 2) {\\\",\\r\\n            \\\"\\\\t\\\\troot = -1;\\\",\\r\\n            \\\"\\\\t\\\\treturn vector<int>();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn res;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename T> vector <int> find_topsort(const digraph <T> &g) {\\\",\\r\\n            \\\"\\\\tvector <int> deg(g.n, 0), res;\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < (int) g.edges.size(); ++i) ++deg[g.edges[i].to];\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < g.n; ++i) if (!deg[i]) res.push_back(i);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < (int) res.size(); i++) {\\\",\\r\\n            \\\"\\\\t\\\\tint u = res[i];\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i: g.adj[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint v = g.edges[i].to;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (!--deg[v]) res.push_back(v);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tif ((int) res.size() != g.n) return vector<int>();\\\",\\r\\n            \\\"\\\\treturn res;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename T> vector <int> tarjan(const digraph <T> &g, int &cnt) {\\\",\\r\\n            \\\"\\\\tvector <int> low(g.n, -1), num(g.n, -1), groups(g.n, -1);\\\",\\r\\n            \\\"\\\\tstack <int> st;\\\",\\r\\n            \\\"\\\\tint t = 0;\\\",\\r\\n            \\\"\\\\tcnt = 0;\\\",\\r\\n            \\\"\\\\tauto dfs = [&] (auto dfs, int u) -> void {\\\",\\r\\n            \\\"\\\\t\\\\tlow[u] = num[u] = t++;\\\",\\r\\n            \\\"\\\\t\\\\tst.push(u);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i: g.adj[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint v = g.edges[i].to;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (num[v] == -1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tdfs(dfs, v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tlow[u] = min(low[u], low[v]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t} else low[u] = min(low[u], num[v]);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tif (low[u] == num[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint v;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tdo {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tv = st.top(); st.pop();\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tlow[v] = num[v] = g.n;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tgroups[v] = cnt;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t} while (v != u);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t++cnt;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < g.n; ++i) if (num[i] == -1) dfs(dfs, i);\\\",\\r\\n            \\\"\\\\treturn groups;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename T> vector <int> kosaraju(const digraph <T> &g, int &cnt) {\\\",\\r\\n            \\\"\\\\tdigraph <T> g_rev = g.reverse();\\\",\\r\\n            \\\"\\\\tvector <int> order;\\\",\\r\\n            \\\"\\\\tvector <bool> visited(g.n);\\\",\\r\\n            \\\"\\\\tauto dfs1 = [&] (auto dfs1, int u) -> void {\\\",\\r\\n            \\\"\\\\t\\\\tvisited[u] = true;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i: g.adj[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tauto &e = g.edges[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint v = e.to;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (!visited[v]) dfs1(dfs1, v);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\torder.push_back(u);\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < g.n; ++i) if (!visited[i]) dfs1(dfs1, i);\\\",\\r\\n            \\\"\\\\tvector <int> c(g.n, -1);\\\",\\r\\n            \\\"\\\\tauto dfs2 = [&] (auto dfs2, int u) -> void {\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i: g_rev.adj[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tauto &e = g_rev.edges[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint v = e.to;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (c[v] == -1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tc[v] = c[u];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tdfs2(dfs2, v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tcnt = 0;\\\",\\r\\n            \\\"\\\\tfor (int id = g.n; id-- > 0; ) {\\\",\\r\\n            \\\"\\\\t\\\\tint i = order[id];\\\",\\r\\n            \\\"\\\\t\\\\tif (c[i] != -1) continue;\\\",\\r\\n            \\\"\\\\t\\\\tc[i] = cnt++;\\\",\\r\\n            \\\"\\\\t\\\\tdfs2(dfs2, i);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn c;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename T> vector<int> find_dominators(const digraph <T> &g, int root) {\\\",\\r\\n            \\\"\\\\tint n = g.n;\\\",\\r\\n            \\\"\\\\tvector <int> pos(n, -1), order, parent(n, -1);\\\",\\r\\n            \\\"\\\\tfunction <void(int)> dfs = [&g, &pos, &order, &parent, &dfs] (int u) {\\\",\\r\\n            \\\"\\\\t\\\\tpos[u] = (int) order.size();\\\",\\r\\n            \\\"\\\\t\\\\torder.push_back(u);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i: g.adj[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint v = g.edges[i].to;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (pos[v] == -1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tparent[v] = u;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tdfs(v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tdfs(root);\\\",\\r\\n            \\\"\\\\tvector <int> p(n), best(n), sdom = pos;\\\",\\r\\n            \\\"\\\\tiota(p.begin(), p.end(), 0);\\\",\\r\\n            \\\"\\\\tiota(best.begin(), best.end(), 0);\\\",\\r\\n            \\\"\\\\tfunction <int(int)> find_best = [&p, &best, &sdom, &find_best] (int x) {\\\",\\r\\n            \\\"\\\\t\\\\tif (p[x] != x) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint u = find_best(p[x]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (sdom[u] < sdom[best[x]]) best[x] = u;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tp[x] = p[p[x]];\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tif (sdom[best[p[x]]] < sdom[best[x]]) best[x] = best[p[x]];\\\",\\r\\n            \\\"\\\\t\\\\treturn best[x];\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tdigraph <T> g_rev = g.reverse();\\\",\\r\\n            \\\"\\\\tvector <int> idom(n, -1), link(n, 0);\\\",\\r\\n            \\\"\\\\tvector <vector <int>> bucket(n);\\\",\\r\\n            \\\"\\\\tfor (int i = (int) order.size() - 1; i >= 0; i--) {\\\",\\r\\n            \\\"\\\\t\\\\tint u = order[i];\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i: g_rev.adj[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint v = g_rev.edges[i].to;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (pos[v] != -1) sdom[u] = min(sdom[u], sdom[find_best(v)]);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tidom[u] = order[sdom[u]];\\\",\\r\\n            \\\"\\\\t\\\\tfor (int v: bucket[u]) link[v] = find_best(v);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i: g.adj[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint v = g.edges[i].to;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (parent[v] == u) p[v] = u;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tbucket[order[sdom[u]]].push_back(u);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tfor (int i = 1; i < (int) order.size(); ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tint u = order[i];\\\",\\r\\n            \\\"\\\\t\\\\tidom[u] = idom[link[u]];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn idom;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"} using namespace GRAPH;\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"GRAPH\\\"\\r\\n    },\\r\\n    \\\"GRADER\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"GRADER\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"#include <bits/stdc++.h>\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"using namespace std;\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"#define\\\\t\\\\t\\\\t\\\\t  fi  first\\\",\\r\\n            \\\"#define\\\\t\\\\t\\\\t\\\\t  se  second\\\",\\r\\n            \\\"#define\\\\t\\\\t\\\\t\\\\tleft  ___left\\\",\\r\\n            \\\"#define\\\\t\\\\t\\\\t   right  ___right\\\",\\r\\n            \\\"#define\\\\t\\\\tscan_op(...)  istream & operator >> (istream &in, __VA_ARGS__ &u)\\\",\\r\\n            \\\"#define\\\\t   print_op(...)  ostream & operator << (ostream &out, const __VA_ARGS__ &u)\\\",\\r\\n            \\\"#ifdef LOCAL\\\",\\r\\n            \\\"\\\\t#include \\\\\\\"debug.h\\\\\\\"\\\",\\r\\n            \\\"#else\\\",\\r\\n            \\\"\\\\t#define file(name) if (fopen(name\\\\\\\".inp\\\\\\\", \\\\\\\"r\\\\\\\")) { freopen(name\\\\\\\".inp\\\\\\\", \\\\\\\"r\\\\\\\", stdin); freopen(name\\\\\\\".out\\\\\\\", \\\\\\\"w\\\\\\\", stdout); }\\\",\\r\\n            \\\"\\\\t#define DB(...) 23\\\",\\r\\n            \\\"\\\\t#define db(...) 23\\\",\\r\\n            \\\"\\\\t#define debug(...) 23\\\",\\r\\n            \\\"#endif\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"namespace std {\\\",\\r\\n            \\\"template <class U, class V> scan_op(pair <U, V>) { return in >> u.first >> u.second; }\\\",\\r\\n            \\\"template <class T> scan_op(vector <T>) { for (size_t i = 0; i < u.size(); ++i) in >> u[i]; return in; }\\\",\\r\\n            \\\"template <class U, class V> print_op(pair <U, V>) { return out << '(' << u.first << \\\\\\\", \\\\\\\" << u.second << ')'; }\\\",\\r\\n            \\\"template <size_t i, class T> ostream &print_tuple_utils(ostream &out, const T &tup) { if constexpr(i == tuple_size<T>::value) return out << \\\\\\\")\\\\\\\"; else return print_tuple_utils<i + 1, T>(out << (i ? \\\\\\\", \\\\\\\" : \\\\\\\"(\\\\\\\") << get<i>(tup), tup); }\\\",\\r\\n            \\\"template <class...U> print_op(tuple <U...>) { return print_tuple_utils<0, tuple <U...>>(out, u); }\\\",\\r\\n            \\\"template <class Con, class = decltype(begin(declval<Con>()))>typename enable_if <!is_same<Con, string>::value, ostream &>::type operator << (ostream &out, const Con &con) { out << '{'; for (__typeof(con.begin()) it = con.begin(); it != con.end(); ++it) out << (it == con.begin() ? \\\\\\\"\\\\\\\" : \\\\\\\", \\\\\\\") << *it; return out << '}'; }\\\",\\r\\n            \\\"template <class T> print_op(stack <T>) { vector <T> v; stack <T> st = u; while (!st.empty()) v.push_back(st.top()), st.pop(); reverse(v.begin(), v.end()); return out << v; }\\\",\\r\\n            \\\"template <class T> print_op(queue <T>) { queue <T> q = u; out << '{'; while (!q.empty()) { out << q.front(); q.pop(); if (!q.empty()) out << \\\\\\\", \\\\\\\"; } out << '}'; return out; }\\\",\\r\\n            \\\"template <class T, class X, class Y> print_op(priority_queue <T, X, Y>) { priority_queue <T, X, Y> pq = u; out << '{'; while (!pq.empty()) { out << pq.top(); pq.pop(); if (!pq.empty()) out << \\\\\\\", \\\\\\\"; } out << '}'; return out; }\\\",\\r\\n            \\\"template <class Fun> class y_combinator_result { Fun fun_; public: template <class T> explicit y_combinator_result(T &&fun): fun_(forward<T>(fun)) {} template <class...Args> decltype(auto)operator()(Args &&...args) { return fun_(ref(*this), forward<Args>(args)...); } };\\\",\\r\\n            \\\"template <class Fun> decltype(auto)y_combinator(Fun &&fun) { return y_combinator_result<decay_t<Fun>>(forward<Fun>(fun)); }\\\",\\r\\n            \\\"template <typename T, int D> struct Vec: public vector <Vec<T, D - 1>> { static_assert(D >= 1, \\\\\\\"Vector dimension must be greater than zero!\\\\\\\"); template <typename ...Args> Vec(int n = 0, Args ...args): vector <Vec<T, D - 1>>(n, Vec<T, D - 1>(args...)) {} };\\\",\\r\\n            \\\"template <typename T> struct Vec<T, 1>: public vector<T>{ Vec(int n = 0, const T &val = T()): vector<T>(n, val) {} };\\\",\\r\\n            \\\"#if __cplusplus < 202002L\\\",\\r\\n            \\\"template <class T> int ssize(const T &a) { return a.size(); }\\\",\\r\\n            \\\"#endif\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"struct Benchmark {\\\",\\r\\n            \\\"\\\\tunsigned long long tim, newtim;\\\",\\r\\n            \\\"\\\\tunsigned long long get_cur_time() { return chrono::steady_clock::now().time_since_epoch().count(); }\\\",\\r\\n            \\\"\\\\tBenchmark() { tim = newtim = get_cur_time(); }\\\",\\r\\n            \\\"\\\\tpair <string, long double> section(string name) {\\\",\\r\\n            \\\"\\\\t\\\\tnewtim = get_cur_time(); long double res = (long double) (newtim - tim) / 1e9;\\\",\\r\\n            \\\"\\\\t\\\\tstringstream ss; ss << fixed << setprecision(9) << name << \\\\\\\": \\\\\\\" << res << \\\\\\\"s.\\\\\\\";\\\",\\r\\n            \\\"\\\\t\\\\ttim = newtim; string ans; getline(ss, ans); return pair {ans, res};\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"const string NAME = \\\\\\\"${TM_DIRECTORY/^.+[\\\\\\\\/\\\\\\\\\\\\\\\\]+(.*)$/$1/}\\\\\\\";\\\",\\r\\n            \\\"const int NUM_TEST = 1000;\\\",\\r\\n            \\\"const long double TIME_LIMIT = 10;\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"void check_status(int status, const string &where) {\\\",\\r\\n            \\\"\\\\tif (!status) return;\\\",\\r\\n            \\\"\\\\tcout << where << \\\\\\\" -> program exited abnormally\\\\\\\\n\\\\\\\";\\\",\\r\\n            \\\"\\\\texit(0);\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"int main(void) {\\\",\\r\\n            \\\"\\\\tfor (int iTest = 1; iTest <= NUM_TEST; ++iTest) {\\\",\\r\\n            \\\"\\\\t\\\\tcout << \\\\\\\"Running on test \\\\\\\" << iTest;\\\",\\r\\n            \\\"\\\\t\\\\tcheck_status(system(\\\\\\\"./gen.exe\\\\\\\"), \\\\\\\"\\\\\\\\t./generator\\\\\\\");\\\",\\r\\n            \\\"\\\\t\\\\tBenchmark bm;\\\",\\r\\n            \\\"\\\\t\\\\tcheck_status(system((\\\\\\\"./\\\\\\\" + NAME + \\\\\\\".exe\\\\\\\").c_str()), \\\\\\\"\\\\\\\\t./\\\\\\\" + NAME);\\\",\\r\\n            \\\"\\\\t\\\\tauto bms = bm.section(\\\\\\\"\\\\\\\\ttime\\\\\\\");\\\",\\r\\n            \\\"\\\\t\\\\t// cout << bms.fi;$0\\\",\\r\\n            \\\"\\\\t\\\\tcout << endl;\\\",\\r\\n            \\\"\\\\t\\\\tif (bms.se > TIME_LIMIT) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tcout << \\\\\\\"Time limit exceeded on test \\\\\\\" << iTest << '\\\\\\\\n';\\\",\\r\\n            \\\"\\\\t\\\\t\\\\treturn 0;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tcheck_status(system((\\\\\\\"./\\\\\\\" + NAME + \\\\\\\"_bf.exe\\\\\\\").c_str()), \\\\\\\"\\\\\\\\t./\\\\\\\" + NAME + \\\\\\\"_bf\\\\\\\");\\\",\\r\\n            \\\"\\\\t\\\\tif (system((\\\\\\\"diff -w \\\\\\\" + NAME + \\\\\\\".out \\\\\\\" + NAME + \\\\\\\".ans\\\\\\\").c_str())) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tcout << \\\\\\\"Wrong answer on test \\\\\\\" << iTest << '\\\\\\\\n';\\\",\\r\\n            \\\"\\\\t\\\\t\\\\treturn 0;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tif (iTest % 5 == 0) system(\\\\\\\"clear\\\\\\\");\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tcout << \\\\\\\"Accepted!\\\\\\\\n\\\\\\\";\\\",\\r\\n            \\\"\\\\treturn 0;\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"GRADER\\\"\\r\\n    },\\r\\n    \\\"GEOMETRY\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"GEOMETRY\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"struct Point {\\\",\\r\\n            \\\"\\\\tlong long x, y;\\\",\\r\\n            \\\"\\\\tPoint(long long x = 0, long long y = 0): x(x), y(y) {}\\\",\\r\\n            \\\"\\\\tfriend scan_op(Point) { return in >> u.x >> u.y; }\\\",\\r\\n            \\\"\\\\tfriend print_op(Point) { return out << make_pair(u.x, u.y); }\\\",\\r\\n            \\\"\\\\tbool operator == (const Point &other) const { return x == other.x && y == other.y; }\\\",\\r\\n            \\\"\\\\tbool operator < (const Point &other) const { return make_pair(x, y) < make_pair(other.x, other.y); }\\\",\\r\\n            \\\"\\\\tPoint & operator += (const Point &other) {x += other.x; y += other.y; return *this; }\\\",\\r\\n            \\\"\\\\tPoint & operator -= (const Point &other) { x -= other.x; y -= other.y; return *this; }\\\",\\r\\n            \\\"\\\\tPoint & operator *= (long long v) { x *= v; y *= v; return *this; }\\\",\\r\\n            \\\"\\\\tPoint & operator /= (long long v) { x /= v; y /= v; return *this; }\\\",\\r\\n            \\\"\\\\tPoint operator + (const Point &other) const { return Point(*this) += other; }\\\",\\r\\n            \\\"\\\\tPoint operator - (const Point &other) const { return Point(*this) -= other; }\\\",\\r\\n            \\\"\\\\tPoint operator * (long long v) const { return Point(*this) *= v; }\\\",\\r\\n            \\\"\\\\tPoint operator / (long long v) const { return Point(*this) /= v; }\\\",\\r\\n            \\\"\\\\tlong long dot(const Point &other) const { return x * other.x + y * other.y; }\\\",\\r\\n            \\\"\\\\tlong long cross(const Point &other) const { return x * other.y - y * other.x; }\\\",\\r\\n            \\\"\\\\tlong long norm(void) const { return x * x + y * y; }\\\",\\r\\n            \\\"\\\\tdouble length(void) const { return sqrtl(norm()); }\\\",\\r\\n            \\\"\\\\tdouble angle(const Point &other) const { return acos(dot(other) / length() / other.length()); }\\\",\\r\\n            \\\"\\\\tlong long cross(const Point &a, const Point &b) const { return (a - *this).cross(b - *this); }\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"int sgn(long long val) { return val < 0 ? -1 : !!val; }\\\",\\r\\n            \\\"int ccw(const Point &a, const Point &b, const Point &c) { return sgn(a.cross(b, c)); }\\\",\\r\\n            \\\"double linePointDist(const Point &a, const Point &b, const Point &c, bool isSegment) {\\\",\\r\\n            \\\"\\\\tdouble dist = abs((b - a).cross(c - a)) / (a - b).length();\\\",\\r\\n            \\\"\\\\tif (isSegment) {\\\",\\r\\n            \\\"\\\\t\\\\tif ((a - b).dot(c - b) < 0) return (b - c).length();\\\",\\r\\n            \\\"\\\\t\\\\tif ((b - a).dot(c - a) < 0) return (a - c).length();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn dist;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"bool inter1(long long a, long long b, long long c, long long d) {\\\",\\r\\n            \\\"\\\\tif (a > b) swap(a, b);\\\",\\r\\n            \\\"\\\\tif (c > d) swap(c, d);\\\",\\r\\n            \\\"\\\\treturn max(a, c) <= min(b, d);\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"bool check_inter(const Point &a, const Point &b, const Point &p) {\\\",\\r\\n            \\\"\\\\treturn !a.cross(b, p) && inter1(a.x, b.x, p.x, p.x) && inter1(a.y, b.y, p.y, p.y);\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"bool check_inter(const Point &a, const Point &b, const Point &c, const Point &d) {\\\",\\r\\n            \\\"\\\\tif (!c.cross(a, d) && !c.cross(b, d)) \\\",\\r\\n            \\\"\\\\t\\\\treturn inter1(a.x, b.x, c.x, d.x) && inter1(a.y, b.y, c.y, d.y);\\\",\\r\\n            \\\"\\\\treturn ccw(a, b, c) != ccw(a, b, d) && ccw(c, d, a) != ccw(c, d, b);\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"struct Line {\\\",\\r\\n            \\\"\\\\t// ax + by = c\\\",\\r\\n            \\\"\\\\tlong long a, b, c;\\\",\\r\\n            \\\"\\\\tLine(long long a = 0, long long b = 0, long long c = 0): a(a), b(b), c(c) {}\\\",\\r\\n            \\\"\\\\tLine(const Point &m, const Point &n) {\\\",\\r\\n            \\\"\\\\t\\\\ta = m.y - n.y;\\\",\\r\\n            \\\"\\\\t\\\\tb = n.x - m.x;\\\",\\r\\n            \\\"\\\\t\\\\tc = a * m.x + b * m.y;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tbool intersect(const Line &other, Point &res) const {\\\",\\r\\n            \\\"\\\\t\\\\tlong long x = a * other.b - b * other.a;\\\",\\r\\n            \\\"\\\\t\\\\tif (!x) return false;\\\",\\r\\n            \\\"\\\\t\\\\tres.x = (other.b * c - b * other.c) / x;\\\",\\r\\n            \\\"\\\\t\\\\tres.y = (a * other.c - c * other.a) / x;\\\",\\r\\n            \\\"\\\\t\\\\treturn true;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tbool parallel(const Line &other) const {\\\",\\r\\n            \\\"\\\\t\\\\treturn a * other.b - b * other.a == 0;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tbool equivalent(const Line &other) const {\\\",\\r\\n            \\\"\\\\t\\\\treturn a * other.b - b * other.a == 0\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t&& a * other.c - c * other.a == 0\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t&& b * other.c - c * other.b == 0;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"void convex_hull(vector <Point> &p) {\\\",\\r\\n            \\\"\\\\tif (p.size() <= 1) return;\\\",\\r\\n            \\\"\\\\tsort(p.begin(), p.end());\\\",\\r\\n            \\\"\\\\tPoint p1 = p[0], p2 = p.back();\\\",\\r\\n            \\\"\\\\tvector <Point> up {p1}, down {p1};\\\",\\r\\n            \\\"\\\\tfor (int i = 1; i < (int) p.size(); ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tint c = ccw(p1, p[i], p2);\\\",\\r\\n            \\\"\\\\t\\\\tif (i == (int) p.size() - 1 || c < 0) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\twhile (up.size() > 1 && ccw(up.end()[-2], up.back(), p[i]) >= 0) up.pop_back();\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tup.push_back(p[i]);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tif (i == (int) p.size() - 1 || c > 0) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\twhile (down.size() > 1 && ccw(down.end()[-2], down.back(), p[i]) <= 0) down.pop_back();\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tdown.push_back(p[i]);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tp = move(up);\\\",\\r\\n            \\\"\\\\tp.insert(p.end(), down.rbegin() + 1, down.rend() - 1);\\\",\\r\\n            \\\"\\\\tif (p.size() == 2 && p[0] == p[1]) p.pop_back();\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"long long area_x2(const vector <Point> &p) {\\\",\\r\\n            \\\"\\\\tlong long res = 0;\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < (int) p.size(); ++i) res += p[i].cross(p[i == (int) p.size() - 1 ? 0 : i + 1]);\\\",\\r\\n            \\\"\\\\treturn abs(res);\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"int n;\\\",\\r\\n            \\\"vector <Point> seq;\\\",\\r\\n            \\\"Point translation;\\\",\\r\\n            \\\"void prepareConvexPolygon(vector <Point> &p) {\\\",\\r\\n            \\\"\\\\tif (ccw(p[0], p[1], p[2]) < 0) reverse(p.begin(), p.end());\\\",\\r\\n            \\\"\\\\tn = p.size();\\\",\\r\\n            \\\"\\\\tint pos = 0;\\\",\\r\\n            \\\"\\\\tfor (int i = 1; i < n; ++i) if (p[i] < p[pos]) pos = i;\\\",\\r\\n            \\\"\\\\trotate(p.begin(), p.begin() + pos, p.end());\\\",\\r\\n            \\\"\\\\t--n;\\\",\\r\\n            \\\"\\\\tseq.resize(n);\\\",\\r\\n            \\\"\\\\ttranslation = p[0];\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < n; ++i) seq[i] = p[i + 1] - translation;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"bool pointInTriangle(const Point &a, const Point &b, const Point &c, const Point &p) {\\\",\\r\\n            \\\"\\\\treturn abs(a.cross(b, c)) == abs(p.cross(a, b)) + abs(p.cross(b, c)) + abs(p.cross(c, a));\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"bool pointInConvexPolygon(Point p) {\\\",\\r\\n            \\\"\\\\tp -= translation;\\\",\\r\\n            \\\"\\\\tif (seq[0].cross(p) < 0) return false;\\\",\\r\\n            \\\"\\\\tif (seq[n - 1].cross(p) > 0) return false;\\\",\\r\\n            \\\"\\\\tif (!seq[0].cross(p)) return seq[0].norm() >= p.norm();\\\",\\r\\n            \\\"\\\\tint l = 0, r = n - 2;\\\",\\r\\n            \\\"\\\\twhile (l <= r) {\\\",\\r\\n            \\\"\\\\t\\\\tint m = (l + r) >> 1;\\\",\\r\\n            \\\"\\\\t\\\\tif (seq[m].cross(p) > 0) l = m + 1;\\\",\\r\\n            \\\"\\\\t\\\\telse r = m - 1;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn pointInTriangle(seq[r], seq[r + 1], Point(0, 0), p);\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"GEOMETRY\\\"\\r\\n    },\\r\\n    \\\"GENERATOR\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"GENERATOR\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"#include \\\\\\\"testlib.h\\\\\\\"\\\",\\r\\n            \\\"#include \\\\\\\"gen_tree.h\\\\\\\"\\\",\\r\\n            \\\"#include <bits/stdc++.h>\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"using namespace std;\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"#define\\\\t\\\\t\\\\t\\\\t  fi  first\\\",\\r\\n            \\\"#define\\\\t\\\\t\\\\t\\\\t  se  second\\\",\\r\\n            \\\"#define\\\\t\\\\t\\\\t\\\\tleft  ___left\\\",\\r\\n            \\\"#define\\\\t\\\\t\\\\t   right  ___right\\\",\\r\\n            \\\"#define\\\\t\\\\tscan_op(...)  istream & operator >> (istream &in, __VA_ARGS__ &u)\\\",\\r\\n            \\\"#define\\\\t   print_op(...)  ostream & operator << (ostream &out, const __VA_ARGS__ &u)\\\",\\r\\n            \\\"#ifdef LOCAL\\\",\\r\\n            \\\"\\\\t#include \\\\\\\"debug.h\\\\\\\"\\\",\\r\\n            \\\"#else\\\",\\r\\n            \\\"\\\\t#define file(name) if (fopen(name\\\\\\\".inp\\\\\\\", \\\\\\\"r\\\\\\\")) { freopen(name\\\\\\\".inp\\\\\\\", \\\\\\\"r\\\\\\\", stdin); freopen(name\\\\\\\".out\\\\\\\", \\\\\\\"w\\\\\\\", stdout); }\\\",\\r\\n            \\\"\\\\t#define DB(...) 23\\\",\\r\\n            \\\"\\\\t#define db(...) 23\\\",\\r\\n            \\\"\\\\t#define debug(...) 23\\\",\\r\\n            \\\"#endif\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"namespace std {\\\",\\r\\n            \\\"template <class U, class V> scan_op(pair <U, V>) { return in >> u.first >> u.second; }\\\",\\r\\n            \\\"template <class T> scan_op(vector <T>) { for (size_t i = 0; i < u.size(); ++i) in >> u[i]; return in; }\\\",\\r\\n            \\\"template <class U, class V> print_op(pair <U, V>) { return out << '(' << u.first << \\\\\\\", \\\\\\\" << u.second << ')'; }\\\",\\r\\n            \\\"template <size_t i, class T> ostream &print_tuple_utils(ostream &out, const T &tup) { if constexpr(i == tuple_size<T>::value) return out << \\\\\\\")\\\\\\\"; else return print_tuple_utils<i + 1, T>(out << (i ? \\\\\\\", \\\\\\\" : \\\\\\\"(\\\\\\\") << get<i>(tup), tup); }\\\",\\r\\n            \\\"template <class...U> print_op(tuple <U...>) { return print_tuple_utils<0, tuple <U...>>(out, u); }\\\",\\r\\n            \\\"template <class Con, class = decltype(begin(declval<Con>()))>typename enable_if <!is_same<Con, string>::value, ostream &>::type operator << (ostream &out, const Con &con) { out << '{'; for (__typeof(con.begin()) it = con.begin(); it != con.end(); ++it) out << (it == con.begin() ? \\\\\\\"\\\\\\\" : \\\\\\\", \\\\\\\") << *it; return out << '}'; }\\\",\\r\\n            \\\"template <class T> print_op(stack <T>) { vector <T> v; stack <T> st = u; while (!st.empty()) v.push_back(st.top()), st.pop(); reverse(v.begin(), v.end()); return out << v; }\\\",\\r\\n            \\\"template <class T> print_op(queue <T>) { queue <T> q = u; out << '{'; while (!q.empty()) { out << q.front(); q.pop(); if (!q.empty()) out << \\\\\\\", \\\\\\\"; } out << '}'; return out; }\\\",\\r\\n            \\\"template <class T, class X, class Y> print_op(priority_queue <T, X, Y>) { priority_queue <T, X, Y> pq = u; out << '{'; while (!pq.empty()) { out << pq.top(); pq.pop(); if (!pq.empty()) out << \\\\\\\", \\\\\\\"; } out << '}'; return out; }\\\",\\r\\n            \\\"template <class Fun> class y_combinator_result { Fun fun_; public: template <class T> explicit y_combinator_result(T &&fun): fun_(forward<T>(fun)) {} template <class...Args> decltype(auto)operator()(Args &&...args) { return fun_(ref(*this), forward<Args>(args)...); } };\\\",\\r\\n            \\\"template <class Fun> decltype(auto)y_combinator(Fun &&fun) { return y_combinator_result<decay_t<Fun>>(forward<Fun>(fun)); }\\\",\\r\\n            \\\"template <typename T, int D> struct Vec: public vector <Vec<T, D - 1>> { static_assert(D >= 1, \\\\\\\"Vector dimension must be greater than zero!\\\\\\\"); template <typename ...Args> Vec(int n = 0, Args ...args): vector <Vec<T, D - 1>>(n, Vec<T, D - 1>(args...)) {} };\\\",\\r\\n            \\\"template <typename T> struct Vec<T, 1>: public vector<T>{ Vec(int n = 0, const T &val = T()): vector<T>(n, val) {} };\\\",\\r\\n            \\\"#if __cplusplus < 202002L\\\",\\r\\n            \\\"template <class T> int ssize(const T &a) { return a.size(); }\\\",\\r\\n            \\\"#endif\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"const int argc = 2;\\\",\\r\\n            \\\"int seed = chrono::steady_clock::now().time_since_epoch().count();\\\",\\r\\n            \\\"string s = to_string(seed);\\\",\\r\\n            \\\"char* argv[argc] = {&s[0], &s[0]};\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"int main(void) {\\\",\\r\\n            \\\"\\\\tios_base::sync_with_stdio(false); cin.tie(nullptr); // cout.tie(nullptr);\\\",\\r\\n            \\\"\\\\tregisterGen(argc, argv, 1);\\\",\\r\\n            \\\"\\\\tfreopen(\\\\\\\"${TM_DIRECTORY/^.+[\\\\\\\\/\\\\\\\\\\\\\\\\]+(.*)$/$1/}.inp\\\\\\\", \\\\\\\"w\\\\\\\", stdout);\\\",\\r\\n            \\\"\\\\t$0\\\",\\r\\n            \\\"\\\\t// cerr << \\\\\\\"Time elapsed: \\\\\\\" << TIME << \\\\\\\" s.\\\\\\\\n\\\\\\\";\\\",\\r\\n            \\\"\\\\treturn 0;\\\",\\r\\n            \\\"}\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"GENERATOR\\\"\\r\\n    },\\r\\n    \\\"GAUSS_ELIMINATION\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"GAUSS_ELIMINATION\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"int GaussianElimination(vector <vector <double>> a, vector <double> &res) {\\\",\\r\\n            \\\"\\\\tint n = a.size();\\\",\\r\\n            \\\"\\\\tint m = (int) a[0].size() - 1;\\\",\\r\\n            \\\"\\\\tvector <int> where(m, -1);\\\",\\r\\n            \\\"\\\\tfor (int i = 0, j = 0; i < n && j < m; ++j) {\\\",\\r\\n            \\\"\\\\t\\\\tint pos = i;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int k = i + 1; k < n; ++k) if (abs(a[k][j]) > abs(a[pos][j])) pos = k;\\\",\\r\\n            \\\"\\\\t\\\\tif (abs(a[pos][j]) < EPS) continue;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int k = j; k <= m; ++k) swap(a[i][k], a[pos][k]);\\\",\\r\\n            \\\"\\\\t\\\\twhere[j] = i;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int k = 0; k < n; ++k) if (k != i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tdouble c = a[k][j] / a[i][j];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int l = j; l <= m; ++l) a[k][l] -= a[i][l] * c;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t++i;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tres.assign(m, 0);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < m; ++i) if (where[i] != -1) res[i] = a[where[i]][m] / a[where[i]][i];\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < n; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tdouble sum = 0;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int j = 0; j < m; ++j) sum += res[j] * a[i][j];\\\",\\r\\n            \\\"\\\\t\\\\tif (abs(sum - a[i][m]) > EPS) return 0;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < m; ++i) if (where[i] == -1) return 2; // INF\\\",\\r\\n            \\\"\\\\treturn 1;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"GAUSS_ELIMINATION\\\"\\r\\n    },\\r\\n    \\\"FENWICK_TREE\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"FENWICK_TREE\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"template <class T> struct FenwickTree {\\\",\\r\\n            \\\"\\\\tint n; vector <T> bit;\\\",\\r\\n            \\\"\\\\tFenwickTree() = default;\\\",\\r\\n            \\\"\\\\tFenwickTree(int _n): n(_n), bit(n + 1, T{}) {}\\\",\\r\\n            \\\"\\\\tFenwickTree(const vector <T> &a): n(a.size()), bit(a.size() + 1, T{}) {\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 1; i <= n; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tbit[i] += a[i - 1];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (i + (i & -i) <= n) bit[i + (i & -i)] += bit[i];\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid reset(void) { fill(bit.begin(), bit.end(), T{}); }\\\",\\r\\n            \\\"\\\\tvoid update(int i, T val) { for (i = max(1, i + 1); i <= n; i += i & -i) bit[i] += val; }\\\",\\r\\n            \\\"\\\\tT get(int i) {\\\",\\r\\n            \\\"\\\\t\\\\tif (i < 0) return T{};\\\",\\r\\n            \\\"\\\\t\\\\tT res = T{};\\\",\\r\\n            \\\"\\\\t\\\\tfor (i = min(i + 1, n); i > 0; i &= i - 1) res += bit[i];\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tT get(int l, int r) { return get(r) - get(l - 1); }\\\",\\r\\n            \\\"\\\\tint upper_bound(T val) {\\\",\\r\\n            \\\"\\\\t\\\\tint res = 0;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = __lg(n); i >= 0; --i)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif ((res | (1 << i)) <= n && val >= bit[res | (1 << i)]) res |= (1 << i), val -= bit[res];\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tint lower_bound(T val) {\\\",\\r\\n            \\\"\\\\t\\\\tint res = 0;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = __lg(n); i >= 0; --i)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif ((res | (1 << i)) <= n && val > bit[res | (1 << i)]) res |= (1 << i), val -= bit[res];\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"FENWICK_TREE\\\"\\r\\n    },\\r\\n    \\\"FENWICK_TREE_RANGE\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"FENWICK_TREE_RANGE\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"template<\\\",\\r\\n            \\\"\\\\tclass T,  // data type for nodes\\\",\\r\\n            \\\"\\\\tT (*op) (T, T),  // operator to combine 2 nodes\\\",\\r\\n            \\\"\\\\tT (*e)() // identity element\\\",\\r\\n            \\\"\\\\t>\\\",\\r\\n            \\\"struct FenwickTree_R {\\\",\\r\\n            \\\"\\\\tint n; vector <T> bit1, bit2, a;\\\",\\r\\n            \\\"\\\\tFenwickTree_R() = default;\\\",\\r\\n            \\\"\\\\tFenwickTree_R(int _n): n(_n), bit1(n + 1, e()), bit2(n + 1, e()), a(n + 1, e()) {}\\\",\\r\\n            \\\"\\\\tvoid reset(void) {\\\",\\r\\n            \\\"\\\\t\\\\tfill(bit1.begin(), bit1.end(), e());\\\",\\r\\n            \\\"\\\\t\\\\tfill(bit2.begin(), bit2.end(), e());\\\",\\r\\n            \\\"\\\\t\\\\tfill(a.begin(), a.end(), e());\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"#define lowbit(x) ((x) & -(x))\\\",\\r\\n            \\\"\\\\tFenwickTree_R(const vector <T> &v): n(v.size()), bit1(n + 1, e()), bit2(n + 1, e()), a(n + 1, e()) {\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 1; i <= n; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\ta[i] = v[i - 1];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tbit1[i] = op(bit1[i], a[i]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (i + lowbit(i) <= n) bit1[i + lowbit(i)] = op(bit1[i + lowbit(i)], bit1[i]);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = n; i > 0; --i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tbit2[i] = op(a[i], bit2[i]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (i - lowbit(i) > 0) bit2[i - lowbit(i)] = op(bit2[i], bit2[i - lowbit(i)]);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid set(int p, T val) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= p && p < n);\\\",\\r\\n            \\\"\\\\t\\\\t++p;\\\",\\r\\n            \\\"\\\\t\\\\ta[p] = val;\\\",\\r\\n            \\\"\\\\t\\\\tT cur = val;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = p, l = p - 1, r = p + 1; i <= n; i += lowbit(i)) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (; r < i; r += lowbit(r)) cur = op(cur, bit2[r]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (; l > i - lowbit(i); l -= lowbit(l)) cur = op(bit1[l], cur);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tbit1[i] = i == p ? cur : op(cur, a[r]);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tcur = val;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = p, l = p - 1, r = p + 1; i > 0; i -= lowbit(i)) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (; r < min(n + 1, i + lowbit(i)); r += lowbit(r)) cur = op(cur, bit2[r]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (; l > i; l -= lowbit(l)) cur = op(bit1[l], cur);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tbit2[i] = i == p ? cur : op(a[l], cur);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid get(int p) const { return a[p]; }\\\",\\r\\n            \\\"\\\\t// Get product in range [l, r-1]\\\",\\r\\n            \\\"\\\\t// For empty segment (l == r) -> return e()\\\",\\r\\n            \\\"\\\\tT prod(int l, int r) const {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= l && l <= r && r <= n);\\\",\\r\\n            \\\"\\\\t\\\\tif (l == r) return e();\\\",\\r\\n            \\\"\\\\t\\\\t++l;\\\",\\r\\n            \\\"\\\\t\\\\tT lft = e(), rgt = e();\\\",\\r\\n            \\\"\\\\t\\\\tint i;\\\",\\r\\n            \\\"\\\\t\\\\tfor (i = l; i + lowbit(i) <= r; i += lowbit(i)) lft = op(lft, bit2[i]);\\\",\\r\\n            \\\"\\\\t\\\\tlft = op(lft, a[i]);\\\",\\r\\n            \\\"\\\\t\\\\tfor (i = r; i - lowbit(i) >= l; i -= lowbit(i)) rgt = op(bit1[i], rgt);\\\",\\r\\n            \\\"\\\\t\\\\treturn op(lft, rgt);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tT all_prod() const {\\\",\\r\\n            \\\"\\\\t\\\\tT res = e();\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = n; i > 0; i -= lowbit(i)) res = op(bit1[i], res);\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"// FenwickTree_R examples {{{\\\",\\r\\n            \\\"// Examples: Commonly used FenwickTree_R ops: max / min\\\",\\r\\n            \\\"struct MaxFenwickOp {\\\",\\r\\n            \\\"\\\\tstatic int op(int x, int y) { return max(x, y); }\\\",\\r\\n            \\\"\\\\tstatic int e() { return -1e9; }\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"struct MinFenwickOP {\\\",\\r\\n            \\\"\\\\tstatic int op(int x, int y) { return min(x, y); }\\\",\\r\\n            \\\"\\\\tstatic int e() { return 1e9; }\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"using MaxFenwick = FenwickTree_R <int, MaxFenwickOp::op, MaxFenwickOp::e>;\\\",\\r\\n            \\\"using MinFenwick = FenwickTree_R <int, MinFenwickOP::op, MinFenwickOP::e>;\\\",\\r\\n            \\\"// }}}\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"FENWICK_TREE_RANGE\\\"\\r\\n    },\\r\\n    \\\"FASTIO_KACTL\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"FASTIO_KACTL\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"inline char gc() { // like getchar()\\\",\\r\\n            \\\"\\\\tstatic char buf[1 << 16];\\\",\\r\\n            \\\"\\\\tstatic size_t bc, be;\\\",\\r\\n            \\\"\\\\tif (bc >= be) {\\\",\\r\\n            \\\"\\\\t\\\\tbuf[0] = 0, bc = 0;\\\",\\r\\n            \\\"\\\\t\\\\tbe = fread(buf, 1, sizeof(buf), stdin);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn buf[bc++]; // returns 0 on EOF\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"int readInt() {\\\",\\r\\n            \\\"\\\\tint a, c;\\\",\\r\\n            \\\"\\\\twhile ((a = gc()) < 40);\\\",\\r\\n            \\\"\\\\tif (a == '-') return -readInt();\\\",\\r\\n            \\\"\\\\twhile ((c = gc()) >= 48) a = a * 10 + c - 480;\\\",\\r\\n            \\\"\\\\treturn a - 48;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"FASTIO_KACTL\\\"\\r\\n    },\\r\\n    \\\"EDMONDS_KARP\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"EDMONDS_KARP\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"struct MaxFlow {\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tstatic const long long INF = 1e18;\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tstruct Edge {\\\",\\r\\n            \\\"\\\\t\\\\tint from, to;\\\",\\r\\n            \\\"\\\\t\\\\tlong long capa, flow;\\\",\\r\\n            \\\"\\\\t\\\\tEdge(int from = 0, int to = 0, long long capa = 0):\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfrom(from), to(to), capa(capa), flow(0) {}\\\",\\r\\n            \\\"\\\\t\\\\tlong long residual(void) const { return capa - flow; }\\\",\\r\\n            \\\"\\\\t\\\\tbool saturating(void) { return !residual(); }\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tvector <Edge> edges;\\\",\\r\\n            \\\"\\\\tvector <vector <int>> adj;\\\",\\r\\n            \\\"\\\\tvector <int> dist, par;\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tMaxFlow(int n) {\\\",\\r\\n            \\\"\\\\t\\\\tadj.assign(n + 1, vector<int> ());\\\",\\r\\n            \\\"\\\\t\\\\tdist.resize(n + 1);\\\",\\r\\n            \\\"\\\\t\\\\tpar.resize(n + 1);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tvoid addEdge(int u, int v, long long c) {\\\",\\r\\n            \\\"\\\\t\\\\tadj[u].push_back(edges.size());\\\",\\r\\n            \\\"\\\\t\\\\tedges.push_back(Edge(u, v, c));\\\",\\r\\n            \\\"\\\\t\\\\tadj[v].push_back(edges.size());\\\",\\r\\n            \\\"\\\\t\\\\tedges.push_back(Edge(v, u, 0));\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tbool findPath(int s, int t) {\\\",\\r\\n            \\\"\\\\t\\\\tfill(dist.begin(), dist.end(), -1);\\\",\\r\\n            \\\"\\\\t\\\\tfill(par.begin(), par.end(), -1);\\\",\\r\\n            \\\"\\\\t\\\\tqueue <int> q;\\\",\\r\\n            \\\"\\\\t\\\\tdist[s] = 0; q.push(s);\\\",\\r\\n            \\\"\\\\t\\\\twhile (!q.empty()) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint u = q.front(); q.pop();\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int &id: adj[u]) if (edges[id].residual() > 0) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint v = edges[id].to;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (dist[v] == -1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tdist[v] = dist[u] + 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tpar[v] = id;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tq.push(v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn dist[t] != -1;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tlong long getFlow(int s, int t) {\\\",\\r\\n            \\\"\\\\t\\\\tfor (Edge &e: edges) e.flow = 0;\\\",\\r\\n            \\\"\\\\t\\\\tlong long totFlow = 0;\\\",\\r\\n            \\\"\\\\t\\\\twhile (findPath(s, t)) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tlong long delta = INF;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int u = t; u != s; u = edges[par[u]].from)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tdelta = min(delta, edges[par[u]].residual());\\\",\\r\\n            \\\"\\\\t\\\\t\\\\ttotFlow += delta;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int u = t; u != s; u = edges[par[u]].from) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tedges[par[u]].flow += delta;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tedges[par[u] ^ 1].flow -= delta;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn totFlow;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tbool saturating(int s, int t) {\\\",\\r\\n            \\\"\\\\t\\\\tmaxFlow(s, t);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int &id: adj[s]) if (edges[id].from == s && !edges[id].saturating()) return false;\\\",\\r\\n            \\\"\\\\t\\\\treturn true;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"EDMONDS_KARP\\\"\\r\\n    },\\r\\n    \\\"DISJOINT_SPARSE_TABLE\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"DISJOINT_SPARSE_TABLE\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"template <class T, T (*op) (T, T)> struct DisjointSparseTable {\\\",\\r\\n            \\\"\\\\tint n;\\\",\\r\\n            \\\"\\\\tvector <vector <T>> st;\\\",\\r\\n            \\\"\\\\tDisjointSparseTable() {}\\\",\\r\\n            \\\"\\\\tDisjointSparseTable(const vector <T> &a): n(a.size()) {\\\",\\r\\n            \\\"\\\\t\\\\tst.push_back(a);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int p = 1; 1 << p < n; p++) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tst.emplace_back(n);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int mid = 1 << p; mid < n; mid += 1 << (p + 1)) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tst[p][mid - 1] = a[mid - 1];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfor (int j = mid - 2; j >= mid - (1 << p); --j) st[p][j] = op(a[j], st[p][j + 1]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tst[p][mid] = a[mid];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfor (int j = mid + 1; j < min(n, mid + (1 << p)); ++j) st[p][j] = op(st[p][j - 1], a[j]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tT get(int l, int r) const {\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= l && l < r && r <= n);\\\",\\r\\n            \\\"\\\\t\\\\tif (r - l == 1) return st[0][l];\\\",\\r\\n            \\\"\\\\t\\\\tint p = __lg(l ^ (r - 1));\\\",\\r\\n            \\\"\\\\t\\\\treturn op(st[p][l], st[p][r - 1]);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"DISJOINT_SPARSE_TABLE\\\"\\r\\n    },\\r\\n    \\\"DISJOINT_SET_UNION\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"DISJOINT_SET_UNION\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"struct DisjointSet {\\\",\\r\\n            \\\"\\\\tvector <int> par;\\\",\\r\\n            \\\"\\\\tDisjointSet(int n = 0): par(n, -1) {}\\\",\\r\\n            \\\"\\\\tvoid reset(void) { fill(par.begin(), par.end(), -1); }\\\",\\r\\n            \\\"\\\\tvoid resize(int n) { par.assign(n, -1); }\\\",\\r\\n            \\\"\\\\tbool connected(int u, int v) { return find(u) == find(v); }\\\",\\r\\n            \\\"\\\\tbool isRoot(int u) { return par[u] < 0; }\\\",\\r\\n            \\\"\\\\tint size(int u) { return -par[find(u)]; }\\\",\\r\\n            \\\"\\\\tint find(int u) { return par[u] < 0 ? u : par[u] = find(par[u]); }\\\",\\r\\n            \\\"\\\\tbool join(int u, int v) {\\\",\\r\\n            \\\"\\\\t\\\\tif ((u = find(u)) == (v = find(v))) return false;\\\",\\r\\n            \\\"\\\\t\\\\tif (par[u] > par[v]) swap(u, v);\\\",\\r\\n            \\\"\\\\t\\\\tpar[u] += par[v]; par[v] = u;\\\",\\r\\n            \\\"\\\\t\\\\treturn true;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"using DSU = DisjointSet;\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"DISJOINT_SET_UNION\\\"\\r\\n    },\\r\\n    \\\"CONVEX_HULL_TRICK\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"CONVEX_HULL_TRICK\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"struct Line {\\\",\\r\\n            \\\"\\\\tlong long a, b;\\\",\\r\\n            \\\"\\\\tLine(long long a = 0, long long b = INF): a(a), b(b) {}\\\",\\r\\n            \\\"\\\\tlong long eval(long long x) { return a * x + b; }\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"struct ConvexHullTrick {\\\",\\r\\n            \\\"\\\\tvector <Line> lines; int ptr;\\\",\\r\\n            \\\"\\\\tConvexHullTrick(): ptr(0) {}\\\",\\r\\n            \\\"\\\\tbool bad(Line a, Line b, Line c) { return (long double) (c.b - a.b) / (a.a - c.a) < (long double) (b.b - a.b) / (a.a - b.a); }\\\",\\r\\n            \\\"\\\\tvoid addLine(long long a, long long b) {\\\",\\r\\n            \\\"\\\\t\\\\tLine l(a, b);\\\",\\r\\n            \\\"\\\\t\\\\twhile (lines.size() >= 2 && bad(lines.end()[-2], lines.back(), l)) lines.pop_back();\\\",\\r\\n            \\\"\\\\t\\\\tlines.push_back(l);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tLine getMin(long long x) {\\\",\\r\\n            \\\"\\\\t\\\\tif (ptr >= (int) lines.size()) ptr = (int) lines.size() - 1;\\\",\\r\\n            \\\"\\\\t\\\\twhile (ptr < (int) lines.size() - 1 && lines[ptr].eval(x) > lines[ptr + 1].eval(x)) ++ptr;\\\",\\r\\n            \\\"\\\\t\\\\treturn lines[ptr];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"using CHT = ConvexHullTrick;\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"CONVEX_HULL_TRICK\\\"\\r\\n    },\\r\\n    \\\"COMPRESS\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"COMPRESS\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"template <class InIter, class OutIter>  void compress(InIter first, InIter last, OutIter result) { vector <__typeof(*first)> v(first, last); sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); while (first != last) { *result = lower_bound(v.begin(), v.end(), *first) - v.begin(); ++first; ++result; } }\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"COMPRESS\\\"\\r\\n    },\\r\\n    \\\"BUMP_ALLOCATOR\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"BUMP_ALLOCATOR\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"static char buf[450 << 20];\\\",\\r\\n            \\\"void* operator new(size_t s) {\\\",\\r\\n            \\\"\\\\tstatic size_t i = sizeof buf;\\\",\\r\\n            \\\"\\\\tassert(s < i);\\\",\\r\\n            \\\"\\\\treturn (void*) &buf[i -= s];\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"void operator delete(void*) {}\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"BUMP_ALLOCATOR\\\"\\r\\n    },\\r\\n    \\\"BRIDGE_ARTICULATION\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"BRIDGE_ARTICULATION\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"struct BridgeArticulation {\\\",\\r\\n            \\\"\\\\tint n, m, tecc_num, bc_num;\\\",\\r\\n            \\\"\\\\tvector <int> cuts, low, num, tecc_ids;\\\",\\r\\n            \\\"\\\\tvector <vector <int>> bc_groups;\\\",\\r\\n            \\\"\\\\tvector <pair <int, int>> bridges;\\\",\\r\\n            \\\"\\\\tvector <bool> articulation, is_bridge;\\\",\\r\\n            \\\"\\\\tstruct edge {\\\",\\r\\n            \\\"\\\\t\\\\tint to, id;\\\",\\r\\n            \\\"\\\\t\\\\tedge(int to = -1, int id = -1): to(to), id(id) {}\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tvector <pair <int, edge>> edges;\\\",\\r\\n            \\\"\\\\tBridgeArticulation(int _n = 0) : n(_n), m(0) {}\\\",\\r\\n            \\\"\\\\tvoid add(int u, int v) {\\\",\\r\\n            \\\"\\\\t\\\\tedges.emplace_back(u, edge(v, m));\\\",\\r\\n            \\\"\\\\t\\\\tedges.emplace_back(v, edge(u, m++));\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid init() {\\\",\\r\\n            \\\"\\\\t\\\\tcsr <edge> g = csr<edge>(n, edges);\\\",\\r\\n            \\\"\\\\t\\\\tint t = 0;\\\",\\r\\n            \\\"\\\\t\\\\tarticulation.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\tis_bridge.resize(m);\\\",\\r\\n            \\\"\\\\t\\\\tlow.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\tnum.assign(n, -1);\\\",\\r\\n            \\\"\\\\t\\\\ttecc_num = bc_num = 0;\\\",\\r\\n            \\\"\\\\t\\\\tvector <bool> used(m);\\\",\\r\\n            \\\"\\\\t\\\\tvector <int> tecc_st, bc_st;\\\",\\r\\n            \\\"\\\\t\\\\ttecc_ids.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\tbc_groups.clear();\\\",\\r\\n            \\\"\\\\t\\\\tfor (int r = 0; r < n; r++) if (num[r] == -1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint child = 0;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tauto dfs = [&] (auto dfs, int u) -> void {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\ttecc_st.push_back(u);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tbc_st.push_back(u);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tnum[u] = t++;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tlow[u] = n;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfor (int i = g.st[u]; i < g.st[u + 1]; i++) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tint id = g.lst[i].id;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (used[id]) continue;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tused[id] = true;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tint v = g.lst[i].to;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (num[v] == -1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (u == r) ++child;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdfs(dfs, v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (low[v] >= num[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarticulation[u] = true;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tint w;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbc_groups.push_back({u});\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdo {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tw = bc_st.back(); bc_st.pop_back();\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbc_groups.back().push_back(w);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} while (w != v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t++bc_num;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (low[v] > num[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tis_bridge[id] = true;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbridges.emplace_back(u, v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlow[u] = min(low[u], low[v]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t} else low[u] = min(low[u], num[v]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (low[u] >= num[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tint v;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tdo {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv = tecc_st.back(); tecc_st.pop_back();\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttecc_ids[v] = tecc_num;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t} while (v != u);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t++tecc_num;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t};\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tdfs(dfs, r);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tarticulation[r] = child > 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (!child) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tbc_groups.push_back({r});\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t++bc_num;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) if (articulation[i]) cuts.push_back(i);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvector <vector <int>> tecc() {\\\",\\r\\n            \\\"\\\\t\\\\tvector <int> cnt(tecc_num);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int x: tecc_ids) cnt[x]++;\\\",\\r\\n            \\\"\\\\t\\\\tvector <vector <int>> groups(tecc_num);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < tecc_num; i++) groups[i].reserve(cnt[i]);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; i++) groups[tecc_ids[i]].push_back(i);\\\",\\r\\n            \\\"\\\\t\\\\treturn groups;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"BRIDGE_ARTICULATION\\\"\\r\\n    },\\r\\n    \\\"BITSET_TRICK\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"BITSET_TRICK\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"template <size_t bitset_size> void solve(int n) {\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"template <size_t bit = 0> void try_solve(int n) {\\\",\\r\\n            \\\"\\\\tif constexpr(bit < 30) {\\\",\\r\\n            \\\"\\\\t\\\\tif (n <= (1u << bit)) solve<(1u << bit)>(n);\\\",\\r\\n            \\\"\\\\t\\\\telse try_solve<bit + 1>(n);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"BITSET_TRICK\\\"\\r\\n    },\\r\\n    \\\"BIGINT\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"BIGINT\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"const int BASE_DIGITS = 9;\\\",\\r\\n            \\\"const int BASE = 1000000000;\\\",\\r\\n            \\\"struct BigInt {\\\",\\r\\n            \\\"\\\\tint sign;\\\",\\r\\n            \\\"\\\\tvector <int> a;\\\",\\r\\n            \\\"\\\\tBigInt() : sign(1) {}\\\",\\r\\n            \\\"\\\\tBigInt(long long v) { *this = v; }\\\",\\r\\n            \\\"\\\\tBigInt & operator = (long long v) {\\\",\\r\\n            \\\"\\\\t\\\\tsign = 1; if (v < 0) sign = -1, v = -v; a.clear();\\\",\\r\\n            \\\"\\\\t\\\\tfor (; v > 0; v = v / BASE) a.push_back(v % BASE);\\\",\\r\\n            \\\"\\\\t\\\\treturn *this;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tBigInt(const string& s) { read(s); }\\\",\\r\\n            \\\"\\\\tvoid read(const string &s) {\\\",\\r\\n            \\\"\\\\t\\\\tsign = 1; a.clear(); int pos = 0;\\\",\\r\\n            \\\"\\\\t\\\\twhile (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (s[pos] == '-') sign = -sign;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t++pos;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = (int) s.size() - 1; i >= pos; i -= BASE_DIGITS) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint x = 0;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int j = max(pos, i - BASE_DIGITS + 1); j <= i; j++) x = x * 10 + s[j] - '0';\\\",\\r\\n            \\\"\\\\t\\\\t\\\\ta.push_back(x);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\ttrim();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tfriend istream & operator >> (istream &stream, BigInt &v) { string s; stream >> s; v.read(s); return stream; }\\\",\\r\\n            \\\"\\\\tfriend ostream & operator << (ostream &stream, const BigInt &v) {\\\",\\r\\n            \\\"\\\\t\\\\tif (v.sign == -1 && !v.isZero()) stream << '-';\\\",\\r\\n            \\\"\\\\t\\\\tstream << (v.a.empty() ? 0 : v.a.back());\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = (int) v.a.size() - 2; i >= 0; --i) stream << setw(BASE_DIGITS) << setfill('0') << v.a[i];\\\",\\r\\n            \\\"\\\\t\\\\treturn stream;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tbool operator < (const BigInt &v) const {\\\",\\r\\n            \\\"\\\\t\\\\tif (sign != v.sign) return sign < v.sign;\\\",\\r\\n            \\\"\\\\t\\\\tif (a.size() != v.a.size()) return a.size() * sign < v.a.size() * v.sign;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = ((int) a.size()) - 1; i >= 0; i--) if (a[i] != v.a[i]) return a[i] * sign < v.a[i] * sign;\\\",\\r\\n            \\\"\\\\t\\\\treturn false;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tbool operator>(const BigInt &v) const { return v < *this; }\\\",\\r\\n            \\\"\\\\tbool operator<=(const BigInt &v) const { return !(v < *this); }\\\",\\r\\n            \\\"\\\\tbool operator>=(const BigInt &v) const { return !(*this < v); }\\\",\\r\\n            \\\"\\\\tbool operator==(const BigInt &v) const { return !(*this < v) && !(v < *this); }\\\",\\r\\n            \\\"\\\\tbool operator!=(const BigInt &v) const { return *this < v || v < *this; }\\\",\\r\\n            \\\"\\\\tfriend int __compare_abs(const BigInt &x, const BigInt &y) {\\\",\\r\\n            \\\"\\\\t\\\\tif (x.a.size() != y.a.size()) return x.a.size() < y.a.size() ? -1 : 1;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = ((int) x.a.size()) - 1; i >= 0; --i) if (x.a[i] != y.a[i]) return x.a[i] < y.a[i] ? -1 : 1;\\\",\\r\\n            \\\"\\\\t\\\\treturn 0;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tBigInt operator - () const { BigInt res = *this; if (isZero()) return res; res.sign = -sign; return res; }\\\",\\r\\n            \\\"\\\\tvoid __internal_add(const BigInt &v) {\\\",\\r\\n            \\\"\\\\t\\\\tif (a.size() < v.a.size()) a.resize(v.a.size(), 0);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (i == (int) a.size()) a.push_back(0);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\ta[i] += carry + (i < (int) v.a.size() ? v.a[i] : 0);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tcarry = a[i] >= BASE; if (carry) a[i] -= BASE;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid __internal_sub(const BigInt &v) {\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\ta[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tcarry = a[i] < 0; if (carry) a[i] += BASE;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tthis->trim();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tBigInt operator += (const BigInt &v) {\\\",\\r\\n            \\\"\\\\t\\\\tif (sign == v.sign) __internal_add(v);\\\",\\r\\n            \\\"\\\\t\\\\telse {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (__compare_abs(*this, v) >= 0) __internal_sub(v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\telse { BigInt vv = v; swap(*this, vv); __internal_sub(vv); }\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn *this;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tBigInt operator -= (const BigInt &v) {\\\",\\r\\n            \\\"\\\\t\\\\tif (sign == v.sign) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (__compare_abs(*this, v) >= 0) __internal_sub(v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\telse { BigInt vv = v; swap(*this, vv); __internal_sub(vv); this->sign = -this->sign; }\\\",\\r\\n            \\\"\\\\t\\\\t} else __internal_add(v);\\\",\\r\\n            \\\"\\\\t\\\\treturn *this;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\ttemplate <typename L, typename R> typename enable_if <is_convertible<L, BigInt>::value && is_convertible<R, BigInt>::value && is_lvalue_reference < R&& >::value, BigInt>::type friend operator + (L &&l, R &&r) {\\\",\\r\\n            \\\"\\\\t\\\\tBigInt result(forward<L>(l)); result += r; return result;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\ttemplate <typename L, typename R> typename enable_if <is_convertible<L, BigInt>::value && is_convertible<R, BigInt>::value && is_rvalue_reference < R&& >::value, BigInt>::type friend operator + (L &&l, R &&r) {\\\",\\r\\n            \\\"\\\\t\\\\tBigInt result(move(r)); result += l; return result;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\ttemplate <typename L, typename R> typename enable_if <is_convertible<L, BigInt>::value && is_convertible<R, BigInt>::value, BigInt>::type friend operator - (L &&l, R &&r) {\\\",\\r\\n            \\\"\\\\t\\\\tBigInt result(forward<L>(l)); result -= r; return result;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tfriend pair <BigInt, BigInt> divmod(const BigInt &a1, const BigInt &b1) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(b1 > 0);\\\",\\r\\n            \\\"\\\\t\\\\tlong long norm = BASE / (b1.a.back() + 1);\\\",\\r\\n            \\\"\\\\t\\\\tBigInt a = a1.abs() * norm, b = b1.abs() * norm, q = 0, r = 0;\\\",\\r\\n            \\\"\\\\t\\\\tq.a.resize(a.a.size());\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = a.a.size() - 1; i >= 0; i--) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tr *= BASE; r += a.a[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tlong long s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tlong long s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tlong long d = ((long long) BASE * s1 + s2) / b.a.back();\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tr -= b * d; while (r < 0) r += b, --d; q.a[i] = d;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tq.sign = a1.sign * b1.sign; r.sign = a1.sign; q.trim(); r.trim();\\\",\\r\\n            \\\"\\\\t\\\\tauto res = make_pair(q, r / norm); if (res.second < 0) res.second += b1; return res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tBigInt operator / (const BigInt &v) const {\\\",\\r\\n            \\\"\\\\t\\\\tif (v < 0) return divmod(-*this, -v).first;\\\",\\r\\n            \\\"\\\\t\\\\treturn divmod(*this, v).first;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tBigInt operator % (const BigInt &v) const { return divmod(*this, v).second; }\\\",\\r\\n            \\\"\\\\tvoid operator /= (int v) {\\\",\\r\\n            \\\"\\\\t\\\\tassert(v > 0);\\\",\\r\\n            \\\"\\\\t\\\\tif (llabs(v) >= BASE) { *this /= BigInt(v); return; }\\\",\\r\\n            \\\"\\\\t\\\\tif (v < 0) sign = -sign, v = -v;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tlong long cur = a[i] + rem * (long long) BASE;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\ta[i] = (int) (cur / v); rem = (int) (cur % v);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\ttrim();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tBigInt operator / (int v) const {\\\",\\r\\n            \\\"\\\\t\\\\tassert(v > 0);\\\",\\r\\n            \\\"\\\\t\\\\tif (llabs(v) >= BASE) return *this / BigInt(v);\\\",\\r\\n            \\\"\\\\t\\\\tBigInt res = *this; res /= v; return res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid operator /= (const BigInt &v) { *this = *this / v; }\\\",\\r\\n            \\\"\\\\tlong long operator % (long long v) const {\\\",\\r\\n            \\\"\\\\t\\\\tassert(v > 0); assert(v < BASE);\\\",\\r\\n            \\\"\\\\t\\\\tint m = 0; for (int i = (int) a.size() - 1; i >= 0; --i) m = (a[i] + m * (long long) BASE) % v;\\\",\\r\\n            \\\"\\\\t\\\\treturn m * sign;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid operator *= (int v) {\\\",\\r\\n            \\\"\\\\t\\\\tif (llabs(v) >= BASE) { *this *= BigInt(v); return; }\\\",\\r\\n            \\\"\\\\t\\\\tif (v < 0) sign = -sign, v = -v;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (i == (int) a.size()) a.push_back(0);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tlong long cur = a[i] * (long long) v + carry;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tcarry = (int) (cur / BASE);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\ta[i] = (int) (cur % BASE);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\ttrim();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tBigInt operator*(int v) const {\\\",\\r\\n            \\\"\\\\t\\\\tif (llabs(v) >= BASE) return *this * BigInt(v);\\\",\\r\\n            \\\"\\\\t\\\\tBigInt res = *this; res *= v; return res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tstatic vector <int> convert_base(const vector<int> &a, int old_digits, int new_digits) {\\\",\\r\\n            \\\"\\\\t\\\\tvector<long long> p(max(old_digits, new_digits) + 1); p[0] = 1;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 1; i < (int) p.size(); i++) p[i] = p[i - 1] * 10;\\\",\\r\\n            \\\"\\\\t\\\\tvector <int> res; long long cur = 0; int cur_digits = 0;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < (int) a.size(); i++) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tcur += a[i] * p[cur_digits]; cur_digits += old_digits;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\twhile (cur_digits >= new_digits) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tres.push_back((long long)(cur % p[new_digits]));\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tcur /= p[new_digits]; cur_digits -= new_digits;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tres.push_back((int) cur); while (!res.empty() && !res.back()) res.pop_back();\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid fft(vector <complex <double>> &x, bool invert) const {\\\",\\r\\n            \\\"\\\\t\\\\tint n = (int) x.size();\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 1, j = 0; i < n; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint bit = n >> 1; for (; j >= bit; bit >>= 1) j -= bit;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tj += bit; if (i < j) swap(x[i], x[j]);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tfor (int len = 2; len <= n; len <<= 1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tdouble ang = 2 * 3.14159265358979323846 / len * (invert ? -1 : 1);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tcomplex <double> wlen(cos(ang), sin(ang));\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int i = 0; i < n; i += len) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tcomplex <double> w(1);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfor (int j = 0; j < len / 2; ++j) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tcomplex<double> u = x[i + j]; complex<double> v = x[i + j + len / 2] * w;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tx[i + j] = u + v; x[i + j + len / 2] = u - v; w *= wlen;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tif (invert) for (int i = 0; i < n; ++i) x[i] /= n;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid multiply_fft(const vector <int> &x, const vector <int> &y, vector <int> &res) const {\\\",\\r\\n            \\\"\\\\t\\\\tvector <complex <double> > fa(x.begin(), x.end());\\\",\\r\\n            \\\"\\\\t\\\\tvector <complex <double> > fb(y.begin(), y.end());\\\",\\r\\n            \\\"\\\\t\\\\tint n = 1; while (n < (int) max(x.size(), y.size())) n <<= 1; n <<= 1;\\\",\\r\\n            \\\"\\\\t\\\\tfa.resize(n); fb.resize(n); fft(fa, false); fft(fb, false);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) fa[i] *= fb[i];\\\",\\r\\n            \\\"\\\\t\\\\tfft(fa, true); res.resize(n); long long carry = 0;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tlong long t = (long long) (fa[i].real() + 0.5) + carry;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tcarry = t / 1000; res[i] = t % 1000;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tBigInt mul_simple(const BigInt &v) const {\\\",\\r\\n            \\\"\\\\t\\\\tBigInt res;\\\",\\r\\n            \\\"\\\\t\\\\tres.sign = sign * v.sign;\\\",\\r\\n            \\\"\\\\t\\\\tres.a.resize(a.size() + v.a.size());\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < (int) a.size(); ++i)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (a[i])\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfor (int j = 0, carry = 0; j < (int) v.a.size() || carry; ++j) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tlong long cur = res.a[i + j] + (long long) a[i] * (j < (int) v.a.size() ? v.a[j] : 0) + carry;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tcarry = (int) (cur / BASE);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tres.a[i + j] = (int) (cur % BASE);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tres.trim();\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\ttypedef vector <long long> vll;\\\",\\r\\n            \\\"\\\\tstatic vll karatsubaMultiply(const vll &a, const vll &b) {\\\",\\r\\n            \\\"\\\\t\\\\tint n = a.size();\\\",\\r\\n            \\\"\\\\t\\\\tvll res(n + n);\\\",\\r\\n            \\\"\\\\t\\\\tif (n <= 32) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) res[i + j] += a[i] * b[j];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tint k = n >> 1;\\\",\\r\\n            \\\"\\\\t\\\\tvll a1(a.begin(), a.begin() + k), a2(a.begin() + k, a.end()), b1(b.begin(), b.begin() + k), b2(b.begin() + k, b.end());\\\",\\r\\n            \\\"\\\\t\\\\tvll a1b1 = karatsubaMultiply(a1, b1), a2b2 = karatsubaMultiply(a2, b2);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < k; i++) a2[i] += a1[i];\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < k; i++) b2[i] += b1[i];\\\",\\r\\n            \\\"\\\\t\\\\tvll r = karatsubaMultiply(a2, b2);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < (int) a1b1.size(); i++) r[i] -= a1b1[i];\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < (int) a2b2.size(); i++) r[i] -= a2b2[i];\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < (int) r.size(); i++) res[i + k] += r[i];\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < (int) a1b1.size(); i++) res[i] += a1b1[i];\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < (int) a2b2.size(); i++) res[i + n] += a2b2[i];\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tBigInt mul_karatsuba(const BigInt &v) const {\\\",\\r\\n            \\\"\\\\t\\\\tvector <int> x6 = convert_base(this->a, BASE_DIGITS, 6);\\\",\\r\\n            \\\"\\\\t\\\\tvector <int> y6 = convert_base(v.a, BASE_DIGITS, 6);\\\",\\r\\n            \\\"\\\\t\\\\tvll x(x6.begin(), x6.end()), y(y6.begin(), y6.end());\\\",\\r\\n            \\\"\\\\t\\\\twhile (x.size() < y.size()) x.push_back(0);\\\",\\r\\n            \\\"\\\\t\\\\twhile (y.size() < x.size()) y.push_back(0);\\\",\\r\\n            \\\"\\\\t\\\\twhile (x.size() & (x.size() - 1)) x.push_back(0), y.push_back(0);\\\",\\r\\n            \\\"\\\\t\\\\tvll c = karatsubaMultiply(x, y);\\\",\\r\\n            \\\"\\\\t\\\\tBigInt res; res.sign = sign * v.sign; long long carry = 0;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < (int) c.size(); i++) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tlong long cur = c[i] + carry; res.a.push_back((int) (cur % 1000000)); carry = cur / 1000000;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tres.a = convert_base(res.a, 6, BASE_DIGITS); res.trim(); return res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid operator*=(const BigInt &v) { *this = *this * v; }\\\",\\r\\n            \\\"\\\\tBigInt operator*(const BigInt &v) const {\\\",\\r\\n            \\\"\\\\t\\\\tif (a.size() * v.a.size() <= 1000111) return mul_simple(v);\\\",\\r\\n            \\\"\\\\t\\\\tif (a.size() > 500111 || v.a.size() > 500111) return mul_fft(v);\\\",\\r\\n            \\\"\\\\t\\\\treturn mul_karatsuba(v);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tBigInt mul_fft(const BigInt& v) const {\\\",\\r\\n            \\\"\\\\t\\\\tBigInt res; res.sign = sign * v.sign;\\\",\\r\\n            \\\"\\\\t\\\\tmultiply_fft(convert_base(a, BASE_DIGITS, 3), convert_base(v.a, BASE_DIGITS, 3), res.a);\\\",\\r\\n            \\\"\\\\t\\\\tres.a = convert_base(res.a, 3, BASE_DIGITS); res.trim(); return res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tBigInt abs() const { BigInt res = *this; res.sign *= res.sign; return res; }\\\",\\r\\n            \\\"\\\\tvoid trim() { while (!a.empty() && !a.back()) a.pop_back(); if (a.empty()) sign = 1; }\\\",\\r\\n            \\\"\\\\tbool isZero() const { return a.empty() || (a.size() == 1 && !a[0]); }\\\",\\r\\n            \\\"\\\\tfriend BigInt gcd(const BigInt &x, const BigInt &y) { return y.isZero() ? x : gcd(y, x % y); }\\\",\\r\\n            \\\"\\\\tfriend BigInt lcm(const BigInt &x, const BigInt &y) { return x / gcd(x, y) * y; }\\\",\\r\\n            \\\"\\\\tfriend BigInt sqrt(const BigInt &a1) {\\\",\\r\\n            \\\"\\\\t\\\\tBigInt a = a1;\\\",\\r\\n            \\\"\\\\t\\\\twhile (a.a.empty() || a.a.size() % 2 == 1) a.a.push_back(0);\\\",\\r\\n            \\\"\\\\t\\\\tint n = a.a.size();\\\",\\r\\n            \\\"\\\\t\\\\tint firstDigit = (int) sqrt((double) a.a[n - 1] * BASE + a.a[n - 2]), norm = BASE / (firstDigit + 1);\\\",\\r\\n            \\\"\\\\t\\\\ta *= norm; a *= norm;\\\",\\r\\n            \\\"\\\\t\\\\twhile (a.a.empty() || a.a.size() % 2 == 1) a.a.push_back(0);\\\",\\r\\n            \\\"\\\\t\\\\tBigInt r = (long long) a.a[n - 1] * BASE + a.a[n - 2];\\\",\\r\\n            \\\"\\\\t\\\\tfirstDigit = (int) sqrt((double) a.a[n - 1] * BASE + a.a[n - 2]);\\\",\\r\\n            \\\"\\\\t\\\\tint q = firstDigit; BigInt res;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int j = n / 2 - 1; j >= 0; j--) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (; ; --q) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tBigInt r1 = (r - (res * 2 * BigInt(BASE) + q) * q) * BigInt(BASE) * BigInt(BASE) + (j > 0 ? (long long) a.a[2 * j - 1] * BASE + a.a[2 * j - 2] : 0);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (r1 >= 0) { r = r1; break; }\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tres *= BASE; res += q;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (j > 0) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint d1 = res.a.size() + 2 < r.a.size() ? r.a[res.a.size() + 2] : 0;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint d2 = res.a.size() + 1 < r.a.size() ? r.a[res.a.size() + 1] : 0;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint d3 = res.a.size() < r.a.size() ? r.a[res.a.size()] : 0;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tq = ((long long) d1 * BASE * BASE + (long long) d2 * BASE + d3) / (firstDigit * 2);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tres.trim(); return res / norm;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"BIGINT\\\"\\r\\n    },\\r\\n    \\\"BENCHMARK\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"BENCHMARK\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"struct Benchmark {\\\",\\r\\n            \\\"\\\\tunsigned long long tim, newtim;\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tunsigned long long get_cur_time(){\\\",\\r\\n            \\\"\\\\t\\\\treturn chrono::steady_clock::now().time_since_epoch().count();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tBenchmark() {\\\",\\r\\n            \\\"\\\\t\\\\ttim = newtim = get_cur_time();\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"\\\\tstring section(string name) {\\\",\\r\\n            \\\"\\\\t\\\\tnewtim = get_cur_time();\\\",\\r\\n            \\\"\\\\t\\\\tstringstream ss;\\\",\\r\\n            \\\"\\\\t\\\\tss << fixed << setprecision(9);\\\",\\r\\n            \\\"\\\\t\\\\tss << name << \\\\\\\": \\\\\\\" << (long double) (newtim - tim) / 1e9;\\\",\\r\\n            \\\"\\\\t\\\\ttim = newtim;\\\",\\r\\n            \\\"\\\\t\\\\tstring ans;\\\",\\r\\n            \\\"\\\\t\\\\tgetline(ss, ans);\\\",\\r\\n            \\\"\\\\t\\\\treturn ans;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"BENCHMARK\\\"\\r\\n    },\\r\\n    \\\"Z_FUNCTION\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"Z_FUNCTION\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"template <typename T> vector <int> z_function(int n, const T &s) {\\\",\\r\\n            \\\"\\\\tif (!n) return {};\\\",\\r\\n            \\\"\\\\tvector <int> z(n);\\\",\\r\\n            \\\"\\\\tz[0] = 0;\\\",\\r\\n            \\\"\\\\tfor (int i = 1, j = 0; i < n; i++) {\\\",\\r\\n            \\\"\\\\t\\\\tint &k = z[i];\\\",\\r\\n            \\\"\\\\t\\\\tk = j + z[j] <= i ? 0 : min(j + z[j] - i, z[i - j]);\\\",\\r\\n            \\\"\\\\t\\\\twhile (i + k < n && s[k] == s[i + k]) k++;\\\",\\r\\n            \\\"\\\\t\\\\tif (j + z[j] < i + z[i]) j = i;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tz[0] = n;\\\",\\r\\n            \\\"\\\\treturn z;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename T> vector <int> z_function(const T &s) { return z_function(s.size(), s); }\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"Z_FUNCTION\\\"\\r\\n    },\\r\\n    \\\"WAVELET_TREE\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"WAVELET_TREE\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"struct WaveletTree {\\\",\\r\\n            \\\"\\\\tint lo, hi, mid;\\\",\\r\\n            \\\"\\\\tvector <int> b;\\\",\\r\\n            \\\"\\\\tWaveletTree *left, *right;\\\",\\r\\n            \\\"\\\\ttemplate <class RandomIt> WaveletTree(RandomIt first, RandomIt last) {\\\",\\r\\n            \\\"\\\\t\\\\tif (first == last) return;\\\",\\r\\n            \\\"\\\\t\\\\tauto x = minmax_element(first, last);\\\",\\r\\n            \\\"\\\\t\\\\tlo = *x.fi; hi = *x.se;\\\",\\r\\n            \\\"\\\\t\\\\tif (lo == hi) return;\\\",\\r\\n            \\\"\\\\t\\\\tmid = lo + hi >> 1;\\\",\\r\\n            \\\"\\\\t\\\\tauto f = [&] (int x) { return x <= mid; };\\\",\\r\\n            \\\"\\\\t\\\\tb.reserve(last - first + 1);\\\",\\r\\n            \\\"\\\\t\\\\tb.push_back(0);\\\",\\r\\n            \\\"\\\\t\\\\tfor (auto it = first; it != last; ++it) b.push_back(b.back() + f(*it));\\\",\\r\\n            \\\"\\\\t\\\\tauto mid = stable_partition(first, last, f);\\\",\\r\\n            \\\"\\\\t\\\\tleft = new WaveletTree(first, mid);\\\",\\r\\n            \\\"\\\\t\\\\tright = new WaveletTree(mid, last);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\t// kth smallest element in [l, r)\\\",\\r\\n            \\\"\\\\tint kth_smallest(int l, int r, int k) {\\\",\\r\\n            \\\"\\\\t\\\\tif (l > r) return 0;\\\",\\r\\n            \\\"\\\\t\\\\tif (lo == hi) return lo;\\\",\\r\\n            \\\"\\\\t\\\\tint inLeft = b[r] - b[l];\\\",\\r\\n            \\\"\\\\t\\\\tif (k <= inLeft) return left->kth_smallest(b[l], b[r], k);\\\",\\r\\n            \\\"\\\\t\\\\treturn right->kth_smallest(l - b[l], r - b[r], k - inLeft);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\t// kth largest element in [l, r)\\\",\\r\\n            \\\"\\\\tint kth_largest(int l, int r, int k) {\\\",\\r\\n            \\\"\\\\t\\\\tif (l > r) return 0;\\\",\\r\\n            \\\"\\\\t\\\\tif (lo == hi) return lo;\\\",\\r\\n            \\\"\\\\t\\\\tint inRight = r - l - b[r] + b[l];\\\",\\r\\n            \\\"\\\\t\\\\tif (k <= inRight) return right->kth_largest(l - b[l], r - b[r], k);\\\",\\r\\n            \\\"\\\\t\\\\treturn left->kth_largest(b[l], b[r], k - inRight);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\t// count of nos in [l, r) Less than or equal to k\\\",\\r\\n            \\\"\\\\tint LTE(int l, int r, int k) {\\\",\\r\\n            \\\"\\\\t\\\\tif (l > r || k < lo) return 0;\\\",\\r\\n            \\\"\\\\t\\\\tif (hi <= k) return r - l;\\\",\\r\\n            \\\"\\\\t\\\\treturn left->LTE(b[l], b[r], k) + right->LTE(l - b[l], r - b[r], k);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\t// count of nos in [l, r) equal to k\\\",\\r\\n            \\\"\\\\tint count(int l, int r, int k) {\\\",\\r\\n            \\\"\\\\t\\\\tif (l > r || k < lo || k > hi) return 0;\\\",\\r\\n            \\\"\\\\t\\\\tif (lo == hi) return r - l;\\\",\\r\\n            \\\"\\\\t\\\\tif (k <= mid) return left->count(b[l], b[r], k);\\\",\\r\\n            \\\"\\\\t\\\\treturn right->count(l - b[l], r - b[r], k);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"WAVELET_TREE\\\"\\r\\n    },\\r\\n    \\\"TWO_SAT\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"TWO_SAT\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"class TwoSat {\\\",\\r\\n            \\\"private: \\\",\\r\\n            \\\"\\\\tint n;\\\",\\r\\n            \\\"\\\\tvector <int> order, used, comp;\\\",\\r\\n            \\\"\\\\tvector <bool> _answer;\\\",\\r\\n            \\\"\\\\tvector <vector <int>> adj, r_adj;\\\",\\r\\n            \\\"\\\\tvoid addEdge(int u, int v) {\\\",\\r\\n            \\\"\\\\t\\\\tadj[u].push_back(v);\\\",\\r\\n            \\\"\\\\t\\\\tr_adj[v].push_back(u);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid dfs1(int u) {\\\",\\r\\n            \\\"\\\\t\\\\tused[u] = true;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int v: adj[u]) if (!used[v]) dfs1(v);\\\",\\r\\n            \\\"\\\\t\\\\torder.push_back(u);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid dfs2(int u, int cl) {\\\",\\r\\n            \\\"\\\\t\\\\tcomp[u] = cl;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int v: r_adj[u]) if (!~comp[v]) dfs2(v, cl);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"public:\\\",\\r\\n            \\\"\\\\tTwoSat(int _n = 0) {\\\",\\r\\n            \\\"\\\\t\\\\tn = _n;\\\",\\r\\n            \\\"\\\\t\\\\tadj.assign(n << 1, vector<int>());\\\",\\r\\n            \\\"\\\\t\\\\tr_adj.assign(n << 1, vector<int>());\\\",\\r\\n            \\\"\\\\t\\\\tused.resize(n << 1);\\\",\\r\\n            \\\"\\\\t\\\\tcomp.resize(n << 1);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid addChoiceCondition(int var1, int type1, int var2, int type2) { \\\",\\r\\n            \\\"\\\\t\\\\t// condition type: A or B\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= var1 && var1 < n);\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= type1 && type1 < 2);\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= var2 && var2 < n);\\\",\\r\\n            \\\"\\\\t\\\\tassert(0 <= type2 && type2 < 2);\\\",\\r\\n            \\\"\\\\t\\\\tvar1 = var1 << 1 | type1;\\\",\\r\\n            \\\"\\\\t\\\\tvar2 = var2 << 1 | type2;\\\",\\r\\n            \\\"\\\\t\\\\taddEdge(var1 ^ 1, var2);\\\",\\r\\n            \\\"\\\\t\\\\taddEdge(var2 ^ 1, var1);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid addMustFalseCondition(int var) {\\\",\\r\\n            \\\"\\\\t\\\\t// Condition type: A = false\\\",\\r\\n            \\\"\\\\t\\\\taddChoiceCondition(var, false, var, false);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid addMustTrueCondition(int var) {\\\",\\r\\n            \\\"\\\\t\\\\t// Condition type: A = true\\\",\\r\\n            \\\"\\\\t\\\\taddChoiceCondition(var, true, var, true);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid addInferCondition(int var1, int type1, int var2, int type2) {\\\",\\r\\n            \\\"\\\\t\\\\t// Condition type: A -> B\\\",\\r\\n            \\\"\\\\t\\\\taddChoiceCondition(var1, !type1, var2, type2);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tbool satisfiable(void) {\\\",\\r\\n            \\\"\\\\t\\\\torder.clear();\\\",\\r\\n            \\\"\\\\t\\\\tfill(used.begin(), used.end(), false);\\\",\\r\\n            \\\"\\\\t\\\\tfill(comp.begin(), comp.end(), -1);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n << 1; ++i) if (!used[i]) dfs1(i);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = n << 1, j = 0; i--; ) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint u = order[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (!~comp[u]) dfs2(u, j++);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t_answer.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n << 1; i += 2) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (comp[i] == comp[i + 1]) return false;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t_answer[i >> 1] = comp[i] < comp[i + 1];\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn true;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvector <bool> answer() { return _answer; }\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"TWO_SAT\\\"\\r\\n    },\\r\\n    \\\"SUFFIX_ARRAY\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"SUFFIX_ARRAY\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"namespace SUFFIX_ARRAY {\\\",\\r\\n            \\\"vector<int> sa_naive(const vector<int>& s) {\\\",\\r\\n            \\\"\\\\tint n = s.size();\\\",\\r\\n            \\\"\\\\tvector <int> sa(n);\\\",\\r\\n            \\\"\\\\tiota(sa.begin(), sa.end(), 0);\\\",\\r\\n            \\\"\\\\tsort(sa.begin(), sa.end(), [&](int l, int r) {\\\",\\r\\n            \\\"\\\\t\\\\tif (l == r) return false;\\\",\\r\\n            \\\"\\\\t\\\\twhile (l < n && r < n) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (s[l] != s[r]) return s[l] < s[r];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tl++; r++;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn l == n;\\\",\\r\\n            \\\"\\\\t});\\\",\\r\\n            \\\"\\\\treturn sa;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"vector <int> sa_doubling(const vector <int>& s) {\\\",\\r\\n            \\\"\\\\tint n = s.size();\\\",\\r\\n            \\\"\\\\tvector <int> sa(n), rnk = s, tmp(n);\\\",\\r\\n            \\\"\\\\tiota(sa.begin(), sa.end(), 0);\\\",\\r\\n            \\\"\\\\tfor (int k = 1; k < n; k <<= 1) {\\\",\\r\\n            \\\"\\\\t\\\\tauto cmp = [&](int x, int y) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint rx = x + k < n ? rnk[x + k] : -1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint ry = y + k < n ? rnk[y + k] : -1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\treturn rx < ry;\\\",\\r\\n            \\\"\\\\t\\\\t};\\\",\\r\\n            \\\"\\\\t\\\\tsort(sa.begin(), sa.end(), cmp);\\\",\\r\\n            \\\"\\\\t\\\\ttmp[sa[0]] = 0;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 1; i < n; ++i) tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\\\",\\r\\n            \\\"\\\\t\\\\tswap(tmp, rnk);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn sa;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40> \\\",\\r\\n            \\\"vector <int> sa_is(const vector <int> &s, int upper) {\\\",\\r\\n            \\\"\\\\tint n = int(s.size());\\\",\\r\\n            \\\"\\\\tif (n == 0) return {};\\\",\\r\\n            \\\"\\\\tif (n == 1) return {0};\\\",\\r\\n            \\\"\\\\tif (n == 2) {\\\",\\r\\n            \\\"\\\\t\\\\tif (s[0] < s[1]) return {0, 1};\\\",\\r\\n            \\\"\\\\t\\\\treturn {1, 0};\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tif (n < THRESHOLD_NAIVE) return sa_naive(s);\\\",\\r\\n            \\\"\\\\tif (n < THRESHOLD_DOUBLING) return sa_doubling(s);\\\",\\r\\n            \\\"\\\\tvector <int> sa(n);\\\",\\r\\n            \\\"\\\\tvector <bool> ls(n);\\\",\\r\\n            \\\"\\\\tfor (int i = n - 2; i >= 0; --i) ls[i] = s[i] == s[i + 1] ? ls[i + 1] : s[i] < s[i + 1];\\\",\\r\\n            \\\"\\\\tvector <int> sum_l(upper + 1), sum_s(upper + 1);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < n; ++i) (ls[i] ? sum_l[s[i] + 1] : sum_s[s[i]])++;\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i <= upper; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tsum_s[i] += sum_l[i];\\\",\\r\\n            \\\"\\\\t\\\\tif (i < upper) sum_l[i + 1] += sum_s[i];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tauto induce = [&](const vector <int>& lms) {\\\",\\r\\n            \\\"\\\\t\\\\tfill(sa.begin(), sa.end(), -1);\\\",\\r\\n            \\\"\\\\t\\\\tvector <int> buf(upper + 1);\\\",\\r\\n            \\\"\\\\t\\\\tcopy(sum_s.begin(), sum_s.end(), buf.begin());\\\",\\r\\n            \\\"\\\\t\\\\tfor (auto d: lms) if (d != n) sa[buf[s[d]]++] = d;\\\",\\r\\n            \\\"\\\\t\\\\tcopy(sum_l.begin(), sum_l.end(), buf.begin());\\\",\\r\\n            \\\"\\\\t\\\\tsa[buf[s[n - 1]]++] = n - 1;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint v = sa[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (v >= 1 && !ls[v - 1]) sa[buf[s[v - 1]]++] = v - 1;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tcopy(sum_l.begin(), sum_l.end(), buf.begin());\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = n - 1; i >= 0; --i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint v = sa[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (v >= 1 && ls[v - 1]) sa[--buf[s[v - 1] + 1]] = v - 1;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tvector <int> lms_map(n + 1, -1);\\\",\\r\\n            \\\"\\\\tint m = 0;\\\",\\r\\n            \\\"\\\\tfor (int i = 1; i < n; ++i) if (!ls[i - 1] && ls[i]) lms_map[i] = m++;\\\",\\r\\n            \\\"\\\\tvector <int> lms;\\\",\\r\\n            \\\"\\\\tlms.reserve(m);\\\",\\r\\n            \\\"\\\\tfor (int i = 1; i < n; ++i) if (!ls[i - 1] && ls[i]) lms.push_back(i);\\\",\\r\\n            \\\"\\\\tinduce(lms);\\\",\\r\\n            \\\"\\\\tif (m) {\\\",\\r\\n            \\\"\\\\t\\\\tvector <int> sorted_lms;\\\",\\r\\n            \\\"\\\\t\\\\tsorted_lms.reserve(m);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int v: sa) if (lms_map[v] != -1) sorted_lms.push_back(v);\\\",\\r\\n            \\\"\\\\t\\\\tvector <int> rec_s(m);\\\",\\r\\n            \\\"\\\\t\\\\tint rec_upper = 0;\\\",\\r\\n            \\\"\\\\t\\\\trec_s[lms_map[sorted_lms[0]]] = 0;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 1; i < m; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint l = sorted_lms[i - 1], r = sorted_lms[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tbool same = true;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (end_l - l != end_r - r) same = false;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\telse {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\twhile (l < end_l) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (s[l] != s[r]) break;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tl++; r++;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (l == n || s[l] != s[r]) same = false;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (!same) rec_upper++;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\trec_s[lms_map[sorted_lms[i]]] = rec_upper;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tauto rec_sa = sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < m; ++i) sorted_lms[i] = lms[rec_sa[i]];\\\",\\r\\n            \\\"\\\\t\\\\tinduce(sorted_lms);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn sa;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"vector <int> suffix_array(const vector <int> &s, int upper) {\\\",\\r\\n            \\\"\\\\tassert(0 <= upper);\\\",\\r\\n            \\\"\\\\tfor (int d: s) assert(0 <= d && d <= upper);\\\",\\r\\n            \\\"\\\\tauto sa = sa_is(s, upper);\\\",\\r\\n            \\\"\\\\treturn sa;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <class T> vector <int> suffix_array(const vector <T> &s) {\\\",\\r\\n            \\\"\\\\tint n = s.size();\\\",\\r\\n            \\\"\\\\tvector <int> idx(n);\\\",\\r\\n            \\\"\\\\tiota(idx.begin(), idx.end(), 0);\\\",\\r\\n            \\\"\\\\tsort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\\\",\\r\\n            \\\"\\\\tvector <int> s2(n);\\\",\\r\\n            \\\"\\\\tint now = 0;\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < n; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tif (i && s[idx[i - 1]] != s[idx[i]]) now++;\\\",\\r\\n            \\\"\\\\t\\\\ts2[idx[i]] = now;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn sa_is(s2, now);\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"vector <int> suffix_array(const string& s) {\\\",\\r\\n            \\\"\\\\tint n = s.size();\\\",\\r\\n            \\\"\\\\tvector <int> s2(n);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < n; ++i) s2[i] = s[i];\\\",\\r\\n            \\\"\\\\treturn sa_is(s2, 255);\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <class T> vector <int> lcp_array(const vector <T> &s, const vector <int> &sa) {\\\",\\r\\n            \\\"\\\\tint n = s.size();\\\",\\r\\n            \\\"\\\\tassert(n > 0);\\\",\\r\\n            \\\"\\\\tvector <int> rnk(n);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < n; ++i) rnk[sa[i]] = i;\\\",\\r\\n            \\\"\\\\tvector <int> lcp(n - 1);\\\",\\r\\n            \\\"\\\\tint h = 0;\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < n; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\tif (h > 0) h--;\\\",\\r\\n            \\\"\\\\t\\\\tif (!rnk[i]) continue;\\\",\\r\\n            \\\"\\\\t\\\\tint j = sa[rnk[i] - 1];\\\",\\r\\n            \\\"\\\\t\\\\tfor (; j + h < n && i + h < n; h++) if (s[j + h] != s[i + h]) break;\\\",\\r\\n            \\\"\\\\t\\\\tlcp[rnk[i] - 1] = h;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn lcp;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"vector <int> lcp_array(const string &s, const vector <int> &sa) {\\\",\\r\\n            \\\"\\\\tint n = s.size();\\\",\\r\\n            \\\"\\\\tvector <int> s2(n);\\\",\\r\\n            \\\"\\\\tfor (int i = 0; i < n; i++) s2[i] = s[i];\\\",\\r\\n            \\\"\\\\treturn lcp_array(s2, sa);\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"} using namespace SUFFIX_ARRAY;\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"SUFFIX_ARRAY\\\"\\r\\n    },\\r\\n    \\\"SUBSET_CONVOLUTION\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"SUBSET_CONVOLUTION\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"namespace SUBSET_CONVOLUTION {\\\",\\r\\n            \\\"\\\\ttemplate <class T> void zeta_transform(vector <T> &a, bool rev = false) {\\\",\\r\\n            \\\"\\\\t\\\\tint n = 0; while ((1 << n) < (int) a.size()) ++n;\\\",\\r\\n            \\\"\\\\t\\\\ta.resize(1 << n);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int mask = 0; mask < 1 << n; ++mask)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif ((mask >> i & 1) ^ rev) a[mask] += a[mask ^ (1 << i)];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\ttemplate <class T> void mobius_transform(vector <T> &a, bool rev = false) {\\\",\\r\\n            \\\"\\\\t\\\\tint n = 0; while ((1 << n) < (int) a.size()) ++n;\\\",\\r\\n            \\\"\\\\t\\\\ta.resize(1 << n);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int mask = 0; mask < 1 << n; ++mask)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif ((mask >> i & 1) ^ rev) a[mask] -= a[mask ^ (1 << i)];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\ttemplate <class T> vector <T> subset_sum_convolution(const vector <T> &f, const vector <T> &g) {\\\",\\r\\n            \\\"\\\\t\\\\tint n = 0; while ((1 << n) < (int) max(f.size(), g.size())) ++n;\\\",\\r\\n            \\\"\\\\t\\\\tvector <vector <T>> fhat(n + 1, vector<T>(1 << n)), ghat(n + 1, vector<T>(1 << n));\\\",\\r\\n            \\\"\\\\t\\\\tfor (int mask = 0; mask < 1 << n; ++mask) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint i = __builtin_popcount(mask);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (mask < (int) f.size()) fhat[i][mask] = f[mask];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (mask < (int) g.size()) ghat[i][mask] = g[mask];\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tzeta_transform(fhat[i]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tzeta_transform(ghat[i]);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tvector <T> res(1 << n), h(1 << n);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i <= n; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int j = 0; j <= i; ++j)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfor (int mask = 0; mask < 1 << n; ++mask)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\th[mask] += fhat[j][mask] * ghat[i - j][mask];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tmobius_transform(h);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int mask = 0; mask < 1 << n; ++mask)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (__builtin_popcount(mask) == i) res[mask] = h[mask];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfill(h.begin(), h.end(), T{});\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\ttemplate <class T> void fft(vector <T> &a, bool rev = false) {\\\",\\r\\n            \\\"\\\\t\\\\tint n = a.size();\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 1; i < n; i <<= 1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int mask = 0; mask < n; ++mask) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (!(mask & i)) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tT u = a[mask], v = a[mask ^ i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\ta[mask] = u + v;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\ta[mask ^ i] = u - v;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tif (rev) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tT inv = T(1) / n;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int mask = 0; mask < n; ++mask) a[mask] *= inv;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\ttemplate <class T> vector <T> or_convolution(vector <T> f, vector <T> g) {\\\",\\r\\n            \\\"\\\\t\\\\tint n = 1;\\\",\\r\\n            \\\"\\\\t\\\\twhile (n < (int) max(f.size(), g.size())) n <<= 1;\\\",\\r\\n            \\\"\\\\t\\\\tf.resize(n); g.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\tzeta_transform(f);\\\",\\r\\n            \\\"\\\\t\\\\tzeta_transform(g);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) f[i] *= g[i];\\\",\\r\\n            \\\"\\\\t\\\\tmobius_transform(f);\\\",\\r\\n            \\\"\\\\t\\\\treturn f;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\ttemplate <class T> vector <T> and_convolution(vector <T> f, vector <T> g) {\\\",\\r\\n            \\\"\\\\t\\\\tint n = 1;\\\",\\r\\n            \\\"\\\\t\\\\twhile (n < (int) max(f.size(), g.size())) n <<= 1;\\\",\\r\\n            \\\"\\\\t\\\\tf.resize(n); g.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\tzeta_transform(f, true);\\\",\\r\\n            \\\"\\\\t\\\\tzeta_transform(g, true);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) f[i] *= g[i];\\\",\\r\\n            \\\"\\\\t\\\\tmobius_transform(f, true);\\\",\\r\\n            \\\"\\\\t\\\\treturn f;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\ttemplate <class T> vector <T> xor_convolution(vector <T> f, vector <T> g) {\\\",\\r\\n            \\\"\\\\t\\\\tint n = 1;\\\",\\r\\n            \\\"\\\\t\\\\twhile (n < (int) max(f.size(), g.size())) n <<= 1;\\\",\\r\\n            \\\"\\\\t\\\\tf.resize(n); g.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\tfft(f); fft(g);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) f[i] *= g[i];\\\",\\r\\n            \\\"\\\\t\\\\tfft(f, true);\\\",\\r\\n            \\\"\\\\t\\\\treturn f;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"} using namespace SUBSET_CONVOLUTION;\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"SUBSET_CONVOLUTION\\\"\\r\\n    },\\r\\n    \\\"STRONGLY_CONNECTED_COMPONENT\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"STRONGLY_CONNECTED_COMPONENT\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"template <class E> struct csr {\\\",\\r\\n            \\\"\\\\tvector <int> st;\\\",\\r\\n            \\\"\\\\tvector <E> lst;\\\",\\r\\n            \\\"\\\\texplicit csr(int n, const vector <pair <int, E>> &edges): st(n + 1), lst(edges.size()) {\\\",\\r\\n            \\\"\\\\t\\\\tfor (auto e: edges) st[e.first + 1]++;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 1; i <= n; i++) st[i] += st[i - 1];\\\",\\r\\n            \\\"\\\\t\\\\tauto cnt = st;\\\",\\r\\n            \\\"\\\\t\\\\tfor (auto e: edges) lst[cnt[e.first]++] = e.second;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"struct StronglyConnectedComponent {\\\",\\r\\n            \\\"\\\\tint n;\\\",\\r\\n            \\\"\\\\tvector <pair <int, int>> edges;\\\",\\r\\n            \\\"\\\\tvector <int> low, num;\\\",\\r\\n            \\\"\\\\tStronglyConnectedComponent(int _n) : n(_n) {}\\\",\\r\\n            \\\"\\\\tvoid add(int from, int to) { edges.emplace_back(from, to); }\\\",\\r\\n            \\\"\\\\tpair <int, vector <int>> scc_ids() {\\\",\\r\\n            \\\"\\\\t\\\\tauto g = csr<int>(n, edges);\\\",\\r\\n            \\\"\\\\t\\\\tint t = 0, group_num = 0;\\\",\\r\\n            \\\"\\\\t\\\\tlow.resize(n);\\\",\\r\\n            \\\"\\\\t\\\\tnum.assign(n, -1);\\\",\\r\\n            \\\"\\\\t\\\\tvector <int> visited, ids(n);\\\",\\r\\n            \\\"\\\\t\\\\tvisited.reserve(n);\\\",\\r\\n            \\\"\\\\t\\\\tauto dfs = [&] (auto self, int u) -> void {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tlow[u] = num[u] = t++;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tvisited.push_back(u);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int i = g.st[u]; i < g.st[u + 1]; i++) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint v = g.lst[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (num[v] == -1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tself(self, v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tlow[u] = min(low[u], low[v]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t} else low[u] = min(low[u], num[v]);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (low[u] == num[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint v;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tdo {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tv = visited.back(); visited.pop_back();\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tnum[v] = n;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tids[v] = group_num;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t} while (v != u);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tgroup_num++;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t};\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; i++) if (num[i] == -1) dfs(dfs, i);\\\",\\r\\n            \\\"\\\\t\\\\tfor (auto &x: ids) x = group_num - 1 - x;\\\",\\r\\n            \\\"\\\\t\\\\treturn {group_num, ids};\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvector <vector <int>> scc() {\\\",\\r\\n            \\\"\\\\t\\\\tauto [group_num, ids] = scc_ids();\\\",\\r\\n            \\\"\\\\t\\\\tvector<int> cnt(group_num);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int x: ids) cnt[x]++;\\\",\\r\\n            \\\"\\\\t\\\\tvector<vector<int>> groups(group_num);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < group_num; i++) groups[i].reserve(cnt[i]);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; i++) groups[ids[i]].push_back(i);\\\",\\r\\n            \\\"\\\\t\\\\treturn groups;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"STRONGLY_CONNECTED_COMPONENT\\\"\\r\\n    },\\r\\n    \\\"MANACHER\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"MANACHER\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"template <typename T> vector <int> manacher(int n, const T &s) {\\\",\\r\\n            \\\"\\\\tif (!n) return vector<int>();\\\",\\r\\n            \\\"\\\\tvector <int> res(2 * n - 1);\\\",\\r\\n            \\\"\\\\tint l = -1, r = -1;\\\",\\r\\n            \\\"\\\\tfor (int z = 0; z < 2 * n - 1; z++) {\\\",\\r\\n            \\\"\\\\t\\\\tint i = (z + 1) >> 1;\\\",\\r\\n            \\\"\\\\t\\\\tint j = z >> 1;\\\",\\r\\n            \\\"\\\\t\\\\tint p = (i >= r ? 0 : min(r - i, res[2 * (l + r) - z]));\\\",\\r\\n            \\\"\\\\t\\\\twhile (j + p + 1 < n && i - p - 1 >= 0 && s[j + p + 1] == s[i - p - 1]) ++p;\\\",\\r\\n            \\\"\\\\t\\\\tif (j + p > r) l = i - p, r = j + p;\\\",\\r\\n            \\\"\\\\t\\\\tres[z] = p;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn res;\\\",\\r\\n            \\\"\\\\t// res[2 * i] = odd radius in position i\\\",\\r\\n            \\\"\\\\t// res[2 * i + 1] = even radius between positions i and i + 1\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"template <typename T> vector<int> manacher(const T &s) { return manacher(s.size(), s); }\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"MANACHER\\\"\\r\\n    },\\r\\n    \\\"MAX_FLOW\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"MAX_FLOW\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"namespace MAX_FLOW {\\\",\\r\\n            \\\"template <class T> struct Edge {\\\",\\r\\n            \\\"\\\\tint from, to;\\\",\\r\\n            \\\"\\\\tT cap, flow;\\\",\\r\\n            \\\"\\\\tint nxt;\\\",\\r\\n            \\\"\\\\tEdge(int from = 0, int to = 0, T cap = 0, int nxt = -1): from(from), to(to), cap(cap), flow(0), nxt(nxt) {}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <class T> struct PushRelabel {\\\",\\r\\n            \\\"\\\\tint n, max_level;\\\",\\r\\n            \\\"\\\\tvector <Edge <T>> edges;\\\",\\r\\n            \\\"\\\\tvector <vector <int>> lst;\\\",\\r\\n            \\\"\\\\tvector <int> head, level, cnt;\\\",\\r\\n            \\\"\\\\tvector <T> excess;\\\",\\r\\n            \\\"\\\\tvector <bool> active;\\\",\\r\\n            \\\"\\\\tPushRelabel(int n = 0): n(n), lst(n), head(n, -1), level(n), cnt(n + 1), excess(n), active(n) {}\\\",\\r\\n            \\\"\\\\tint add(int from, int to, T cap, bool bi = false) {\\\",\\r\\n            \\\"\\\\t\\\\tint id = edges.size();\\\",\\r\\n            \\\"\\\\t\\\\tedges.emplace_back(from, to, cap, head[from]);\\\",\\r\\n            \\\"\\\\t\\\\thead[from] = id;\\\",\\r\\n            \\\"\\\\t\\\\tedges.emplace_back(to, from, bi ? cap : 0, head[to]);\\\",\\r\\n            \\\"\\\\t\\\\thead[to] = id + 1;\\\",\\r\\n            \\\"\\\\t\\\\treturn id;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid enqueue(int u) {\\\",\\r\\n            \\\"\\\\t\\\\tif (!active[u] && excess[u] && level[u] < n) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tactive[u] = true;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tlst[level[u]].push_back(u);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tmax_level = max(max_level, level[u]);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tT max_flow(int s, int t) {\\\",\\r\\n            \\\"\\\\t\\\\tfor (Edge <T> &e: edges) e.flow = 0;\\\",\\r\\n            \\\"\\\\t\\\\tmax_level = 0;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) lst[i].clear();\\\",\\r\\n            \\\"\\\\t\\\\tfill(level.begin(), level.end(), 0);\\\",\\r\\n            \\\"\\\\t\\\\tfill(excess.begin(), excess.end(), 0);\\\",\\r\\n            \\\"\\\\t\\\\tfill(cnt.begin(), cnt.end(), 0);\\\",\\r\\n            \\\"\\\\t\\\\tfill(active.begin(), active.end(), false);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = head[s]; i != -1; i = edges[i].nxt) excess[s] += edges[i].cap;\\\",\\r\\n            \\\"\\\\t\\\\tcnt[0] = n;\\\",\\r\\n            \\\"\\\\t\\\\tenqueue(s);\\\",\\r\\n            \\\"\\\\t\\\\tactive[t] = true;\\\",\\r\\n            \\\"\\\\t\\\\twhile (max_level >= 0) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (!lst[max_level].empty()) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint u = lst[max_level].back();\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tlst[max_level].pop_back();\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tactive[u] = false;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfor (int i = head[u]; i != -1 && excess[u]; i = edges[i].nxt) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tT d = min(excess[u], edges[i].cap - edges[i].flow);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (d && level[u] == level[edges[i].to] + 1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tedges[i].flow += d; edges[i ^ 1].flow -= d;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\texcess[edges[i].to] += d; excess[u] -= d;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tenqueue(edges[i].to);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (excess[u]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (cnt[level[u]] == 1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tint k = level[u];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (int u = 0; u < n; ++u) if (level[u] >= k) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t--cnt[level[u]];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlevel[u] = n;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t++cnt[level[u]];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tenqueue(u);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t--cnt[level[u]];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlevel[u] = n;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (int i = head[u]; i != -1; i = edges[i].nxt)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (edges[i].cap != edges[i].flow) level[u] = min(level[u], level[edges[i].to] + 1);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t++cnt[level[u]];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tenqueue(u);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t} else max_level--;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn excess[t];\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <class T> struct Dinic {\\\",\\r\\n            \\\"\\\\tstatic constexpr T inf = numeric_limits<T>::max();\\\",\\r\\n            \\\"\\\\tint n, ss, tt;\\\",\\r\\n            \\\"\\\\tvector <Edge <T>> edges;\\\",\\r\\n            \\\"\\\\tvector <int> head, level, ptr, q;\\\",\\r\\n            \\\"\\\\tDinic(int n = 0): n(n), head(n, -1), level(n), ptr(n), q(n) {}\\\",\\r\\n            \\\"\\\\tint add(int from, int to, T cap, bool bi = false) {\\\",\\r\\n            \\\"\\\\t\\\\tint id = edges.size();\\\",\\r\\n            \\\"\\\\t\\\\tedges.emplace_back(from, to, cap, head[from]);\\\",\\r\\n            \\\"\\\\t\\\\thead[from] = id;\\\",\\r\\n            \\\"\\\\t\\\\tedges.emplace_back(to, from, bi ? cap : 0, head[to]);\\\",\\r\\n            \\\"\\\\t\\\\thead[to] = id + 1;\\\",\\r\\n            \\\"\\\\t\\\\treturn id;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tbool bfs(void) {\\\",\\r\\n            \\\"\\\\t\\\\tfill(level.begin(), level.end(), n + 1);\\\",\\r\\n            \\\"\\\\t\\\\tq[0] = ss; level[ss] = 0;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int l = 0, r = 1; l < r; ) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint u = q[l++];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int i = head[u]; i != -1; i = edges[i].nxt) if (edges[i].cap != edges[i].flow) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint v = edges[i].to;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (level[v] == n + 1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tlevel[v] = level[u] + 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (v == tt) return true;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tq[r++] = v;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn false;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tT dfs(int u, T pushed) {\\\",\\r\\n            \\\"\\\\t\\\\tif (u == ss) return pushed;\\\",\\r\\n            \\\"\\\\t\\\\tT flow = 0;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int &j = ptr[u]; j != -1; j = edges[j].nxt) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint i = j ^ 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (edges[i].cap - edges[i].flow == 0 || level[edges[i].from] >= level[u]) continue;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tT tr = dfs(edges[i].from, min(pushed - flow, edges[i].cap - edges[i].flow));\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (!tr) continue;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tedges[i].flow += tr;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tedges[j].flow -= tr;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tflow += tr;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (flow == pushed) return flow;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tlevel[u] = n;\\\",\\r\\n            \\\"\\\\t\\\\treturn flow;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tT max_flow(int s, int t) {\\\",\\r\\n            \\\"\\\\t\\\\tss = s; tt = t;\\\",\\r\\n            \\\"\\\\t\\\\tfor (Edge <T> &e: edges) e.flow = 0;\\\",\\r\\n            \\\"\\\\t\\\\tT flow = 0;\\\",\\r\\n            \\\"\\\\t\\\\tq[0] = ss;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int L = 30; L >= 0; --L) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\twhile (true) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfill(level.begin(), level.end(), 0);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint l = 0, r = level[s] = 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\twhile (l < r && !level[t]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tint u = q[l++];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tfor (int i = head[u]; i != -1; i = edges[i].nxt) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!level[edges[i].to] && (edges[i].cap - edges[i].flow) >> L) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tq[r++] = edges[i].to;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlevel[edges[i].to] = level[u] + 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (!level[t]) break;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tcopy(head.begin(), head.end(), ptr.begin());\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tflow += dfs(t, inf);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn flow;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <class Cap, class Cost> struct CEdge {\\\",\\r\\n            \\\"\\\\tint from, to;\\\",\\r\\n            \\\"\\\\tCap cap, flow;\\\",\\r\\n            \\\"\\\\tCost cost;\\\",\\r\\n            \\\"\\\\tint nxt;\\\",\\r\\n            \\\"\\\\tCEdge(int from = 0, int to = 0, Cap cap = 0, Cost cost = 0, int nxt = 0): from(from), to(to), cap(cap), flow(0), cost(cost), nxt(nxt) {}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <typename Cap, typename Cost> struct MinCostFlow {\\\",\\r\\n            \\\"\\\\tstatic constexpr Cap inf_cap = numeric_limits<Cap>::max();\\\",\\r\\n            \\\"\\\\tstatic constexpr Cost inf_cost = numeric_limits<Cost>::max() >> 1;\\\",\\r\\n            \\\"\\\\tint n;\\\",\\r\\n            \\\"\\\\tvector <CEdge <Cap, Cost>> edges;\\\",\\r\\n            \\\"\\\\tvector <Cost> d, pot;\\\",\\r\\n            \\\"\\\\tpriority_queue <pair <Cost, int>> q;\\\",\\r\\n            \\\"\\\\tvector <int> trace, head;\\\",\\r\\n            \\\"\\\\tMinCostFlow(int n_ = 0) : n(n_), d(n), pot(n, 0), trace(n), head(n, -1) {}\\\",\\r\\n            \\\"\\\\tint add(int from, int to, Cap cap, Cost cost) {\\\",\\r\\n            \\\"\\\\t\\\\tint id = edges.size();\\\",\\r\\n            \\\"\\\\t\\\\tedges.emplace_back(from, to, cap, cost, head[from]);\\\",\\r\\n            \\\"\\\\t\\\\thead[from] = id;\\\",\\r\\n            \\\"\\\\t\\\\tedges.emplace_back(to, from, 0, -cost, head[to]);\\\",\\r\\n            \\\"\\\\t\\\\thead[to] = id + 1;\\\",\\r\\n            \\\"\\\\t\\\\treturn id;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tvoid expath(int st) {\\\",\\r\\n            \\\"\\\\t\\\\tfill(d.begin(), d.end(), inf_cost);\\\",\\r\\n            \\\"\\\\t\\\\twhile (!q.empty()) q.pop();\\\",\\r\\n            \\\"\\\\t\\\\td[st] = 0;\\\",\\r\\n            \\\"\\\\t\\\\tq.push({pot[st], st});\\\",\\r\\n            \\\"\\\\t\\\\twhile (!q.empty()) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tauto [du, u] = q.top(); q.pop();\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (du != pot[u] - d[u]) continue;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int i = head[u]; i != -1; i = edges[i].nxt) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint v = edges[i].to;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (edges[i].cap != edges[i].flow && d[u] + edges[i].cost < d[v]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\td[v] = d[u] + edges[i].cost;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\ttrace[v] = i;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tq.push({pot[v] - d[v], v});\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tswap(d, pot);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tpair <Cap, Cost> max_flow(int s, int t) {\\\",\\r\\n            \\\"\\\\t\\\\tCap flow = 0;\\\",\\r\\n            \\\"\\\\t\\\\tCost cost = 0;\\\",\\r\\n            \\\"\\\\t\\\\tbool ok = true;\\\",\\r\\n            \\\"\\\\t\\\\tfor (auto &e: edges) if (e.cap != e.flow && e.cost + pot[e.from] - pot[e.to] < 0) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tok = false;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tbreak;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tif (ok) expath(s);\\\",\\r\\n            \\\"\\\\t\\\\telse {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tvector <int> deg(n, 0);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int u = 0; u < n; ++u)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfor (int i = head[u]; i != -1; i = edges[i].nxt)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (edges[i].cap != edges[i].flow) ++deg[edges[i].to];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tvector <int> que;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int i = 0; i < n; ++i) if (!deg[i]) que.push_back(i);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int b = 0; b < (int) que.size(); ++b) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfor (int i = head[que[b]]; i != -1; i = edges[i].nxt) if (edges[i].cap != edges[i].flow) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t--deg[edges[i].to];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (!deg[edges[i].to]) que.push_back(edges[i].to);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfill(pot.begin(), pot.end(), inf_cost);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tpot[s] = 0;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif ((int) que.size() == n) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfor (int u: que) if (pot[u] < inf_cost) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tfor (int i = head[u]; i != -1; i = edges[i].nxt) if (edges[i].cap != edges[i].flow && pot[u] + edges[i].cost < pot[edges[i].to]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpot[edges[i].to] = pot[u] + edges[i].cost;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttrace[edges[i].to] = i;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t} else {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tque.assign(1, s);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tvector <bool> in_queue(n, false);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tin_queue[s] = true;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfor (int b = 0; b < (int)que.size(); b++) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tint u = que[b];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tin_queue[u] = false;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tfor (int i = head[u]; i != -1; i = edges[i].nxt) if (edges[i].cap != edges[i].flow && pot[u] + edges[i].cost < pot[edges[i].to]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpot[edges[i].to] = pot[u] + edges[i].cost;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttrace[edges[i].to] = i;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!in_queue[edges[i].to]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tque.push_back(edges[i].to);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tin_queue[edges[i].to] = true;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\twhile (pot[t] < inf_cost) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tCap push = inf_cap;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int u = t; u != s; u = edges[trace[u]].from)\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tpush = min(push, edges[trace[u]].cap - edges[trace[u]].flow);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int u = t; u != s; u = edges[trace[u]].from) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tedges[trace[u]].flow += push;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tedges[trace[u] ^ 1].flow -= push;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tflow += push; cost += push * pot[t];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\texpath(s);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn {flow, cost};\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <bool ToShuffle = false> struct MaxMatching {\\\",\\r\\n            \\\"\\\\tint n;\\\",\\r\\n            \\\"\\\\tvector <int> match, gr, cnt;\\\",\\r\\n            \\\"\\\\tvector <pair <int, int>> edg;\\\",\\r\\n            \\\"\\\\tMaxMatching(int n = 0): n(n) {}\\\",\\r\\n            \\\"\\\\tvoid add(int u, int v) { edg.emplace_back(u, v); }\\\",\\r\\n            \\\"\\\\tstruct Data {\\\",\\r\\n            \\\"\\\\t\\\\tint used, prev, root, depth;\\\",\\r\\n            \\\"\\\\t\\\\tData(int used, int prev, int root, int depth): used(used), prev(prev), root(root), depth(depth) {}\\\",\\r\\n            \\\"\\\\t};\\\",\\r\\n            \\\"\\\\tvector <pair <int, int>> max_matching() {\\\",\\r\\n            \\\"\\\\t\\\\tif constexpr (ToShuffle) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tshuffle(edg.begin(), edg.end(), rng);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tmatch.assign(n, -1);\\\",\\r\\n            \\\"\\\\t\\\\tgr.resize(edg.size() << 1);\\\",\\r\\n            \\\"\\\\t\\\\tcnt.assign(n + 1, 0);\\\",\\r\\n            \\\"\\\\t\\\\tfor (auto [u, v]: edg) ++cnt[u], ++cnt[v];\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0, c = 0; i <= n; ++i) c += cnt[i], cnt[i] = c;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = edg.size(); i-- > 0; ) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tauto &[u, v] = edg[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tgr[--cnt[u]] = v;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tgr[--cnt[v]] = u;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tvector <Data> data(n, Data(0, 0, 0, 0));\\\",\\r\\n            \\\"\\\\t\\\\tint used_mark = 0, db_ptr, de_ptr;\\\",\\r\\n            \\\"\\\\t\\\\tvector <int> dq(n);\\\",\\r\\n            \\\"\\\\t\\\\twhile (true) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tused_mark++; db_ptr = de_ptr = 0;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int i = 0; i < n; ++i) if (match[i] == -1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tdata[i] = Data(used_mark, -1, i, 0);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tdq[de_ptr++] = i;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint aug_cnt = 0;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\twhile (db_ptr < de_ptr) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint u = dq[db_ptr++];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (match[data[u].root] != -1) continue;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tbool aug_found = false;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfor (int ti = cnt[u]; ti < cnt[u + 1]; ++ti) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tint t = gr[ti];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (data[t].used == used_mark && data[t].depth == 0 && match[data[t].root] == -1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taug_cnt++;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmatch[u] = t, match[t] = u;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tint len = 1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (int x = u; data[x].prev != -1; x = data[x].prev) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (data[x].depth == 1) match[x] = data[x].prev, match[data[x].prev] = x;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlen++;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (int x = t; data[x].prev != -1; x = data[x].prev) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (data[x].depth == 1) match[x] = data[x].prev, match[data[x].prev] = x;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlen++;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taug_found = true;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbreak;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (aug_found) continue;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfor (int ti = cnt[u]; ti < cnt[u + 1]; ++ti) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tint t = gr[ti];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tif (data[t].used != used_mark) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tint t2 = match[t];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata[t] = Data(used_mark, u, data[u].root, 1);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata[t2] = Data(used_mark, t, data[u].root, 0);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdq[de_ptr++] = t2;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (!aug_cnt) break;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tvector <pair <int, int>> res;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) if (i < match[i]) res.push_back({i, match[i]});\\\",\\r\\n            \\\"\\\\t\\\\treturn res;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\tpair <vector <int>, vector <int>> minimum_vertex_cover() {\\\",\\r\\n            \\\"\\\\t\\\\tvector <int> q(n);\\\",\\r\\n            \\\"\\\\t\\\\tint qb = 0, qe = 0;\\\",\\r\\n            \\\"\\\\t\\\\tvector <bool> f(n);\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) if (match[i] == -1) q[qe++] = i;\\\",\\r\\n            \\\"\\\\t\\\\twhile (qb < qe) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tint u = q[qb++];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int i = cnt[u]; i < cnt[u + 1]; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint v = gr[i];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (!f[v]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tf[v] = true;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tq[qe++] = match[v];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) if (match[i] != -1 && !f[i] && !f[match[i]]) f[i] = true;\\\",\\r\\n            \\\"\\\\t\\\\tvector <int> L, R;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) (f[i] ? L : R).push_back(i);\\\",\\r\\n            \\\"\\\\t\\\\treturn {L, R};\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"template <class T> struct Hungarian {\\\",\\r\\n            \\\"\\\\tint n;\\\",\\r\\n            \\\"\\\\tvector <vector <T>> c;\\\",\\r\\n            \\\"\\\\tvector <T> fx, fy, d;\\\",\\r\\n            \\\"\\\\tvector <int> l, r, arg, trace;\\\",\\r\\n            \\\"\\\\tint start, finish;\\\",\\r\\n            \\\"\\\\tstatic constexpr T inf = numeric_limits<T>::max() >> 1;\\\",\\r\\n            \\\"\\\\tHungarian() {}\\\",\\r\\n            \\\"\\\\tHungarian(int n1, int n2): n(max(n1, n2)), c(n, vector<T>(n, inf)), fx(n), fy(n), d(n), l(n, -1), r(n, -1), arg(n), trace(n) {}\\\",\\r\\n            \\\"\\\\tvoid add(int u, int v, T cost) { c[u][v] = min(c[u][v], cost); }\\\",\\r\\n            \\\"\\\\tT getC(int u, int v) { return c[u][v] - fx[u] - fy[v]; }\\\",\\r\\n            \\\"\\\\tT max_matching() {\\\",\\r\\n            \\\"\\\\t\\\\tfor (int u = 0; u < n; ++u) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfx[u] = c[u][0];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int v = 0; v < n; ++v) fx[u] = min(fx[u], c[u][v]);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tfor (int v = 0; v < n; ++v) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfy[v] = c[0][v] - fx[0];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int u = 0; u < n; ++u) fy[v] = min(fy[v], c[u][v] - fx[u]);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tvector <int> q(n);\\\",\\r\\n            \\\"\\\\t\\\\tint qb, qe;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int u = 0; u < n; ++u) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tstart = u;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tqb = qe = 0;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tq[qe++] = start;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfill(trace.begin(), trace.end(), -1);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfor (int v = 0; v < n; ++v) d[v] = getC(start, v), arg[v] = start;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tfinish = -1;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\twhile (finish == -1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\twhile (qb < qe) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tint u = q[qb++];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tfor (int v = 0; v < n; ++v) if (trace[v] == -1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tT w = getC(u, v);\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!w) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttrace[v] = u;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (r[v] == -1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfinish = v;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgoto nxt;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tq[qe++] = r[v];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (d[v] > w) d[v] = w, arg[v] = u;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tnxt:;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tif (finish == -1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tT delta = inf;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tfor (int v = 0; v < n; ++v) if (trace[v] == -1 && d[v] < delta) delta = d[v];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tfx[start] += delta;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tfor (int v = 0; v < n; ++v) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (trace[v] != -1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tint u = r[v];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfy[v] -= delta; fx[u] += delta;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else d[v] -= delta;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\tfor (int v = 0; v < n; ++v) if (trace[v] == -1 && !d[v]) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttrace[v] = arg[v];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (r[v] == -1) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfinish = v;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbreak;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tq[qe++] = r[v];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tdo {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tint u = trace[finish], nxt = l[u];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tl[u] = finish; r[finish] = u;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t\\\\tfinish = nxt;\\\",\\r\\n            \\\"\\\\t\\\\t\\\\t} while (finish != -1);\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\tT ans = 0;\\\",\\r\\n            \\\"\\\\t\\\\tfor (int i = 0; i < n; ++i) {\\\",\\r\\n            \\\"\\\\t\\\\t\\\\tif (c[i][l[i]] != inf) ans += c[i][l[i]];\\\",\\r\\n            \\\"\\\\t\\\\t\\\\telse l[i] = -1;\\\",\\r\\n            \\\"\\\\t\\\\t}\\\",\\r\\n            \\\"\\\\t\\\\treturn ans;\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"};\\\",\\r\\n            \\\"} using namespace MAX_FLOW;\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"MAX_FLOW\\\"\\r\\n    },\\r\\n    \\\"GCD\\\": {\\r\\n        \\\"scope\\\": \\\"cpp\\\",\\r\\n        \\\"prefix\\\": \\\"GCD\\\",\\r\\n        \\\"body\\\": [\\r\\n            \\\"int gcd(int a, int b) {\\\",\\r\\n            \\\"\\\\tif (!a) return b;\\\",\\r\\n            \\\"\\\\tif (!b) return a;\\\",\\r\\n            \\\"\\\\tint az = __builtin_ctz(a);\\\",\\r\\n            \\\"\\\\tint bz = __builtin_ctz(b);\\\",\\r\\n            \\\"\\\\tint shift = min(az, bz);\\\",\\r\\n            \\\"\\\\tb >>= bz;\\\",\\r\\n            \\\"\\\\twhile (a) {\\\",\\r\\n            \\\"\\\\t\\\\ta >>= az;\\\",\\r\\n            \\\"\\\\t\\\\tint diff = b - a;\\\",\\r\\n            \\\"\\\\t\\\\taz = __builtin_ctz(diff);\\\",\\r\\n            \\\"\\\\t\\\\tb = min(a, b); a = abs(diff);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn b << shift;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"\\\",\\r\\n            \\\"long long gcdll(long long a, long long b) {\\\",\\r\\n            \\\"\\\\tif (!a) return b;\\\",\\r\\n            \\\"\\\\tif (!b) return a;\\\",\\r\\n            \\\"\\\\tint az = __builtin_ctzll(a);\\\",\\r\\n            \\\"\\\\tint bz = __builtin_ctzll(b);\\\",\\r\\n            \\\"\\\\tint shift = min(az, bz);\\\",\\r\\n            \\\"\\\\tb >>= bz;\\\",\\r\\n            \\\"\\\\twhile (a) {\\\",\\r\\n            \\\"\\\\t\\\\ta >>= az;\\\",\\r\\n            \\\"\\\\t\\\\tlong long diff = b - a;\\\",\\r\\n            \\\"\\\\t\\\\taz = __builtin_ctzll(diff);\\\",\\r\\n            \\\"\\\\t\\\\tb = min(a, b); a = abs(diff);\\\",\\r\\n            \\\"\\\\t}\\\",\\r\\n            \\\"\\\\treturn b << shift;\\\",\\r\\n            \\\"}\\\",\\r\\n            \\\"\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"GCD\\\"\\r\\n    },\\r\\n}\"}}","extensions":"[{\"identifier\":{\"id\":\"adpyke.codesnap\",\"uuid\":\"8c1fc960-44b1-45e8-89b5-85f982fdaf27\"},\"displayName\":\"CodeSnap\"},{\"identifier\":{\"id\":\"divyanshuagrawal.competitive-programming-helper\",\"uuid\":\"28579c42-9973-4b79-9a1e-76431ea4bc1f\"},\"displayName\":\"Competitive Programming Helper (cph)\"},{\"identifier\":{\"id\":\"formulahendry.code-runner\",\"uuid\":\"a6a0c5b2-d078-4bf5-a9ee-4e37054414b3\"},\"displayName\":\"Code Runner\"},{\"identifier\":{\"id\":\"fwcd.kotlin\",\"uuid\":\"c86bc8a9-fd3b-44db-b28a-2d146cb78d3c\"},\"displayName\":\"Kotlin\"},{\"identifier\":{\"id\":\"github.copilot\",\"uuid\":\"23c4aeee-f844-43cd-b53e-1113e483f1a6\"},\"displayName\":\"GitHub Copilot\"},{\"identifier\":{\"id\":\"github.copilot-chat\",\"uuid\":\"7ec7d6e6-b89e-4cc5-a59b-d6c4d238246f\"},\"displayName\":\"GitHub Copilot Chat\"},{\"identifier\":{\"id\":\"mathiasfrohlich.kotlin\",\"uuid\":\"d36bad53-910d-481a-a7ee-8992450665f6\"},\"displayName\":\"Kotlin Language\"},{\"identifier\":{\"id\":\"monokai.theme-monokai-pro-vscode\",\"uuid\":\"f5d7ffda-c1d6-4070-ba80-803c705a1ee6\"},\"displayName\":\"Monokai Pro\"},{\"identifier\":{\"id\":\"ms-python.debugpy\",\"uuid\":\"4bd5d2c9-9d65-401a-b0b2-7498d9f17615\"},\"displayName\":\"Python Debugger\"},{\"identifier\":{\"id\":\"ms-python.python\",\"uuid\":\"f1f59ae4-9318-4f3c-a9b5-81b2eaa5f8a5\"},\"displayName\":\"Python\"},{\"identifier\":{\"id\":\"ms-python.vscode-pylance\",\"uuid\":\"364d2426-116a-433a-a5d8-a5098dc3afbd\"},\"displayName\":\"Pylance\"},{\"identifier\":{\"id\":\"ms-vscode.cpptools\",\"uuid\":\"690b692e-e8a9-493f-b802-8089d50ac1b2\"},\"displayName\":\"C/C++\"},{\"identifier\":{\"id\":\"pkief.material-icon-theme\",\"uuid\":\"5db78037-f674-459f-a236-db622c427c5b\"},\"displayName\":\"Material Icon Theme\"},{\"identifier\":{\"id\":\"shardulm94.trailing-spaces\",\"uuid\":\"6ad45f5a-09ec-44e5-b363-867ddc1ec674\"},\"displayName\":\"Trailing Spaces\"},{\"identifier\":{\"id\":\"shd101wyy.markdown-preview-enhanced\",\"uuid\":\"3b1db1fc-c7f7-4bd6-9fa4-b499dfa99a8a\"},\"displayName\":\"Markdown Preview Enhanced\"},{\"identifier\":{\"id\":\"usernamehw.errorlens\",\"uuid\":\"9d8c32ab-354c-4daf-a9bf-20b633734435\"},\"displayName\":\"Error Lens\"},{\"identifier\":{\"id\":\"vscode-icons-team.vscode-icons\",\"uuid\":\"9ccc1dd7-7ec4-4a46-bd4f-7d7b8b9d322a\"},\"displayName\":\"vscode-icons\"},{\"identifier\":{\"id\":\"wenfangdu.snippet-generator\",\"uuid\":\"0992b553-4ce0-40cf-b32a-c83dd131f9de\"},\"displayName\":\"Snippet Generator\"}]","globalState":"{\"storage\":{\"workbench.panel.markers.hidden\":\"[{\\\"id\\\":\\\"workbench.panel.markers.view\\\",\\\"isHidden\\\":false}]\",\"workbench.panel.output.hidden\":\"[{\\\"id\\\":\\\"workbench.panel.output\\\",\\\"isHidden\\\":false}]\",\"terminal.hidden\":\"[{\\\"id\\\":\\\"terminal\\\",\\\"isHidden\\\":false,\\\"order\\\":1},{\\\"id\\\":\\\"workbench.panel.repl.view\\\",\\\"isHidden\\\":false,\\\"order\\\":0}]\",\"workbench.explorer.views.state.hidden\":\"[{\\\"id\\\":\\\"outline\\\",\\\"isHidden\\\":true},{\\\"id\\\":\\\"timeline\\\",\\\"isHidden\\\":true},{\\\"id\\\":\\\"workbench.explorer.openEditorsView\\\",\\\"isHidden\\\":true},{\\\"id\\\":\\\"workbench.explorer.emptyView\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"npm\\\",\\\"isHidden\\\":true},{\\\"id\\\":\\\"workbench.explorer.fileView\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"dockerContainers\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"dockerImages\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"dockerRegistries\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"dockerNetworks\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"dockerVolumes\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"vscode-docker.views.dockerContexts\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"vscode-docker.views.help\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"copilotSidebar.explain\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"copilotSidebar.translate\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"copilotSidebar.toolbox\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"copilotSidebar.generateTests\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"chatgpt.sidebar\\\",\\\"isHidden\\\":false}]\",\"workbench.scm.views.state.hidden\":\"[{\\\"id\\\":\\\"workbench.scm.repositories\\\",\\\"isHidden\\\":true},{\\\"id\\\":\\\"workbench.scm\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"gitlens.views.repositories\\\",\\\"isHidden\\\":true},{\\\"id\\\":\\\"gitlens.views.commits\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"gitlens.views.commitDetails\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"gitlens.views.fileHistory\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"gitlens.views.lineHistory\\\",\\\"isHidden\\\":true},{\\\"id\\\":\\\"gitlens.views.branches\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"gitlens.views.remotes\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"gitlens.views.stashes\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"gitlens.views.tags\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"gitlens.views.worktrees\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"gitlens.views.contributors\\\",\\\"isHidden\\\":true},{\\\"id\\\":\\\"gitlens.views.searchAndCompare\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.scm.sync\\\",\\\"isHidden\\\":false}]\",\"workbench.view.search.state.hidden\":\"[{\\\"id\\\":\\\"workbench.view.search\\\",\\\"isHidden\\\":false}]\",\"workbench.activity.pinnedViewlets2\":\"[{\\\"id\\\":\\\"workbench.view.search\\\",\\\"pinned\\\":false,\\\"visible\\\":true,\\\"order\\\":1},{\\\"id\\\":\\\"workbench.view.explorer\\\",\\\"pinned\\\":true,\\\"visible\\\":true,\\\"order\\\":0},{\\\"id\\\":\\\"workbench.view.scm\\\",\\\"pinned\\\":false,\\\"visible\\\":true,\\\"order\\\":2},{\\\"id\\\":\\\"workbench.view.debug\\\",\\\"pinned\\\":false,\\\"visible\\\":true,\\\"order\\\":3},{\\\"id\\\":\\\"workbench.view.remote\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":4},{\\\"id\\\":\\\"workbench.view.extension.test\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":6},{\\\"id\\\":\\\"workbench.view.extension.references-view\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":7},{\\\"id\\\":\\\"workbench.view.extension.tabnine\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":12},{\\\"id\\\":\\\"workbench.panel.chatSidebar\\\",\\\"pinned\\\":true,\\\"visible\\\":true,\\\"order\\\":100},{\\\"id\\\":\\\"workbench.view.extension.cph-judge-view-container\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":8},{\\\"id\\\":\\\"workbench.view.extension.copilot-sidebar-webview\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":9},{\\\"id\\\":\\\"workbench.view.extension.cmake-view\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":12},{\\\"id\\\":\\\"workbench.view.extension.cmake__viewContainer\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":12},{\\\"id\\\":\\\"workbench.view.extension.bookmarks\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":8},{\\\"id\\\":\\\"workbench.view.extension.code-time-sidebar\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":13},{\\\"id\\\":\\\"workbench.view.extension.dockerView\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":10},{\\\"id\\\":\\\"workbench.view.extension.tabnine-access\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":15},{\\\"id\\\":\\\"workbench.view.extension.gitlens\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":12},{\\\"id\\\":\\\"workbench.view.extensions\\\",\\\"pinned\\\":true,\\\"visible\\\":true,\\\"order\\\":4},{\\\"id\\\":\\\"workbench.panel.chatSidebar.copilot\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":100},{\\\"id\\\":\\\"workbench.view.sync\\\",\\\"pinned\\\":true,\\\"visible\\\":false},{\\\"id\\\":\\\"workbench.view.editSessions\\\",\\\"pinned\\\":true,\\\"visible\\\":false},{\\\"id\\\":\\\"userDataProfiles\\\",\\\"pinned\\\":true,\\\"visible\\\":false}]\",\"workbench.panel.pinnedPanels\":\"[{\\\"id\\\":\\\"workbench.panel.markers\\\",\\\"pinned\\\":true,\\\"visible\\\":true,\\\"order\\\":0},{\\\"id\\\":\\\"workbench.panel.output\\\",\\\"pinned\\\":true,\\\"visible\\\":true,\\\"order\\\":1},{\\\"id\\\":\\\"workbench.views.service.panel.17827b40-7980-41bf-8535-94638f93a3a1\\\",\\\"pinned\\\":true,\\\"visible\\\":false},{\\\"id\\\":\\\"workbench.panel.repl\\\",\\\"pinned\\\":true,\\\"visible\\\":true,\\\"order\\\":2},{\\\"id\\\":\\\"workbench.panel.testResults\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":3},{\\\"id\\\":\\\"terminal\\\",\\\"pinned\\\":true,\\\"visible\\\":true,\\\"order\\\":3},{\\\"id\\\":\\\"~remote.forwardedPortsContainer\\\",\\\"pinned\\\":false,\\\"visible\\\":true,\\\"order\\\":5},{\\\"id\\\":\\\"workbench.view.extension.gitlensPanel\\\",\\\"pinned\\\":true,\\\"visible\\\":false,\\\"order\\\":6},{\\\"id\\\":\\\"workbench.panel.comments\\\",\\\"pinned\\\":false,\\\"visible\\\":false,\\\"order\\\":10},{\\\"id\\\":\\\"refactorPreview\\\",\\\"pinned\\\":true,\\\"visible\\\":false}]\",\"workbench.view.debug.state.hidden\":\"[{\\\"id\\\":\\\"workbench.debug.welcome\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.debug.variablesView\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.debug.watchExpressionsView\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.debug.callStackView\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.debug.loadedScriptsView\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.debug.breakPointsView\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"jsBrowserBreakpoints\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"jsExcludedCallers\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"CppSshTargetsView\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"lldb.loadedModules\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"lldb.excludedCallers\\\",\\\"isHidden\\\":false}]\",\"workbench.panel.repl.hidden\":\"[{\\\"id\\\":\\\"workbench.panel.repl.view\\\",\\\"isHidden\\\":false}]\",\"colorThemeData\":\"{\\\"id\\\":\\\"vs-dark monokai-theme-monokai-pro-vscode-themes-Monokai-Pro--Filter-Spectrum--json\\\",\\\"label\\\":\\\"Monokai Pro (Filter Spectrum)\\\",\\\"settingsId\\\":\\\"Monokai Pro (Filter Spectrum)\\\",\\\"themeTokenColors\\\":[{\\\"settings\\\":{\\\"name\\\":\\\"Comments and overrides inside comments\\\",\\\"fontStyle\\\":\\\"italic\\\",\\\"foreground\\\":\\\"#69676c\\\"},\\\"scope\\\":[\\\"comment\\\",\\\"comment keyword\\\",\\\"comment markup.underline.link\\\",\\\"comment string\\\",\\\"comment punctuation.definition\\\",\\\"comment punctuation\\\",\\\"comment text\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"JSDoc storage type\\\",\\\"foreground\\\":\\\"#69676c\\\"},\\\"scope\\\":\\\"comment storage.type\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"JSDoc entity name\\\",\\\"foreground\\\":\\\"#bab6c0\\\"},\\\"scope\\\":\\\"comment entity.name.type\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"JSDoc variable\\\",\\\"foreground\\\":\\\"#bab6c0\\\"},\\\"scope\\\":[\\\"comment variable\\\",\\\"comment variable.other\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"PHPDoc keyword\\\",\\\"foreground\\\":\\\"#bab6c0\\\"},\\\"scope\\\":[\\\"comment keyword\\\",\\\"comment entity.name.tag\\\",\\\"entity.name.tag.documentation\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Comment TODO / FIXME (at least in VSCode Python)\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"comment keyword.codetag.notation\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Git status remote\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":\\\"comment.git-status.header.remote\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Git status local\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":\\\"comment.git-status.header.local\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Git status remote\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"comment.other.git-status.head\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Docstring\\\",\\\"foreground\\\":\\\"#69676c\\\"},\\\"scope\\\":[\\\"string.quoted.docstring\\\",\\\"string.quoted.docstring punctuation.definition\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Constant\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"constant\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Constant\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"constant.other\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Constant\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"constant.other.caps\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Placeholders in C\\\",\\\"foreground\\\":\\\"#fd9353\\\"},\\\"scope\\\":\\\"constant.other.placeholder.c\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Constant as property\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"constant.other.property\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Constant in latex\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"constant.other.citation.latex\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Constant as color (in css / sass)\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"constant.other.color\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Constant as character class escape (e.g. in regex)\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"constant.other.character-class.escape\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Constant as key (e.g. in puppet manifests)\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"constant.other.key\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Constant as symbol (e.g. in ruby)\\\",\\\"foreground\\\":\\\"#fd9353\\\"},\\\"scope\\\":\\\"constant.other.symbol\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Constants in elm\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":\\\"constant.other.elm\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Number\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"constant.numeric\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Constant\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"constant.language\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Character escape\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"constant.character.escape\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Search result line numbers\\\",\\\"foreground\\\":\\\"#525053\\\"},\\\"scope\\\":\\\"constant.numeric.line-number.find-in-files\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Search result matched line numbes\\\",\\\"foreground\\\":\\\"#fce566\\\"},\\\"scope\\\":\\\"constant.numeric.line-number.match.find-in-files\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Sections\\\",\\\"foreground\\\":\\\"#fce566\\\"},\\\"scope\\\":\\\"entity.name.section\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Functions\\\",\\\"foreground\\\":\\\"#7bd88f\\\"},\\\"scope\\\":[\\\"entity.name.function\\\",\\\"entity.name.function.templated\\\",\\\"entity.name.function.member.static\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Class template\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":[\\\"entity.name.type.class.templated\\\",\\\"entity.name.type.class.generic\\\",\\\"entity.name.type.namespace\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"label\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"entity.name.label\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Macros\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":\\\"entity.name.function.preprocessor\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Entity name\\\",\\\"foreground\\\":\\\"#7bd88f\\\"},\\\"scope\\\":\\\"entity.name\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Class name\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":\\\"entity.name.class\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Constant name\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"entity.name.constant\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Namespace\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"entity.name.namespace\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Inherited class\\\",\\\"fontStyle\\\":\\\"italic\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":\\\"entity.other.inherited-class\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Function name\\\",\\\"foreground\\\":\\\"#7bd88f\\\"},\\\"scope\\\":\\\"entity.name.function\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Tag name\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":[\\\"entity.name.tag\\\",\\\"entity.name.tag.js.jsx support.class.component.js.jsx\\\",\\\"entity.name.tag support.class.component\\\",\\\"source.vue support.class.component\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Operator\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":\\\"entity.name.function.operator\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Operator\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":[\\\"meta.brackets entity.name.function.operator\\\",\\\"punctuation.separator entity.name.function.operator\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Entity name type\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":[\\\"entity.name.type\\\",\\\"entity.name.type.class.reference\\\",\\\"entity.name.type.class.value\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Tag attribute\\\",\\\"fontStyle\\\":\\\"italic\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":\\\"entity.other.attribute-name\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"CSS class\\\",\\\"foreground\\\":\\\"#7bd88f\\\"},\\\"scope\\\":[\\\"entity.other.attribute-name.class.css\\\",\\\"entity.other.attribute-name.parent-selector-suffix.css\\\",\\\"entity.other.attribute-name.parent-selector-suffix.css punctuation.definition.entity.css\\\",\\\"entity.other.attribute-name.css\\\",\\\"entity.other.animation-name.css\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"CSS id\\\",\\\"foreground\\\":\\\"#fd9353\\\"},\\\"scope\\\":\\\"entity.other.attribute-name.id.css\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"CSS pseudo class\\\",\\\"fontStyle\\\":\\\"italic\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":[\\\"entity.other.attribute-name.pseudo-class.css\\\",\\\"entity.other.pseudo-class.css\\\",\\\"entity.other.pseudo-element.css\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Function names / calls\\\",\\\"foreground\\\":\\\"#7bd88f\\\"},\\\"scope\\\":[\\\"entity.name.function\\\",\\\"support.function\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"git status commit hex\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"entity.other.git-status.hex\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"jinja delimiters\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":\\\"entity.other.jinja2.delimiter\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"custom literal\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"entity.name.operator.custom-literal\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"custom literal string\\\",\\\"foreground\\\":\\\"#fce566\\\"},\\\"scope\\\":\\\"entity.name.operator.custom-literal.string\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"custom literal number\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"entity.name.operator.custom-literal.number\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"rust specific\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":\\\"entity.name.type.rust\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"rust specific\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":\\\"entity.name.lifetime.rust\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Invalid\\\",\\\"foreground\\\":\\\"#fc618d\\\",\\\"fontStyle\\\":\\\"italic underline\\\"},\\\"scope\\\":\\\"invalid\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Invalid deprecated\\\",\\\"foreground\\\":\\\"#fd9353\\\",\\\"fontStyle\\\":\\\"italic underline\\\"},\\\"scope\\\":\\\"invalid.deprecated\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Keyword\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":\\\"keyword\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Control keywords examples include if, try, end and while. Some syntaxes prefer to mark if and else with the conditional variant. The import variant is often used in appropriate situations.\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":\\\"keyword.control\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"keyword control directive\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":\\\"keyword.control.directive\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Operator\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":[\\\"keyword.operator\\\",\\\"keyword.operator.member\\\",\\\"keyword.operator.new\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Substitution string\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":\\\"keyword.other.substitution\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Template literal begin / end\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":[\\\"keyword.other.template.begin\\\",\\\"keyword.other.template.end\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"RestructuredText heading, table markup\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":[\\\"keyword.operator.heading.restructuredtext\\\",\\\"keyword.operator.table.row.restructuredtext keyword.operator.table.data.restructuredtext\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"elm parenthesis\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":\\\"keyword.other.parenthesis.elm\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"rust specific\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":[\\\"keyword.other.fn.rust\\\",\\\"keyword.other.rust\\\",\\\"keyword.other.unsafe.rust\\\",\\\"keyword.other.where.rust\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"rust specific\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":[\\\"keyword.control.rust\\\",\\\"keyword.operator.misc.rust\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"ruby specific\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":[\\\"keyword.declaration.class.ruby\\\",\\\"keyword.declaration.function.ruby\\\",\\\"keyword.declaration.namespace.ruby\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Italic\\\",\\\"fontStyle\\\":\\\"italic\\\"},\\\"scope\\\":\\\"markup.italic\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Bold\\\",\\\"fontStyle\\\":\\\"bold\\\"},\\\"scope\\\":\\\"markup.bold\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Heading\\\",\\\"foreground\\\":\\\"#fce566\\\"},\\\"scope\\\":\\\"markup.heading\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Raw\\\",\\\"foreground\\\":\\\"#fd9353\\\"},\\\"scope\\\":\\\"markup.raw\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Underline\\\",\\\"fontStyle\\\":\\\"underline\\\"},\\\"scope\\\":\\\"markup.underline\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Link\\\",\\\"foreground\\\":\\\"#7bd88f\\\"},\\\"scope\\\":\\\"markup.underline.link\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Diff inserted\\\",\\\"foreground\\\":\\\"#7bd88f\\\"},\\\"scope\\\":[\\\"markup.inserted\\\",\\\"markup.inserted punctuation.definition.inserted\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Diff deleted\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":[\\\"markup.deleted\\\",\\\"markup.deleted punctuation.definition.deleted\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Diff changed\\\",\\\"foreground\\\":\\\"#fce566\\\"},\\\"scope\\\":[\\\"markup.changed\\\",\\\"markup.changed punctuation.definition.changed\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Diff ignored\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":[\\\"markup.ignored\\\",\\\"markup.ignored punctuation.definition.ignored\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Diff untracked\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":\\\"markup.untracked\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Markup quote\\\",\\\"fontStyle\\\":\\\"italic\\\"},\\\"scope\\\":\\\"markup.quote\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Braces, delimiters\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":[\\\"meta.brace.round\\\",\\\"meta.brace.square\\\",\\\"meta.brace.curly\\\",\\\"meta.delimiter.comma.js\\\",\\\"meta.function-call.without-arguments.js\\\",\\\"meta.function-call.method.without-arguments.js\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Function call (vs)\\\",\\\"foreground\\\":\\\"#7bd88f\\\"},\\\"scope\\\":[\\\"meta.function-call.generic.python\\\",\\\"support.function.builtin.python\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Function arguments (vs)\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"meta.function-call.python meta.function-call.arguments.python\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Constructor (new MyClass())\\\",\\\"foreground\\\":\\\"#7bd88f\\\"},\\\"scope\\\":\\\"meta.instance.constructor\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Class string name (i.e. in html attributes)\\\",\\\"foreground\\\":\\\"#7bd88f\\\"},\\\"scope\\\":[\\\"meta.attribute-with-value.class string\\\",\\\"meta.attribute.class.html string\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"ID string name (i.e. in html attributes)\\\",\\\"foreground\\\":\\\"#fd9353\\\"},\\\"scope\\\":[\\\"meta.attribute-with-value.id string\\\",\\\"meta.attribute.id.html string\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"JSON keys\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"source.json meta.mapping.key string\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"YAML keys\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":\\\"source.yaml meta.mapping.key string\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Object members\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"meta.object.member\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"SCSS Variable\\\",\\\"foreground\\\":\\\"#fd9353\\\"},\\\"scope\\\":\\\"meta.property-list.css variable.other\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Preprocessor\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":[\\\"entity.name.constant.preprocessor\\\",\\\"meta.preprocessor\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"git diff header\\\",\\\"foreground\\\":\\\"#fce566\\\"},\\\"scope\\\":\\\"meta.diff.git-diff.header\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"rust specific (brackets and certain type names)\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"meta.type_params.rust\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"rust specific (variable.language.rust is 'self' keyword.\\\",\\\"foreground\\\":\\\"#bab6c0\\\"},\\\"scope\\\":[\\\"meta.attribute.rust\\\",\\\"meta.annotation.rust\\\",\\\"variable.language.rust\\\",\\\"variable.annotation.rust\\\",\\\"meta.annotation.rust string\\\",\\\"meta.annotation.rust keyword\\\",\\\"meta.annotation.rust keyword.operator\\\",\\\"meta.attribute.rust string\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"type annotation\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":[\\\"meta.type variable\\\",\\\"meta.type variable.other.readwrite\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Punctuation\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":\\\"punctuation\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Punctuation tags\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":[\\\"punctuation.definition.tag\\\",\\\"punctuation.definition.tag source\\\",\\\"punctuation.definition.group.begin.ruby\\\",\\\"punctuation.definition.group.end.ruby\\\",\\\"punctuation.definition.group.begin.css\\\",\\\"punctuation.definition.group.end.css\\\",\\\"punctuation.definition.string.end.html source.css\\\",\\\"punctuation.definition.block\\\",\\\"punctuation.definition.parameters.begin\\\",\\\"punctuation.definition.parameters.end\\\",\\\"punctuation.separator.parameter\\\",\\\"punctuation.accessor\\\",\\\"punctuation.terminator\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Group (i.e. in regex)\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"punctuation.definition.group\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Comment start / end\\\",\\\"foreground\\\":\\\"#69676c\\\"},\\\"scope\\\":\\\"punctuation.definition.comment\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Variable indicator (i.e. in php or in include directives in sass)\\\",\\\"foreground\\\":\\\"#bab6c0\\\"},\\\"scope\\\":[\\\"punctuation.definition.variable\\\",\\\"punctuation.definition.keyword.scss\\\",\\\"punctuation.definition.entity.css\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Punctuation section embedded (i.e. ?php blocks in html)\\\",\\\"foreground\\\":\\\"#fd9353\\\"},\\\"scope\\\":[\\\"punctuation.section.embedded\\\",\\\"punctuation.section.embedded entity.name.tag\\\",\\\"punctuation.section.embedded constant.other\\\",\\\"punctuation.section.embedded source\\\",\\\"punctuation.section.embedded.begin\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Punctuation template string (`example`)\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":[\\\"punctuation.template-string.element.begin\\\",\\\"punctuation.template-string.element.end\\\",\\\"punctuation.definition.string.template.begin\\\",\\\"punctuation.definition.string.template.end\\\",\\\"string.quoted.template punctuation.definition.string.begin\\\",\\\"string.quoted.template punctuation.definition.string.end\\\",\\\"punctuation.definition.template-expression.begin\\\",\\\"punctuation.definition.template-expression.end\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Punctuation hard line break in Markdown\\\",\\\"background\\\":\\\"#948ae3\\\"},\\\"scope\\\":[\\\"meta.paragraph.markdown meta.dummy.line-break\\\",\\\"meta.paragraph.markdown meta.hard-line-break.markdown\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Punctuation in markdown links\\\",\\\"foreground\\\":\\\"#7bd88f\\\"},\\\"scope\\\":\\\"markup.underline.link punctuation\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Meta braces\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":[\\\"meta.brace.round\\\",\\\"meta.brace.square\\\",\\\"keyword.operator.type.annotation\\\",\\\"meta.type storage.modifier.array\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"region red color\\\",\\\"foreground\\\":\\\"#fc618d\\\",\\\"background\\\":\\\"#fc618d59\\\"},\\\"scope\\\":\\\"region.redish\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"region orange color\\\",\\\"foreground\\\":\\\"#fd9353\\\",\\\"background\\\":\\\"#fd935359\\\"},\\\"scope\\\":\\\"region.orangish\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"region yellow color\\\",\\\"foreground\\\":\\\"#fce566\\\",\\\"background\\\":\\\"#fce56659\\\"},\\\"scope\\\":\\\"region.yellowish\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"region green color\\\",\\\"foreground\\\":\\\"#7bd88f\\\",\\\"background\\\":\\\"#7bd88f59\\\"},\\\"scope\\\":\\\"region.greenish\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"region blue color\\\",\\\"foreground\\\":\\\"#5ad4e6\\\",\\\"background\\\":\\\"#5ad4e659\\\"},\\\"scope\\\":\\\"region.bluish\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"region purple color\\\",\\\"foreground\\\":\\\"#948ae3\\\",\\\"background\\\":\\\"#948ae359\\\"},\\\"scope\\\":\\\"region.purplish\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"region pink color\\\",\\\"foreground\\\":\\\"#fc618d\\\",\\\"background\\\":\\\"#fc618d59\\\"},\\\"scope\\\":\\\"region.pinkish\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"White for ST3 for non-colorized scheme\\\",\\\"foreground\\\":\\\"#FFFFFF\\\"},\\\"scope\\\":\\\"region.whitish\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"source\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"source\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"SASS, SCSS default\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":[\\\"source.scss\\\",\\\"source.sass\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"SASS, SCSS and LESS variables\\\",\\\"fontStyle\\\":\\\"italic\\\",\\\"foreground\\\":\\\"#fd9353\\\"},\\\"scope\\\":[\\\"source.sass variable.other\\\",\\\"source.sass variable.sass\\\",\\\"source.scss variable.other\\\",\\\"source.scss variable.scss\\\",\\\"source.scss variable.sass\\\",\\\"source.css variable.other\\\",\\\"source.css variable.scss\\\",\\\"source.less variable.other\\\",\\\"source.less variable.other.less\\\",\\\"source.less variable.declaration.less\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"git\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"source.git-show.commit.sha\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"git\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":[\\\"source.git-show.author\\\",\\\"source.git-show.date\\\",\\\"source.git-diff.command\\\",\\\"source.git-diff.command meta.diff.git-diff.header.from-file\\\",\\\"source.git-diff.command meta.diff.git-diff.header.to-file\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"git diff header hash\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":[\\\"source.git-show meta.diff.git-diff.header.extended.index.from-sha\\\",\\\"source.git-show meta.diff.git-diff.header.extended.index.to-sha\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"git diff header range\\\",\\\"foreground\\\":\\\"#fd9353\\\"},\\\"scope\\\":\\\"source.git-show meta.diff.range.unified\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"git diff header files\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":[\\\"source.git-show meta.diff.header.from-file\\\",\\\"source.git-show meta.diff.header.to-file\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Storage\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":\\\"storage\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Types and definition / declaration keywords should use the following scope. Examples include int, bool, char, func, function, class and def. Depending on the language and semantics, const may be this or storage.modifier.\\\",\\\"fontStyle\\\":\\\"italic\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":\\\"storage.type\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Extends\\\",\\\"fontStyle\\\":\\\"normal\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":\\\"storage.type.extends\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Fat arrow function\\\",\\\"fontStyle\\\":\\\"normal\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":\\\"storage.type.function.arrow\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Keywords that affect the storage of a variable, function or data structure should use the following scope. Examples include static, inline, const, public and private.\\\",\\\"fontStyle\\\":\\\"italic\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":[\\\"storage.modifier\\\",\\\"storage.type.modifier\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"refs (Restructured text)\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"storage.class.restructuredtext.ref\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"rust specific\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":[\\\"storage.modifier.visibility.rust\\\",\\\"storage.modifier.lifetime.rust\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"rust specific\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":[\\\"storage.modifier.const.rust\\\",\\\"storage.modifier.dyn.rust\\\",\\\"storage.modifier.mut.rust\\\",\\\"storage.modifier.static.rust\\\",\\\"storage.type.rust\\\",\\\"storage.type.core.rust\\\",\\\"storage.class.std.rust\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"rust specific (adjust blue to red)\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":[\\\"storage.type.rust\\\",\\\"storage.modifier.const.rust\\\",\\\"storage.modifier.dyn.rust\\\",\\\"storage.modifier.mut.rust\\\",\\\"storage.modifier.static.rust\\\",\\\"keyword.other.rust\\\",\\\"keyword.other.where.rust\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"imported Java libraries\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"storage.modifier.import.java\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"String\\\",\\\"foreground\\\":\\\"#fce566\\\"},\\\"scope\\\":\\\"string\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"String label\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"string.unquoted.label\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Source in template string\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"string source\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Embedded punctuation begin / end in template string\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":[\\\"string source punctuation.section.embedded\\\",\\\"string punctuation.definition.string source\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"link title\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":[\\\"string.other.link.title\\\",\\\"string.other.link.description\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"link description\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":\\\"string.other.link.description.title\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"String regexp begin / end\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":[\\\"string.regexp punctuation.definition.string.begin\\\",\\\"string.regexp punctuation.definition.string.end\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"refs (Restructured text)\\\",\\\"foreground\\\":\\\"#7bd88f\\\"},\\\"scope\\\":[\\\"string.other.ref\\\",\\\"string.other.restructuredtext.ref\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"git key in git status help text\\\",\\\"foreground\\\":\\\"#bab6c0\\\"},\\\"scope\\\":\\\"string.other.git-status.help.key\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"git status remote\\\",\\\"foreground\\\":\\\"#fc618d\\\"},\\\"scope\\\":\\\"string.other.git-status.remote\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Library constant\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":\\\"support.constant\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Handlebars start / end\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":\\\"support.constant.handlebars\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"vendor prefix\\\",\\\"foreground\\\":\\\"#bab6c0\\\"},\\\"scope\\\":\\\"support.type.vendor-prefix.css\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Function name\\\",\\\"foreground\\\":\\\"#7bd88f\\\"},\\\"scope\\\":\\\"support.function\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"function brackets, comma's\\\",\\\"foreground\\\":\\\"#8b888f\\\"},\\\"scope\\\":\\\"support.function.delimiter.elm\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Library type\\\",\\\"fontStyle\\\":\\\"italic\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":[\\\"support.type\\\",\\\"entity.name.type.object.console\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Support variables\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":[\\\"support.variable\\\",\\\"support.variable.property\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Library type property, JSON keys\\\",\\\"fontStyle\\\":\\\"normal\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"support.type.property-name\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Library class\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":\\\"support.class\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"rust specific\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"support.constant.core.rust\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"comment support\\\",\\\"foreground\\\":\\\"#69676c\\\"},\\\"scope\\\":[\\\"comment support\\\",\\\"comment support.class\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"text\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"text\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Search result\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"text.find-in-files\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Variable\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":[\\\"variable\\\",\\\"variable.other\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Function arguments\\\",\\\"fontStyle\\\":\\\"italic\\\",\\\"foreground\\\":\\\"#fd9353\\\"},\\\"scope\\\":[\\\"variable.parameter\\\",\\\"parameters variable.function\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Reserved variable names that are specified by the language, such as this, self, super, arguments. Also in function arguments (e.g. like in Python)\\\",\\\"fontStyle\\\":\\\"italic\\\",\\\"foreground\\\":\\\"#bab6c0\\\"},\\\"scope\\\":[\\\"variable.language\\\",\\\"variable.parameter.function.language.special.self.python\\\",\\\"variable.parameter.function.language.special.cls.python\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Reserved variable names: 'arguments'\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"variable.language.arguments\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Library function\\\",\\\"foreground\\\":\\\"#5ad4e6\\\"},\\\"scope\\\":\\\"variable.other.class\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Immutable variables, often via a const modifier, should receive the following scope. Depending on the language and semantics, entity.name.constant may be a better choice.\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"variable.other.constant\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"read/write variables\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"variable.other.readwrite\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Fields, properties, members and attributes of a class or other data structure should use:\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":\\\"variable.other.member\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Enum member\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":\\\"variable.other.enummember\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Variable property\\\",\\\"foreground\\\":\\\"#f7f1ff\\\"},\\\"scope\\\":[\\\"variable.other.property\\\",\\\"variable.other.property.static\\\",\\\"variable.other.event\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"Function and method names should be scoped using the following, but only when they are being invoked. When defined, they should use entity.name.function.\\\",\\\"foreground\\\":\\\"#7bd88f\\\"},\\\"scope\\\":\\\"variable.function\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Substitution (restructured text)\\\",\\\"foreground\\\":\\\"#fd9353\\\"},\\\"scope\\\":\\\"variable.other.substitution\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"Ruby instance variables\\\",\\\"foreground\\\":\\\"#948ae3\\\"},\\\"scope\\\":[\\\"source.ruby variable.other.readwrite.instance.ruby\\\",\\\"source.ruby variable.other.readwrite.class.ruby\\\"]},{\\\"settings\\\":{\\\"name\\\":\\\"jinja2 variable block\\\",\\\"foreground\\\":\\\"#7bd88f\\\"},\\\"scope\\\":\\\"source.jinja2 variable.other.jinja2.block\\\"},{\\\"settings\\\":{\\\"name\\\":\\\"jinja2 variable\\\",\\\"foreground\\\":\\\"#fd9353\\\"},\\\"scope\\\":\\\"source.jinja2 variable.other.jinja2\\\"}],\\\"semanticTokenRules\\\":[],\\\"extensionData\\\":{\\\"_extensionId\\\":\\\"monokai.theme-monokai-pro-vscode\\\",\\\"_extensionIsBuiltin\\\":false,\\\"_extensionName\\\":\\\"theme-monokai-pro-vscode\\\",\\\"_extensionPublisher\\\":\\\"monokai\\\"},\\\"colorMap\\\":{\\\"activityBar.activeFocusBorder\\\":\\\"#fce566\\\",\\\"activityBar.background\\\":\\\"#131313\\\",\\\"activityBar.border\\\":\\\"#131313\\\",\\\"activityBar.foreground\\\":\\\"#bab6c0\\\",\\\"activityBar.inactiveForeground\\\":\\\"#525053\\\",\\\"activityBarBadge.background\\\":\\\"#fce566\\\",\\\"activityBarBadge.foreground\\\":\\\"#222222\\\",\\\"badge.background\\\":\\\"#fce566\\\",\\\"badge.foreground\\\":\\\"#222222\\\",\\\"banner.background\\\":\\\"#363537\\\",\\\"banner.foreground\\\":\\\"#bab6c0\\\",\\\"banner.iconForeground\\\":\\\"#bab6c0\\\",\\\"breadcrumb.activeSelectionForeground\\\":\\\"#f7f1ff\\\",\\\"breadcrumb.focusForeground\\\":\\\"#bab6c0\\\",\\\"breadcrumb.foreground\\\":\\\"#8b888f\\\",\\\"breadcrumbPicker.background\\\":\\\"#222222\\\",\\\"button.background\\\":\\\"#363537\\\",\\\"button.foreground\\\":\\\"#bab6c0\\\",\\\"button.hoverBackground\\\":\\\"#525053\\\",\\\"button.secondaryBackground\\\":\\\"#363537\\\",\\\"button.secondaryForeground\\\":\\\"#bab6c0\\\",\\\"button.secondaryHoverBackground\\\":\\\"#525053\\\",\\\"button.separator\\\":\\\"#222222\\\",\\\"charts.blue\\\":\\\"#5ad4e6\\\",\\\"charts.foreground\\\":\\\"#f7f1ff\\\",\\\"charts.green\\\":\\\"#7bd88f\\\",\\\"charts.lines\\\":\\\"#69676c\\\",\\\"charts.orange\\\":\\\"#fd9353\\\",\\\"charts.purple\\\":\\\"#948ae3\\\",\\\"charts.red\\\":\\\"#fc618d\\\",\\\"charts.yellow\\\":\\\"#fce566\\\",\\\"chat.avatarBackground\\\":\\\"#222222\\\",\\\"chat.avatarForeground\\\":\\\"#948ae3\\\",\\\"chat.requestBackground\\\":\\\"#363537\\\",\\\"chat.requestBorder\\\":\\\"#525053\\\",\\\"chat.slashCommandBackground\\\":\\\"#00000000\\\",\\\"chat.slashCommandForeground\\\":\\\"#fce566\\\",\\\"checkbox.background\\\":\\\"#363537\\\",\\\"checkbox.border\\\":\\\"#363537\\\",\\\"checkbox.foreground\\\":\\\"#f7f1ff\\\",\\\"commandCenter.activeBackground\\\":\\\"#222222\\\",\\\"commandCenter.activeForeground\\\":\\\"#bab6c0\\\",\\\"commandCenter.background\\\":\\\"#191919\\\",\\\"commandCenter.border\\\":\\\"#222222\\\",\\\"commandCenter.debuggingBackground\\\":\\\"#191919\\\",\\\"commandCenter.foreground\\\":\\\"#8b888f\\\",\\\"debugConsole.errorForeground\\\":\\\"#fc618d\\\",\\\"debugConsole.infoForeground\\\":\\\"#5ad4e6\\\",\\\"debugConsole.sourceForeground\\\":\\\"#f7f1ff\\\",\\\"debugConsole.warningForeground\\\":\\\"#fd9353\\\",\\\"debugConsoleInputIcon.foreground\\\":\\\"#fce566\\\",\\\"debugExceptionWidget.background\\\":\\\"#363537\\\",\\\"debugExceptionWidget.border\\\":\\\"#222222\\\",\\\"debugIcon.breakpointCurrentStackframeForeground\\\":\\\"#fce566\\\",\\\"debugIcon.breakpointDisabledForeground\\\":\\\"#bab6c0\\\",\\\"debugIcon.breakpointForeground\\\":\\\"#fc618d\\\",\\\"debugIcon.breakpointStackframeForeground\\\":\\\"#f7f1ff\\\",\\\"debugIcon.breakpointUnverifiedForeground\\\":\\\"#fd9353\\\",\\\"debugIcon.continueForeground\\\":\\\"#f7f1ff\\\",\\\"debugIcon.disconnectForeground\\\":\\\"#f7f1ff\\\",\\\"debugIcon.pauseForeground\\\":\\\"#f7f1ff\\\",\\\"debugIcon.restartForeground\\\":\\\"#7bd88f\\\",\\\"debugIcon.startForeground\\\":\\\"#7bd88f\\\",\\\"debugIcon.stepBackForeground\\\":\\\"#f7f1ff\\\",\\\"debugIcon.stepIntoForeground\\\":\\\"#f7f1ff\\\",\\\"debugIcon.stepOutForeground\\\":\\\"#f7f1ff\\\",\\\"debugIcon.stepOverForeground\\\":\\\"#f7f1ff\\\",\\\"debugIcon.stopForeground\\\":\\\"#fc618d\\\",\\\"debugTokenExpression.boolean\\\":\\\"#fd9353\\\",\\\"debugTokenExpression.error\\\":\\\"#fc618d\\\",\\\"debugTokenExpression.name\\\":\\\"#5ad4e6\\\",\\\"debugTokenExpression.number\\\":\\\"#948ae3\\\",\\\"debugTokenExpression.string\\\":\\\"#fce566\\\",\\\"debugTokenExpression.value\\\":\\\"#f7f1ff\\\",\\\"debugToolBar.background\\\":\\\"#363537\\\",\\\"debugView.exceptionLabelBackground\\\":\\\"#fc618d\\\",\\\"debugView.exceptionLabelForeground\\\":\\\"#222222\\\",\\\"debugView.stateLabelBackground\\\":\\\"#7bd88f\\\",\\\"debugView.stateLabelForeground\\\":\\\"#222222\\\",\\\"debugView.valueChangedHighlight\\\":\\\"#fce566\\\",\\\"descriptionForeground\\\":\\\"#8b888f\\\",\\\"diffEditor.diagonalFill\\\":\\\"#363537\\\",\\\"diffEditor.insertedLineBackground\\\":\\\"#7bd88f19\\\",\\\"diffEditor.insertedTextBackground\\\":\\\"#7bd88f19\\\",\\\"diffEditor.move.border\\\":\\\"#ff0000\\\",\\\"diffEditor.moveActive.border\\\":\\\"#ff0000\\\",\\\"diffEditor.removedLineBackground\\\":\\\"#fc618d19\\\",\\\"diffEditor.removedTextBackground\\\":\\\"#fc618d19\\\",\\\"diffEditor.unchangedCodeBackground\\\":\\\"#191919\\\",\\\"diffEditor.unchangedRegionBackground\\\":\\\"#191919\\\",\\\"diffEditor.unchangedRegionForeground\\\":\\\"#bab6c0\\\",\\\"diffEditor.unchangedRegionShadow\\\":\\\"#131313\\\",\\\"diffEditorGutter.insertedLineBackground\\\":\\\"#7bd88f19\\\",\\\"diffEditorGutter.removedLineBackground\\\":\\\"#fc618d19\\\",\\\"diffEditorOverview.insertedForeground\\\":\\\"#7bd88fa5\\\",\\\"diffEditorOverview.removedForeground\\\":\\\"#fc618da5\\\",\\\"dropdown.background\\\":\\\"#222222\\\",\\\"dropdown.border\\\":\\\"#222222\\\",\\\"dropdown.foreground\\\":\\\"#8b888f\\\",\\\"dropdown.listBackground\\\":\\\"#363537\\\",\\\"editor.background\\\":\\\"#222222\\\",\\\"editor.findMatchBackground\\\":\\\"#f7f1ff26\\\",\\\"editor.findMatchBorder\\\":\\\"#fce566\\\",\\\"editor.findMatchHighlightBackground\\\":\\\"#f7f1ff26\\\",\\\"editor.findMatchHighlightBorder\\\":\\\"#00000000\\\",\\\"editor.findRangeHighlightBackground\\\":\\\"#f7f1ff0c\\\",\\\"editor.findRangeHighlightBorder\\\":\\\"#00000000\\\",\\\"editor.focusedStackFrameHighlightBackground\\\":\\\"#bab6c026\\\",\\\"editor.foldBackground\\\":\\\"#f7f1ff0c\\\",\\\"editor.foreground\\\":\\\"#f7f1ff\\\",\\\"editor.hoverHighlightBackground\\\":\\\"#f7f1ff0c\\\",\\\"editor.inactiveSelectionBackground\\\":\\\"#f7f1ff0c\\\",\\\"editor.inlineValuesBackground\\\":\\\"#525053\\\",\\\"editor.inlineValuesForeground\\\":\\\"#bab6c0\\\",\\\"editor.lineHighlightBackground\\\":\\\"#f7f1ff0c\\\",\\\"editor.lineHighlightBorder\\\":\\\"#00000000\\\",\\\"editor.linkedEditingBackground\\\":\\\"#363537\\\",\\\"editor.rangeHighlightBackground\\\":\\\"#363537\\\",\\\"editor.rangeHighlightBorder\\\":\\\"#363537\\\",\\\"editor.selectionBackground\\\":\\\"#bab6c026\\\",\\\"editor.selectionHighlightBackground\\\":\\\"#f7f1ff26\\\",\\\"editor.selectionHighlightBorder\\\":\\\"#00000000\\\",\\\"editor.stackFrameHighlightBackground\\\":\\\"#bab6c026\\\",\\\"editor.wordHighlightBackground\\\":\\\"#f7f1ff26\\\",\\\"editor.wordHighlightBorder\\\":\\\"#00000000\\\",\\\"editor.wordHighlightStrongBackground\\\":\\\"#f7f1ff26\\\",\\\"editor.wordHighlightStrongBorder\\\":\\\"#00000000\\\",\\\"editorBracketHighlight.foreground1\\\":\\\"#fc618d\\\",\\\"editorBracketHighlight.foreground2\\\":\\\"#fd9353\\\",\\\"editorBracketHighlight.foreground3\\\":\\\"#fce566\\\",\\\"editorBracketHighlight.foreground4\\\":\\\"#7bd88f\\\",\\\"editorBracketHighlight.foreground5\\\":\\\"#5ad4e6\\\",\\\"editorBracketHighlight.foreground6\\\":\\\"#948ae3\\\",\\\"editorBracketMatch.background\\\":\\\"#222222\\\",\\\"editorBracketMatch.border\\\":\\\"#69676c\\\",\\\"editorCodeLens.foreground\\\":\\\"#69676c\\\",\\\"editorCursor.background\\\":\\\"#222222\\\",\\\"editorCursor.foreground\\\":\\\"#f7f1ff\\\",\\\"editorError.background\\\":\\\"#00000000\\\",\\\"editorError.border\\\":\\\"#00000000\\\",\\\"editorError.foreground\\\":\\\"#fc618d\\\",\\\"editorGhostText.foreground\\\":\\\"#69676c\\\",\\\"editorGroup.border\\\":\\\"#191919\\\",\\\"editorGroup.dropBackground\\\":\\\"#191919bf\\\",\\\"editorGroup.emptyBackground\\\":\\\"#131313\\\",\\\"editorGroup.focusedEmptyBorder\\\":\\\"#191919\\\",\\\"editorGroupHeader.noTabsBackground\\\":\\\"#222222\\\",\\\"editorGroupHeader.tabsBackground\\\":\\\"#222222\\\",\\\"editorGroupHeader.tabsBorder\\\":\\\"#222222\\\",\\\"editorGutter.addedBackground\\\":\\\"#7bd88f\\\",\\\"editorGutter.background\\\":\\\"#222222\\\",\\\"editorGutter.deletedBackground\\\":\\\"#fc618d\\\",\\\"editorGutter.foldingControlForeground\\\":\\\"#bab6c0\\\",\\\"editorGutter.modifiedBackground\\\":\\\"#fd9353\\\",\\\"editorHint.border\\\":\\\"#222222\\\",\\\"editorHint.foreground\\\":\\\"#948ae3\\\",\\\"editorHoverWidget.background\\\":\\\"#363537\\\",\\\"editorHoverWidget.border\\\":\\\"#222222\\\",\\\"editorIndentGuide.background\\\":\\\"#363537\\\",\\\"editorInfo.background\\\":\\\"#00000000\\\",\\\"editorInfo.border\\\":\\\"#222222\\\",\\\"editorInfo.foreground\\\":\\\"#5ad4e6\\\",\\\"editorInlayHint.background\\\":\\\"#363537\\\",\\\"editorInlayHint.foreground\\\":\\\"#8b888f\\\",\\\"editorLightBulb.foreground\\\":\\\"#fce566\\\",\\\"editorLightBulbAi.foreground\\\":\\\"#fce566\\\",\\\"editorLightBulbAutoFix.foreground\\\":\\\"#7bd88f\\\",\\\"editorLineNumber.activeForeground\\\":\\\"#bab6c0\\\",\\\"editorLineNumber.foreground\\\":\\\"#525053\\\",\\\"editorLink.activeForeground\\\":\\\"#5ad4e6\\\",\\\"editorMarkerNavigation.background\\\":\\\"#363537\\\",\\\"editorMarkerNavigationError.background\\\":\\\"#fc618d\\\",\\\"editorMarkerNavigationInfo.background\\\":\\\"#5ad4e6\\\",\\\"editorMarkerNavigationWarning.background\\\":\\\"#fd9353\\\",\\\"editorOverviewRuler.addedForeground\\\":\\\"#7bd88f\\\",\\\"editorOverviewRuler.border\\\":\\\"#222222\\\",\\\"editorOverviewRuler.currentContentForeground\\\":\\\"#363537\\\",\\\"editorOverviewRuler.deletedForeground\\\":\\\"#fc618d\\\",\\\"editorOverviewRuler.errorForeground\\\":\\\"#fc618d\\\",\\\"editorOverviewRuler.findMatchForeground\\\":\\\"#f7f1ff26\\\",\\\"editorOverviewRuler.incomingContentForeground\\\":\\\"#363537\\\",\\\"editorOverviewRuler.infoForeground\\\":\\\"#5ad4e6\\\",\\\"editorOverviewRuler.modifiedForeground\\\":\\\"#fd9353\\\",\\\"editorOverviewRuler.rangeHighlightForeground\\\":\\\"#f7f1ff26\\\",\\\"editorOverviewRuler.selectionHighlightForeground\\\":\\\"#f7f1ff26\\\",\\\"editorOverviewRuler.warningForeground\\\":\\\"#fd9353\\\",\\\"editorOverviewRuler.wordHighlightForeground\\\":\\\"#f7f1ff26\\\",\\\"editorOverviewRuler.wordHighlightStrongForeground\\\":\\\"#f7f1ff26\\\",\\\"editorPane.background\\\":\\\"#222222\\\",\\\"editorRuler.foreground\\\":\\\"#525053\\\",\\\"editorStickyScroll.background\\\":\\\"#222222\\\",\\\"editorStickyScroll.border\\\":\\\"#363537\\\",\\\"editorStickyScroll.shadow\\\":\\\"#222222\\\",\\\"editorStickyScrollHover.background\\\":\\\"#f7f1ff0c\\\",\\\"editorSuggestWidget.background\\\":\\\"#363537\\\",\\\"editorSuggestWidget.border\\\":\\\"#363537\\\",\\\"editorSuggestWidget.foreground\\\":\\\"#bab6c0\\\",\\\"editorSuggestWidget.highlightForeground\\\":\\\"#f7f1ff\\\",\\\"editorSuggestWidget.selectedBackground\\\":\\\"#69676c\\\",\\\"editorUnnecessaryCode.opacity\\\":\\\"#000000a5\\\",\\\"editorWarning.background\\\":\\\"#00000000\\\",\\\"editorWarning.border\\\":\\\"#00000000\\\",\\\"editorWarning.foreground\\\":\\\"#fd9353\\\",\\\"editorWhitespace.foreground\\\":\\\"#525053\\\",\\\"editorWidget.background\\\":\\\"#363537\\\",\\\"editorWidget.border\\\":\\\"#363537\\\",\\\"errorForeground\\\":\\\"#fc618d\\\",\\\"extensionBadge.remoteForeground\\\":\\\"#7bd88f\\\",\\\"extensionButton.prominentBackground\\\":\\\"#363537\\\",\\\"extensionButton.prominentForeground\\\":\\\"#f7f1ff\\\",\\\"extensionButton.prominentHoverBackground\\\":\\\"#525053\\\",\\\"extensionIcon.preReleaseForeground\\\":\\\"#948ae3\\\",\\\"extensionIcon.sponsorForeground\\\":\\\"#5ad4e6\\\",\\\"extensionIcon.starForeground\\\":\\\"#fce566\\\",\\\"extensionIcon.verifiedForeground\\\":\\\"#7bd88f\\\",\\\"focusBorder\\\":\\\"#69676c\\\",\\\"foreground\\\":\\\"#f7f1ff\\\",\\\"gitDecoration.addedResourceForeground\\\":\\\"#7bd88f\\\",\\\"gitDecoration.conflictingResourceForeground\\\":\\\"#fd9353\\\",\\\"gitDecoration.deletedResourceForeground\\\":\\\"#fc618d\\\",\\\"gitDecoration.ignoredResourceForeground\\\":\\\"#525053\\\",\\\"gitDecoration.modifiedResourceForeground\\\":\\\"#fce566\\\",\\\"gitDecoration.stageDeletedResourceForeground\\\":\\\"#fc618d\\\",\\\"gitDecoration.stageModifiedResourceForeground\\\":\\\"#fce566\\\",\\\"gitDecoration.untrackedResourceForeground\\\":\\\"#bab6c0\\\",\\\"icon.foreground\\\":\\\"#8b888f\\\",\\\"inlineChat.background\\\":\\\"#222222\\\",\\\"inlineChat.border\\\":\\\"#191919\\\",\\\"inlineChat.shadow\\\":\\\"#131313\\\",\\\"inlineChatDiff.inserted\\\":\\\"#7bd88f19\\\",\\\"inlineChatDiff.removed\\\":\\\"#7bd88f19\\\",\\\"input.background\\\":\\\"#363537\\\",\\\"input.border\\\":\\\"#363537\\\",\\\"input.foreground\\\":\\\"#f7f1ff\\\",\\\"input.placeholderForeground\\\":\\\"#69676c\\\",\\\"inputOption.activeBackground\\\":\\\"#525053\\\",\\\"inputOption.activeBorder\\\":\\\"#525053\\\",\\\"inputOption.activeForeground\\\":\\\"#f7f1ff\\\",\\\"inputOption.hoverBackground\\\":\\\"#525053\\\",\\\"inputValidation.errorBackground\\\":\\\"#363537\\\",\\\"inputValidation.errorBorder\\\":\\\"#fc618d\\\",\\\"inputValidation.errorForeground\\\":\\\"#fc618d\\\",\\\"inputValidation.infoBackground\\\":\\\"#363537\\\",\\\"inputValidation.infoBorder\\\":\\\"#5ad4e6\\\",\\\"inputValidation.infoForeground\\\":\\\"#5ad4e6\\\",\\\"inputValidation.warningBackground\\\":\\\"#363537\\\",\\\"inputValidation.warningBorder\\\":\\\"#fd9353\\\",\\\"inputValidation.warningForeground\\\":\\\"#fd9353\\\",\\\"interactive.activeCodeBorder\\\":\\\"#69676c\\\",\\\"interactive.inactiveCodeBorder\\\":\\\"#363537\\\",\\\"keybindingLabel.background\\\":\\\"#525053\\\",\\\"keybindingLabel.border\\\":\\\"#525053\\\",\\\"keybindingLabel.bottomBorder\\\":\\\"#363537\\\",\\\"keybindingLabel.foreground\\\":\\\"#bab6c0\\\",\\\"list.activeSelectionBackground\\\":\\\"#f7f1ff0c\\\",\\\"list.activeSelectionForeground\\\":\\\"#fce566\\\",\\\"list.dropBackground\\\":\\\"#191919bf\\\",\\\"list.errorForeground\\\":\\\"#fc618d\\\",\\\"list.focusBackground\\\":\\\"#222222\\\",\\\"list.focusForeground\\\":\\\"#f7f1ff\\\",\\\"list.highlightForeground\\\":\\\"#f7f1ff\\\",\\\"list.hoverBackground\\\":\\\"#f7f1ff0c\\\",\\\"list.hoverForeground\\\":\\\"#f7f1ff\\\",\\\"list.inactiveFocusBackground\\\":\\\"#222222\\\",\\\"list.inactiveSelectionBackground\\\":\\\"#bab6c00c\\\",\\\"list.inactiveSelectionForeground\\\":\\\"#fce566\\\",\\\"list.invalidItemForeground\\\":\\\"#fc618d\\\",\\\"list.warningForeground\\\":\\\"#fd9353\\\",\\\"listFilterWidget.background\\\":\\\"#222222\\\",\\\"listFilterWidget.noMatchesOutline\\\":\\\"#fc618d\\\",\\\"listFilterWidget.outline\\\":\\\"#222222\\\",\\\"listFilterWidget.shadow\\\":\\\"#131313\\\",\\\"menu.background\\\":\\\"#222222\\\",\\\"menu.border\\\":\\\"#191919\\\",\\\"menu.foreground\\\":\\\"#f7f1ff\\\",\\\"menu.selectionForeground\\\":\\\"#fce566\\\",\\\"menu.separatorBackground\\\":\\\"#363537\\\",\\\"menubar.selectionForeground\\\":\\\"#f7f1ff\\\",\\\"merge.border\\\":\\\"#222222\\\",\\\"merge.commonContentBackground\\\":\\\"#f7f1ff19\\\",\\\"merge.commonHeaderBackground\\\":\\\"#f7f1ff26\\\",\\\"merge.currentContentBackground\\\":\\\"#fc618d19\\\",\\\"merge.currentHeaderBackground\\\":\\\"#fc618d26\\\",\\\"merge.incomingContentBackground\\\":\\\"#7bd88f19\\\",\\\"merge.incomingHeaderBackground\\\":\\\"#7bd88f26\\\",\\\"mergeEditor.change.background\\\":\\\"#f7f1ff19\\\",\\\"mergeEditor.change.word.background\\\":\\\"#f7f1ff19\\\",\\\"mergeEditor.conflict.handled.minimapOverViewRuler\\\":\\\"#7bd88f\\\",\\\"mergeEditor.conflict.handledFocused.border\\\":\\\"#7bd88f\\\",\\\"mergeEditor.conflict.handledUnfocused.border\\\":\\\"#7bd88f\\\",\\\"mergeEditor.conflict.unhandled.minimapOverViewRuler\\\":\\\"#fc618d\\\",\\\"mergeEditor.conflict.unhandledFocused.border\\\":\\\"#fc618d\\\",\\\"mergeEditor.conflict.unhandledUnfocused.border\\\":\\\"#fc618d\\\",\\\"minimap.errorHighlight\\\":\\\"#fc618da5\\\",\\\"minimap.findMatchHighlight\\\":\\\"#8b888fa5\\\",\\\"minimap.infoHighlight\\\":\\\"#5ad4e6a5\\\",\\\"minimap.selectionHighlight\\\":\\\"#bab6c026\\\",\\\"minimap.selectionOccurrenceHighlight\\\":\\\"#69676ca5\\\",\\\"minimap.warningHighlight\\\":\\\"#fd9353a5\\\",\\\"minimapGutter.addedBackground\\\":\\\"#7bd88f\\\",\\\"minimapGutter.deletedBackground\\\":\\\"#fc618d\\\",\\\"minimapGutter.modifiedBackground\\\":\\\"#fce566\\\",\\\"notebook.cellBorderColor\\\":\\\"#363537\\\",\\\"notebook.cellEditorBackground\\\":\\\"#1919197f\\\",\\\"notebook.cellInsertionIndicator\\\":\\\"#f7f1ff\\\",\\\"notebook.cellStatusBarItemHoverBackground\\\":\\\"#69676c\\\",\\\"notebook.cellToolbarSeparator\\\":\\\"#363537\\\",\\\"notebook.editorBackground\\\":\\\"#222222\\\",\\\"notebook.focusedEditorBorder\\\":\\\"#69676c\\\",\\\"notebookStatusErrorIcon.foreground\\\":\\\"#fc618d\\\",\\\"notebookStatusRunningIcon.foreground\\\":\\\"#f7f1ff\\\",\\\"notebookStatusSuccessIcon.foreground\\\":\\\"#7bd88f\\\",\\\"notificationCenter.border\\\":\\\"#363537\\\",\\\"notificationCenterHeader.background\\\":\\\"#363537\\\",\\\"notificationCenterHeader.foreground\\\":\\\"#8b888f\\\",\\\"notificationLink.foreground\\\":\\\"#fce566\\\",\\\"notifications.background\\\":\\\"#363537\\\",\\\"notifications.border\\\":\\\"#363537\\\",\\\"notifications.foreground\\\":\\\"#bab6c0\\\",\\\"notificationsErrorIcon.foreground\\\":\\\"#fc618d\\\",\\\"notificationsInfoIcon.foreground\\\":\\\"#5ad4e6\\\",\\\"notificationsWarningIcon.foreground\\\":\\\"#fd9353\\\",\\\"notificationToast.border\\\":\\\"#363537\\\",\\\"panel.background\\\":\\\"#363537\\\",\\\"panel.border\\\":\\\"#222222\\\",\\\"panel.dropBackground\\\":\\\"#191919bf\\\",\\\"panelStickyScroll.background\\\":\\\"#363537\\\",\\\"panelStickyScroll.border\\\":\\\"#ff0000\\\",\\\"panelStickyScroll.shadow\\\":\\\"#363537\\\",\\\"panelTitle.activeBorder\\\":\\\"#fce566\\\",\\\"panelTitle.activeForeground\\\":\\\"#fce566\\\",\\\"panelTitle.inactiveForeground\\\":\\\"#8b888f\\\",\\\"peekView.border\\\":\\\"#222222\\\",\\\"peekViewEditor.background\\\":\\\"#363537\\\",\\\"peekViewEditor.matchHighlightBackground\\\":\\\"#525053\\\",\\\"peekViewEditorGutter.background\\\":\\\"#363537\\\",\\\"peekViewResult.background\\\":\\\"#363537\\\",\\\"peekViewResult.fileForeground\\\":\\\"#8b888f\\\",\\\"peekViewResult.lineForeground\\\":\\\"#8b888f\\\",\\\"peekViewResult.matchHighlightBackground\\\":\\\"#525053\\\",\\\"peekViewResult.selectionBackground\\\":\\\"#363537\\\",\\\"peekViewResult.selectionForeground\\\":\\\"#f7f1ff\\\",\\\"peekViewTitle.background\\\":\\\"#363537\\\",\\\"peekViewTitleDescription.foreground\\\":\\\"#8b888f\\\",\\\"peekViewTitleLabel.foreground\\\":\\\"#f7f1ff\\\",\\\"pickerGroup.border\\\":\\\"#222222\\\",\\\"pickerGroup.foreground\\\":\\\"#525053\\\",\\\"ports.iconRunningProcessForeground\\\":\\\"#7bd88f\\\",\\\"problemsErrorIcon.foreground\\\":\\\"#fc618d\\\",\\\"problemsInfoIcon.foreground\\\":\\\"#5ad4e6\\\",\\\"problemsWarningIcon.foreground\\\":\\\"#fd9353\\\",\\\"profileBadge.background\\\":\\\"#363537\\\",\\\"profileBadge.foreground\\\":\\\"#bab6c0\\\",\\\"progressBar.background\\\":\\\"#69676c\\\",\\\"sash.hoverBorder\\\":\\\"#69676c\\\",\\\"scrollbar.shadow\\\":\\\"#222222\\\",\\\"scrollbarSlider.activeBackground\\\":\\\"#f7f1ff59\\\",\\\"scrollbarSlider.background\\\":\\\"#bab6c026\\\",\\\"scrollbarSlider.hoverBackground\\\":\\\"#f7f1ff26\\\",\\\"selection.background\\\":\\\"#bab6c026\\\",\\\"settings.checkboxBackground\\\":\\\"#363537\\\",\\\"settings.checkboxBorder\\\":\\\"#363537\\\",\\\"settings.checkboxForeground\\\":\\\"#f7f1ff\\\",\\\"settings.dropdownBackground\\\":\\\"#363537\\\",\\\"settings.dropdownBorder\\\":\\\"#363537\\\",\\\"settings.dropdownForeground\\\":\\\"#f7f1ff\\\",\\\"settings.dropdownListBorder\\\":\\\"#8b888f\\\",\\\"settings.headerForeground\\\":\\\"#fce566\\\",\\\"settings.modifiedItemForeground\\\":\\\"#fce566\\\",\\\"settings.modifiedItemIndicator\\\":\\\"#fce566\\\",\\\"settings.numberInputBackground\\\":\\\"#363537\\\",\\\"settings.numberInputBorder\\\":\\\"#363537\\\",\\\"settings.numberInputForeground\\\":\\\"#f7f1ff\\\",\\\"settings.rowHoverBackground\\\":\\\"#69676c0c\\\",\\\"settings.sashBorder\\\":\\\"#363537\\\",\\\"settings.settingsHeaderHoverForeground\\\":\\\"#f7f1ff\\\",\\\"settings.textInputBackground\\\":\\\"#363537\\\",\\\"settings.textInputBorder\\\":\\\"#363537\\\",\\\"settings.textInputForeground\\\":\\\"#f7f1ff\\\",\\\"sideBar.background\\\":\\\"#191919\\\",\\\"sideBar.border\\\":\\\"#131313\\\",\\\"sideBar.dropBackground\\\":\\\"#191919bf\\\",\\\"sideBar.foreground\\\":\\\"#8b888f\\\",\\\"sideBarSectionHeader.background\\\":\\\"#191919\\\",\\\"sideBarSectionHeader.foreground\\\":\\\"#69676c\\\",\\\"sideBarStickyScroll.background\\\":\\\"#191919\\\",\\\"sideBarStickyScroll.border\\\":\\\"#363537\\\",\\\"sideBarStickyScroll.shadow\\\":\\\"#191919\\\",\\\"sideBarTitle.foreground\\\":\\\"#525053\\\",\\\"simpleFindWidget.sashBorder\\\":\\\"#ff0000\\\",\\\"statusBar.background\\\":\\\"#191919\\\",\\\"statusBar.border\\\":\\\"#131313\\\",\\\"statusBar.debuggingBackground\\\":\\\"#69676c\\\",\\\"statusBar.debuggingBorder\\\":\\\"#191919\\\",\\\"statusBar.debuggingForeground\\\":\\\"#f7f1ff\\\",\\\"statusBar.focusBorder\\\":\\\"#363537\\\",\\\"statusBar.foreground\\\":\\\"#69676c\\\",\\\"statusBar.noFolderBackground\\\":\\\"#191919\\\",\\\"statusBar.noFolderBorder\\\":\\\"#131313\\\",\\\"statusBar.noFolderForeground\\\":\\\"#69676c\\\",\\\"statusBarItem.activeBackground\\\":\\\"#222222\\\",\\\"statusBarItem.errorBackground\\\":\\\"#222222\\\",\\\"statusBarItem.errorForeground\\\":\\\"#fc618d\\\",\\\"statusBarItem.focusBorder\\\":\\\"#69676c\\\",\\\"statusBarItem.hoverBackground\\\":\\\"#f7f1ff0c\\\",\\\"statusBarItem.prominentBackground\\\":\\\"#363537\\\",\\\"statusBarItem.offlineBackground\\\":\\\"#ff0000\\\",\\\"statusBarItem.offlineForeground\\\":\\\"#ff0000\\\",\\\"statusBarItem.prominentHoverBackground\\\":\\\"#363537\\\",\\\"statusBarItem.remoteBackground\\\":\\\"#191919\\\",\\\"statusBarItem.remoteForeground\\\":\\\"#7bd88f\\\",\\\"statusBarItem.warningBackground\\\":\\\"#222222\\\",\\\"statusBarItem.warningForeground\\\":\\\"#fd9353\\\",\\\"symbolIcon.arrayForeground\\\":\\\"#fc618d\\\",\\\"symbolIcon.booleanForeground\\\":\\\"#fc618d\\\",\\\"symbolIcon.classForeground\\\":\\\"#5ad4e6\\\",\\\"symbolIcon.colorForeground\\\":\\\"#948ae3\\\",\\\"symbolIcon.constantForeground\\\":\\\"#948ae3\\\",\\\"symbolIcon.constructorForeground\\\":\\\"#7bd88f\\\",\\\"symbolIcon.enumeratorForeground\\\":\\\"#fd9353\\\",\\\"symbolIcon.enumeratorMemberForeground\\\":\\\"#fd9353\\\",\\\"symbolIcon.eventForeground\\\":\\\"#fd9353\\\",\\\"symbolIcon.fieldForeground\\\":\\\"#fd9353\\\",\\\"symbolIcon.fileForeground\\\":\\\"#bab6c0\\\",\\\"symbolIcon.folderForeground\\\":\\\"#bab6c0\\\",\\\"symbolIcon.functionForeground\\\":\\\"#7bd88f\\\",\\\"symbolIcon.interfaceForeground\\\":\\\"#5ad4e6\\\",\\\"symbolIcon.keyForeground\\\":\\\"#fd9353\\\",\\\"symbolIcon.keywordForeground\\\":\\\"#fc618d\\\",\\\"symbolIcon.methodForeground\\\":\\\"#7bd88f\\\",\\\"symbolIcon.moduleForeground\\\":\\\"#5ad4e6\\\",\\\"symbolIcon.namespaceForeground\\\":\\\"#5ad4e6\\\",\\\"symbolIcon.nullForeground\\\":\\\"#948ae3\\\",\\\"symbolIcon.numberForeground\\\":\\\"#948ae3\\\",\\\"symbolIcon.objectForeground\\\":\\\"#5ad4e6\\\",\\\"symbolIcon.operatorForeground\\\":\\\"#fc618d\\\",\\\"symbolIcon.packageForeground\\\":\\\"#948ae3\\\",\\\"symbolIcon.propertyForeground\\\":\\\"#fd9353\\\",\\\"symbolIcon.referenceForeground\\\":\\\"#948ae3\\\",\\\"symbolIcon.snippetForeground\\\":\\\"#7bd88f\\\",\\\"symbolIcon.stringForeground\\\":\\\"#fce566\\\",\\\"symbolIcon.structForeground\\\":\\\"#fc618d\\\",\\\"symbolIcon.textForeground\\\":\\\"#fce566\\\",\\\"symbolIcon.typeParameterForeground\\\":\\\"#fd9353\\\",\\\"symbolIcon.unitForeground\\\":\\\"#948ae3\\\",\\\"symbolIcon.variableForeground\\\":\\\"#5ad4e6\\\",\\\"tab.activeBackground\\\":\\\"#222222\\\",\\\"tab.activeBorder\\\":\\\"#fce566\\\",\\\"tab.activeForeground\\\":\\\"#fce566\\\",\\\"tab.activeModifiedBorder\\\":\\\"#525053\\\",\\\"tab.border\\\":\\\"#222222\\\",\\\"tab.hoverBackground\\\":\\\"#222222\\\",\\\"tab.hoverBorder\\\":\\\"#525053\\\",\\\"tab.hoverForeground\\\":\\\"#f7f1ff\\\",\\\"tab.inactiveBackground\\\":\\\"#222222\\\",\\\"tab.inactiveForeground\\\":\\\"#8b888f\\\",\\\"tab.inactiveModifiedBorder\\\":\\\"#525053\\\",\\\"tab.lastPinnedBorder\\\":\\\"#525053\\\",\\\"tab.unfocusedActiveBorder\\\":\\\"#8b888f\\\",\\\"tab.unfocusedActiveForeground\\\":\\\"#bab6c0\\\",\\\"tab.unfocusedActiveModifiedBorder\\\":\\\"#363537\\\",\\\"tab.unfocusedHoverBackground\\\":\\\"#222222\\\",\\\"tab.unfocusedHoverBorder\\\":\\\"#222222\\\",\\\"tab.unfocusedHoverForeground\\\":\\\"#bab6c0\\\",\\\"tab.unfocusedInactiveForeground\\\":\\\"#8b888f\\\",\\\"tab.unfocusedInactiveModifiedBorder\\\":\\\"#363537\\\",\\\"terminal.ansiBlack\\\":\\\"#363537\\\",\\\"terminal.ansiBlue\\\":\\\"#fd9353\\\",\\\"terminal.ansiBrightBlack\\\":\\\"#69676c\\\",\\\"terminal.ansiBrightBlue\\\":\\\"#fd9353\\\",\\\"terminal.ansiBrightCyan\\\":\\\"#5ad4e6\\\",\\\"terminal.ansiBrightGreen\\\":\\\"#7bd88f\\\",\\\"terminal.ansiBrightMagenta\\\":\\\"#948ae3\\\",\\\"terminal.ansiBrightRed\\\":\\\"#fc618d\\\",\\\"terminal.ansiBrightWhite\\\":\\\"#f7f1ff\\\",\\\"terminal.ansiBrightYellow\\\":\\\"#fce566\\\",\\\"terminal.ansiCyan\\\":\\\"#5ad4e6\\\",\\\"terminal.ansiGreen\\\":\\\"#7bd88f\\\",\\\"terminal.ansiMagenta\\\":\\\"#948ae3\\\",\\\"terminal.ansiRed\\\":\\\"#fc618d\\\",\\\"terminal.ansiWhite\\\":\\\"#f7f1ff\\\",\\\"terminal.ansiYellow\\\":\\\"#fce566\\\",\\\"terminal.background\\\":\\\"#363537\\\",\\\"terminal.foreground\\\":\\\"#f7f1ff\\\",\\\"terminal.selectionBackground\\\":\\\"#f7f1ff26\\\",\\\"terminalCommandDecoration.defaultBackground\\\":\\\"#f7f1ff\\\",\\\"terminalCommandDecoration.errorBackground\\\":\\\"#fc618d\\\",\\\"terminalCommandDecoration.successBackground\\\":\\\"#7bd88f\\\",\\\"terminalCursor.background\\\":\\\"#00000000\\\",\\\"terminalCursor.foreground\\\":\\\"#f7f1ff\\\",\\\"testing.iconErrored\\\":\\\"#fc618d\\\",\\\"testing.iconFailed\\\":\\\"#fc618d\\\",\\\"testing.iconPassed\\\":\\\"#7bd88f\\\",\\\"testing.iconQueued\\\":\\\"#f7f1ff\\\",\\\"testing.iconSkipped\\\":\\\"#fd9353\\\",\\\"testing.iconUnset\\\":\\\"#8b888f\\\",\\\"testing.message.error.decorationForeground\\\":\\\"#fc618d\\\",\\\"testing.message.error.lineBackground\\\":\\\"#fc618d19\\\",\\\"testing.message.info.decorationForeground\\\":\\\"#f7f1ff\\\",\\\"testing.message.info.lineBackground\\\":\\\"#f7f1ff19\\\",\\\"testing.runAction\\\":\\\"#fce566\\\",\\\"textBlockQuote.background\\\":\\\"#363537\\\",\\\"textBlockQuote.border\\\":\\\"#363537\\\",\\\"textCodeBlock.background\\\":\\\"#363537\\\",\\\"textLink.activeForeground\\\":\\\"#f7f1ff\\\",\\\"textLink.foreground\\\":\\\"#fce566\\\",\\\"textPreformat.foreground\\\":\\\"#f7f1ff\\\",\\\"textSeparator.foreground\\\":\\\"#69676c\\\",\\\"titleBar.activeBackground\\\":\\\"#191919\\\",\\\"titleBar.activeForeground\\\":\\\"#8b888f\\\",\\\"titleBar.border\\\":\\\"#131313\\\",\\\"titleBar.inactiveBackground\\\":\\\"#191919\\\",\\\"titleBar.inactiveForeground\\\":\\\"#525053\\\",\\\"tree.inactiveIndentGuidesStroke\\\":\\\"#222222\\\",\\\"tree.indentGuidesStroke\\\":\\\"#363537\\\",\\\"walkThrough.embeddedEditorBackground\\\":\\\"#191919\\\",\\\"welcomePage.buttonBackground\\\":\\\"#363537\\\",\\\"welcomePage.buttonHoverBackground\\\":\\\"#525053\\\",\\\"welcomePage.progress.background\\\":\\\"#69676c\\\",\\\"welcomePage.progress.foreground\\\":\\\"#8b888f\\\",\\\"welcomePage.tileBackground\\\":\\\"#363537\\\",\\\"welcomePage.tileHoverBackground\\\":\\\"#525053\\\",\\\"welcomePage.tileShadow\\\":\\\"#131313\\\",\\\"widget.shadow\\\":\\\"#131313\\\"},\\\"watch\\\":false}\",\"nps/lastSessionDate\":\"Fri Sep 13 2024\",\"nps/sessionCount\":\"199\",\"cpp.1.lastSessionDate\":\"Wed Feb 01 2023\",\"cpp.1.sessionCount\":\"37\",\"java.2.lastSessionDate\":\"Wed Oct 02 2024\",\"java.2.sessionCount\":\"210\",\"javascript.1.lastSessionDate\":\"Wed Oct 02 2024\",\"javascript.1.sessionCount\":\"210\",\"typescript.1.lastSessionDate\":\"Wed Oct 02 2024\",\"typescript.1.sessionCount\":\"210\",\"csharp.1.lastSessionDate\":\"Wed Oct 02 2024\",\"csharp.1.sessionCount\":\"164\",\"~remote.forwardedPortsContainer.hidden\":\"[{\\\"id\\\":\\\"~remote.forwardedPorts\\\",\\\"isHidden\\\":false}]\",\"workbench.telemetryOptOutShown\":\"true\",\"memento/gettingStartedService\":\"{\\\"pickColorTheme\\\":{\\\"done\\\":true},\\\"pickColorThemeWeb\\\":{\\\"done\\\":true},\\\"settingsSync\\\":{\\\"done\\\":true},\\\"settingsSyncWeb\\\":{\\\"done\\\":true},\\\"GitHub.copilot#copilotWelcome#copilot.signin\\\":{\\\"done\\\":true},\\\"ms-vscode-remote.remote-wsl#wslWalkthrough#install.tools\\\":{\\\"done\\\":true},\\\"pickAFolderTask-Other\\\":{\\\"done\\\":true},\\\"ms-azuretools.vscode-docker#dockerStart#openFolder\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#no.compilers.found.windows\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#create.cpp.file\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#awaiting.activation.mac\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#awaiting.activation.linux\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#awaiting.activation.windows\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#no.compilers.found.mac\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#no.compilers.found.linux\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#verify.compiler.mac\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#verify.compiler.linux\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#verify.compiler.windows\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#relaunch.developer.command.prompt.windows\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#run.project.mac\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#run.project.linux\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#run.project.windows\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#customize.debugging.linux\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#customize.debugging.windows\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#customize.debugging.mac\\\":{\\\"done\\\":true},\\\"commandPaletteTask\\\":{\\\"done\\\":true},\\\"commandPaletteTaskWeb\\\":{\\\"done\\\":true},\\\"installGit\\\":{\\\"done\\\":true},\\\"ms-vscode-remote.remote-wsl#wslWalkthrough#explore.commands\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#verify.compiler.windows10\\\":{\\\"done\\\":true},\\\"ms-vscode.cpptools#cppWelcome#verify.compiler.windows11\\\":{\\\"done\\\":true}}\",\"workbench.statusbar.hidden\":\"[\\\"status.workspaceTrust.1647839407427\\\",\\\"status.workspaceTrust.ec4782d37bdb198420b1367fe5b2c4f0\\\",\\\"status.workspaceTrust.1648094474591\\\",\\\"status.workspaceTrust.1655714609191\\\",\\\"status.workspaceTrust.1664766271860\\\",\\\"status.workspaceTrust.1660642459864\\\",\\\"status.workspaceTrust.4ce84f1e37e50028e855d15b1b9879c6\\\",\\\"status.workspaceTrust.1667913452044\\\",\\\"status.workspaceTrust.1668248555285\\\",\\\"status.workspaceTrust.1668257094741\\\",\\\"status.workspaceTrust.065df74bb0001411f0faeddd7f6154df\\\",\\\"status.workspaceTrust.0e3b828bb7e4ad2566b6d1ac2694e840\\\",\\\"status.workspaceTrust.1681559787142\\\",\\\"status.workspaceTrust.1685782198408\\\",\\\"status.workspaceTrust.1687868575692\\\",\\\"status.workspaceTrust.1689386040346\\\",\\\"status.workspaceTrust.1690970239670\\\",\\\"status.workspaceTrust.1694357037411\\\",\\\"status.workspaceTrust.1696866504520\\\",\\\"status.workspaceTrust.1696866504834\\\",\\\"status.workspaceTrust.45e8b4474497bf8af05068b06d28325e\\\",\\\"status.workspaceTrust.1697293430770\\\",\\\"status.workspaceTrust.22c41b0d76b473f107383b5cf3807fe8\\\",\\\"status.workspaceTrust.1697600032563\\\",\\\"status.workspaceTrust.1697600054358\\\",\\\"status.workspaceTrust.1697623998913\\\",\\\"status.workspaceTrust.1697901776935\\\",\\\"status.workspaceTrust.1700209308966\\\",\\\"status.workspaceTrust.1701419075697\\\",\\\"status.workspaceTrust.1701829919637\\\",\\\"status.workspaceTrust.1704194479743\\\",\\\"status.workspaceTrust.1705312983525\\\",\\\"status.workspaceTrust.1707832617085\\\",\\\"status.workspaceTrust.1708343644931\\\",\\\"status.workspaceTrust.1708398252575\\\",\\\"status.workspaceTrust.1708858109713\\\",\\\"status.workspaceTrust.1709828165106\\\",\\\"status.workspaceTrust.1709828704923\\\"]\",\"themeUpdatedNotificationShown\":\"true\",\"workbench.view.extensions.state.hidden\":\"[{\\\"id\\\":\\\"workbench.views.extensions.installed\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.workspaceRecommendations\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.popular\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.otherRecommendations\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"extensions.recommendedList\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.enabled\\\",\\\"isHidden\\\":true},{\\\"id\\\":\\\"workbench.views.extensions.disabled\\\",\\\"isHidden\\\":true},{\\\"id\\\":\\\"workbench.views.extensions.marketplace\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.searchInstalled\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.searchEnabled\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.searchDisabled\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.searchOutdated\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.searchBuiltin\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.searchWorkspaceUnsupported\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.builtinFeatureExtensions\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.builtinThemeExtensions\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.builtinProgrammingLanguageExtensions\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.untrustedUnsupportedExtensions\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.untrustedPartiallySupportedExtensions\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.virtualUnsupportedExtensions\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.virtualPartiallySupportedExtensions\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.deprecatedExtensions\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.searchRecentlyUpdated\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.local.installed\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.views.extensions.remote.installed\\\",\\\"isHidden\\\":false}]\",\"workbench.welcomePage.walkthroughMetadata\":\"[[\\\"alefragnani.Bookmarks#bookmarksWelcome\\\",{\\\"firstSeen\\\":1696867188753,\\\"stepIDs\\\":[\\\"toggle\\\",\\\"navigateToBookmarks\\\",\\\"defineLabelsForYourBookmarks\\\",\\\"exclusiveSideBar\\\",\\\"workingWithRemotes\\\",\\\"customizingAppearance\\\"],\\\"manaullyOpened\\\":false}],[\\\"GitHub.copilot#copilotWelcome\\\",{\\\"firstSeen\\\":1696867188753,\\\"stepIDs\\\":[\\\"copilot.signin\\\",\\\"copilot.firstsuggest\\\",\\\"copilot.realfiles.openrecent\\\",\\\"copilot.realfiles.quickopen\\\",\\\"copilot.iterate\\\",\\\"copilot.creativity\\\"],\\\"manaullyOpened\\\":false}],[\\\"ms-azuretools.vscode-docker#dockerStart\\\",{\\\"firstSeen\\\":1696867188753,\\\"stepIDs\\\":[\\\"openFolder\\\",\\\"openFolderMac\\\",\\\"scaffold\\\",\\\"buildImage\\\",\\\"runContainer\\\",\\\"dockerExplorer\\\",\\\"pushImage\\\",\\\"azDeploy\\\",\\\"learn\\\"],\\\"manaullyOpened\\\":false}],[\\\"ms-vscode-remote.remote-wsl#wslWalkthrough\\\",{\\\"firstSeen\\\":1696867188753,\\\"stepIDs\\\":[\\\"explore.commands\\\",\\\"open.wslwindow\\\",\\\"create.project\\\",\\\"open.project\\\",\\\"linux.environment\\\",\\\"install.tools\\\",\\\"run.debug\\\",\\\"come.back\\\"],\\\"manaullyOpened\\\":false}],[\\\"ms-vscode.cpptools#cppWelcome\\\",{\\\"firstSeen\\\":1696867188753,\\\"stepIDs\\\":[\\\"awaiting.activation.mac\\\",\\\"awaiting.activation.linux\\\",\\\"awaiting.activation.windows\\\",\\\"no.compilers.found.mac\\\",\\\"no.compilers.found.linux\\\",\\\"no.compilers.found.windows\\\",\\\"verify.compiler.mac\\\",\\\"verify.compiler.linux\\\",\\\"verify.compiler.windows\\\",\\\"create.cpp.file\\\",\\\"relaunch.developer.command.prompt.windows\\\",\\\"run.project.mac\\\",\\\"run.project.linux\\\",\\\"run.project.windows\\\",\\\"customize.debugging.linux\\\",\\\"customize.debugging.windows\\\",\\\"customize.debugging.mac\\\"],\\\"manaullyOpened\\\":false}],[\\\"ms-python.python#pythonWelcome\\\",{\\\"firstSeen\\\":1720636472690,\\\"stepIDs\\\":[\\\"python.createPythonFolder\\\",\\\"python.createPythonFile\\\",\\\"python.installPythonWin8\\\",\\\"python.installPythonMac\\\",\\\"python.installPythonLinux\\\",\\\"python.createEnvironment\\\",\\\"python.runAndDebug\\\",\\\"python.learnMoreWithDS\\\"],\\\"manaullyOpened\\\":false}],[\\\"ms-python.python#pythonDataScienceWelcome\\\",{\\\"firstSeen\\\":1720636472690,\\\"stepIDs\\\":[\\\"python.installJupyterExt\\\",\\\"python.createNewNotebook\\\",\\\"python.openInteractiveWindow\\\",\\\"python.dataScienceLearnMore\\\"],\\\"manaullyOpened\\\":false}]]\",\"ces/skipSurvey\":\"1.65.2\",\"workbench.panel.alignment\":\"center\",\"fileBasedRecommendations/promptedRecommendations\":\"{\\\"cpp\\\":[\\\"ms-vscode.cpptools-extension-pack\\\"],\\\"dockercompose\\\":[\\\"ms-azuretools.vscode-docker\\\"]}\",\"workbench.view.remote.state.hidden\":\"[{\\\"id\\\":\\\"targetsContainers\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"detailsContainers\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"devVolumes\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"sshHosts\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"targetsWsl\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"remoteTargets\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"~remote.helpPanel\\\",\\\"isHidden\\\":false}]\",\"remote.explorerType\":\"wsl\",\"fileBasedRecommendations/promptedFileExtensions\":\"[\\\"out\\\",\\\"inp\\\"]\",\"cpp.1.editedCount\":\"10\",\"cpp.1.editedDate\":\"Tue Jan 31 2023\",\"commandPalette.mru.cache\":\"{\\\"usesLRU\\\":true,\\\"entries\\\":[{\\\"key\\\":\\\"bookmarks.toggle\\\",\\\"value\\\":3},{\\\"key\\\":\\\"npm-script.run\\\",\\\"value\\\":5},{\\\"key\\\":\\\"snippet.find\\\",\\\"value\\\":8},{\\\"key\\\":\\\"workbench.action.replaceInFiles\\\",\\\"value\\\":9},{\\\"key\\\":\\\"editor.action.insertSnippet\\\",\\\"value\\\":11},{\\\"key\\\":\\\"editor.action.rename\\\",\\\"value\\\":14},{\\\"key\\\":\\\"workbench.action.terminal.rename\\\",\\\"value\\\":15},{\\\"key\\\":\\\"vscode-debug-visualizer.new-visualizer\\\",\\\"value\\\":20},{\\\"key\\\":\\\"workbench.action.chat.nextCodeBlock\\\",\\\"value\\\":29},{\\\"key\\\":\\\"C_Cpp.ConfigurationEditJSON\\\",\\\"value\\\":31},{\\\"key\\\":\\\"workbench.action.toggleKeybindingsLog\\\",\\\"value\\\":33},{\\\"key\\\":\\\"workbench.action.terminal.toggleTerminal\\\",\\\"value\\\":96},{\\\"key\\\":\\\"editor.action.toggleWordWrap\\\",\\\"value\\\":103},{\\\"key\\\":\\\"workbench.action.terminal.clear\\\",\\\"value\\\":117},{\\\"key\\\":\\\"workbench.action.openGlobalKeybindings\\\",\\\"value\\\":119},{\\\"key\\\":\\\"background.config\\\",\\\"value\\\":134},{\\\"key\\\":\\\"monokai_pro.select_theme\\\",\\\"value\\\":140},{\\\"key\\\":\\\"bracket-pair-color-dlw.run\\\",\\\"value\\\":142},{\\\"key\\\":\\\"vscode-icons.activateIcons\\\",\\\"value\\\":149},{\\\"key\\\":\\\"material-icon-theme.activateIcons\\\",\\\"value\\\":152},{\\\"key\\\":\\\"editor.action.formatDocument\\\",\\\"value\\\":190},{\\\"key\\\":\\\"editor.action.formatDocument.multiple\\\",\\\"value\\\":193},{\\\"key\\\":\\\"workbench.action.openGlobalKeybindingsFile\\\",\\\"value\\\":215},{\\\"key\\\":\\\"C_Cpp.DisableErrorSquiggles\\\",\\\"value\\\":224},{\\\"key\\\":\\\"codesnap.start\\\",\\\"value\\\":230},{\\\"key\\\":\\\"C_Cpp.ConfigurationEditUI\\\",\\\"value\\\":247},{\\\"key\\\":\\\"editor.action.formatSelection\\\",\\\"value\\\":248},{\\\"key\\\":\\\"editor.action.unicodeHighlight.showExcludeOptions\\\",\\\"value\\\":249},{\\\"key\\\":\\\"C_Cpp.BuildAndDebugFile\\\",\\\"value\\\":252},{\\\"key\\\":\\\"snippet-generator.generate-snippet\\\",\\\"value\\\":255},{\\\"key\\\":\\\"workbench.action.openSnippets\\\",\\\"value\\\":256},{\\\"key\\\":\\\"C_Cpp.EnableErrorSquiggles\\\",\\\"value\\\":257},{\\\"key\\\":\\\"workbench.action.openSettings2\\\",\\\"value\\\":258},{\\\"key\\\":\\\"workbench.action.openSettingsJson\\\",\\\"value\\\":259},{\\\"key\\\":\\\"C_Cpp.SelectIntelliSenseConfiguration\\\",\\\"value\\\":261}]}\",\"commandPalette.mru.counter\":\"262\",\"workbench.view.extension.bookmarks.state.hidden\":\"[{\\\"id\\\":\\\"bookmarksExplorer\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"bookmarksHelpAndFeedback\\\",\\\"isHidden\\\":false}]\",\"memento/workbench.editor.keybindings\":\"{\\\"searchHistory\\\":[\\\"@command:bookmarks.toggle\\\",\\\"@command:bookm\\\",\\\"runc\\\",\\\"\\\\\\\"ctrl+b\\\\\\\"\\\",\\\"ru\\\",\\\"runcode\\\",\\\"\\\\\\\"ctrl+shift+h\\\\\\\"\\\",\\\"\\\\\\\"ctr\\\",\\\"f\\\",\\\"ctrl sh\\\",\\\"ctrl shift m\\\",\\\"ctrl al\\\",\\\"ctrl alt \\\",\\\"ctrl alt shift \\\",\\\"ctrl alt shift j\\\",\\\"f2\\\",\\\"renam\\\",\\\"ctr\\\",\\\"ctrl '\\\",\\\"@command:workbench.action.openSnippets\\\",\\\"rename\\\",\\\"ctrl f2\\\",\\\"inline.su\\\",\\\"inline.sugg\\\",\\\"inline.suggt\\\",\\\"inline.sugg\\\",\\\"inline.suggest\\\",\\\"alt + \\\",\\\"alt +u\\\",\\\"alt +up\\\",\\\"\\\\\\\"ctrl+shift+up\\\\\\\"\\\",\\\"\\\\\\\"\\\",\\\"\\\\\\\"a\\\",\\\"alt+upa\\\",\\\"alt+uparr\\\",\\\"alt+uparrow\\\",\\\"\\\\\\\"ctrl+shift+down\\\\\\\"\\\",\\\"aldp\\\",\\\"alt+down\\\",\\\"\\\\\\\"ct\\\",\\\"\\\\\\\"ctrl\\\\\\\"\\\",\\\"\\\\\\\"c\\\",\\\"ct\\\",\\\"\\\\\\\"alt\\\\\\\"\\\",\\\"at\\\",\\\"multi\\\",\\\"r\\\",\\\"row\\\",\\\"mu\\\",\\\"mul\\\",\\\"multil\\\",\\\"multiline\\\",\\\"multip\\\",\\\"multiple line\\\",\\\"multiple\\\",\\\"al\\\",\\\"alt\\\",\\\"copyLinesDownAction\\\",\\\"\\\\\\\"ctrl+shift+d\\\\\\\"\\\",\\\"shift a\\\",\\\"shift alt \\\",\\\"shift alt down\\\",\\\"pointer\\\",\\\"mouse\\\",\\\"stop\\\",\\\"stop code\\\",\\\"ctrl b\\\",\\\"ctrl + k\\\",\\\"ctrl k\\\",\\\"ctrl shif\\\",\\\"ctrl shift\\\",\\\"ctrl shift en\\\",\\\"ctrl shift enter\\\",\\\"ne\\\",\\\"inser\\\",\\\"insert line \\\",\\\"insert line below\\\",\\\"du\\\",\\\"dupi\\\",\\\"line\\\",\\\"copy\\\",\\\"copy line d\\\",\\\"copy line down\\\",\\\"@ext:GitHub.copilot\\\",\\\"ctrl\\\",\\\"ctrl s\\\",\\\"copli\\\",\\\"cp;\\\",\\\"c\\\",\\\"copl\\\",\\\"cop\\\",\\\"@command:workbench.action.terminal.clear +when:terminalHasBeenCreated || terminalProcessSupported\\\",\\\"ctrl \\\",\\\"ctrl + p\\\",\\\"@command:C_Cpp.DisableErrorSquiggles\\\",\\\"copi\\\",\\\"copilot\\\",\\\"EnableErrorSquiggles\\\",\\\"@command:workbench.action.openSettings2\\\",\\\"@command:C_Cpp.EnableErrorSquiggles\\\"]}\",\"workbench.view.extension.code-time-sidebar.state.hidden\":\"[{\\\"id\\\":\\\"codetime.webView\\\",\\\"isHidden\\\":false}]\",\"refactorPreview.hidden\":\"[{\\\"id\\\":\\\"refactorPreview\\\",\\\"isHidden\\\":false}]\",\"workbench.view.extension.tabnine-access.state.hidden\":\"[{\\\"id\\\":\\\"tabnine-today\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"tabnine-home\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"tabnine-notifications\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"tabnine.chat\\\",\\\"isHidden\\\":false}]\",\"github-marvinthang\":\"[{\\\"id\\\":\\\"github.copilot\\\",\\\"name\\\":\\\"GitHub Copilot\\\",\\\"allowed\\\":true},{\\\"id\\\":\\\"github.copilot-labs\\\",\\\"name\\\":\\\"GitHub Copilot Labs\\\",\\\"allowed\\\":true}]\",\"nps/isCandidate\":\"false\",\"Comments.hidden\":\"[{\\\"id\\\":\\\"workbench.panel.comments\\\",\\\"isHidden\\\":false}]\",\"snippets.usageTimestamps\":\"[[\\\"MATRIX.code-snippets/MATRIX\\\",1665740167877],[\\\"DEBUGGER.code-snippets/DEBUGGER\\\",1665800530574],[\\\"DINIC_FLOW.code-snippets/DINIC_FLOW\\\",1665800592607],[\\\"DISJOINT_SPARSE_TABLE.code-snippets/DISJOINT_SPARSE_TABLE\\\",1665800716392],[\\\"EDMONDS_KARP.code-snippets/EDMONDS_KARP\\\",1665800865993],[\\\"FAST_FOURIER_TRANSFORM.code-snippets/FAST_FOURIER_TRANSFORM\\\",1665800933488],[\\\"FASTIO.code-snippets/FASTIO\\\",1665800974942],[\\\"FENWICK.code-snippets/FENWICK\\\",1665801020647],[\\\"GAUSS_ELIMINATION.code-snippets/GAUSS_ELIMINATION\\\",1665801082267],[\\\"HASHING.code-snippets/HASHING\\\",1665801670764],[\\\"MAX_FLOW_PVH.code-snippets/MAX_FLOW_PVH\\\",1665801755587],[\\\"MAXMIN.code-snippets/MAXMIN\\\",1665802369456],[\\\"MIN_COST.code-snippets/MIN_COST\\\",1665802426694],[\\\"PARTIALLY_PERSISTENT_DSU.code-snippets/PARTIALLY_PERSISTENT_DSU\\\",1665802521146],[\\\"SPARSE_TABLE.code-snippets/SPARSE_TABLE\\\",1665802589279],[\\\"GENERATOR.code-snippets/GENERATOR\\\",1665802891569],[\\\"COMPRESS.code-snippets/COMPRESS\\\",1665806140698],[\\\"SQR.code-snippets/SQR\\\",1665820519432],[\\\"MODULAR.code-snippets/MODULAR\\\",1665998020640],[\\\"COMBINATION.code-snippets/COMBINATION\\\",1665998050658],[\\\"SUFFIX_ARRAY.code-snippets/SUFFIX_ARRAY\\\",1675218615012],[\\\"DISJOINT_SET_UNION.code-snippets/DISJOINT_SET_UNION\\\",1697600011647],[\\\"START.code-snippets/START\\\",1717156090531],[\\\"marvinthang.code-snippets/AHO_CORASICK_ARR\\\",1717156831439],[\\\"marvinthang.code-snippets/AHO_CORASICK_PTR\\\",1717156939120],[\\\"GRADER.code-snippets/GRADER\\\",1717157665740],[\\\"marvinthang.code-snippets/BICONNECTED_COMPONENT\\\",1721201658762],[\\\"marvinthang.code-snippets/TWO_EDGE_CONNECTED_COMPONENT\\\",1721203116090],[\\\"marvinthang.code-snippets/BRIDGE_ARTICULATION\\\",1721204928764],[\\\"marvinthang.code-snippets/STRONGLY_CONNECTED_COMPONENT\\\",1721207381896],[\\\"marvinthang.code-snippets/LCA_BL\\\",1721207785432],[\\\"marvinthang.code-snippets/LCA_RMQ\\\",1721207910265],[\\\"marvinthang.code-snippets/MAX_FLOW_PVH\\\",1721236673587],[\\\"marvinthang.code-snippets/DINIC_FLOW\\\",1721237948374],[\\\"marvinthang.code-snippets/MIN_COST_FLOW\\\",1721243677896],[\\\"marvinthang.code-snippets/LINE_CONTAINER\\\",1721292544756],[\\\"marvinthang.code-snippets/Z_FUNCTION\\\",1721392375949],[\\\"marvinthang.code-snippets/KMP\\\",1721393856371],[\\\"marvinthang.code-snippets/DISJOINT_SPARSE_TABLE\\\",1721396696532],[\\\"marvinthang.code-snippets/KNUTH_MORRIS_PRATT\\\",1721396795745],[\\\"marvinthang.code-snippets/TEMPLATE\\\",1721399100688],[\\\"marvinthang.code-snippets/FENWICK_TREE_RANGE\\\",1721556647760],[\\\"marvinthang.code-snippets/CONVEX_HULL_TRICK\\\",1721651872793],[\\\"marvinthang.code-snippets/PARTIALLY_PERSISTENT_DSU\\\",1722181420784],[\\\"marvinthang.code-snippets/WAVELET_TREE\\\",1725036317197],[\\\"marvinthang.code-snippets/SUFFIX_ARRAY\\\",1725703052794],[\\\"marvinthang.code-snippets/MANACHER\\\",1725703055866],[\\\"marvinthang.code-snippets/GEOMETRY\\\",1726140057056],[\\\"marvinthang.code-snippets/BENCHMARK\\\",1726391891178],[\\\"marvinthang.code-snippets/GAUSS_ELIMINATION\\\",1726536926607],[\\\"marvinthang.code-snippets/BITSET_TRICK\\\",1726730336699],[\\\"marvinthang.code-snippets/BIGINT\\\",1726733568210],[\\\"marvinthang.code-snippets/MATRIX\\\",1726765544114],[\\\"marvinthang.code-snippets/MAX_FLOW\\\",1726767421403],[\\\"marvinthang.code-snippets/SPARSE_TABLE\\\",1726909825697],[\\\"marvinthang.code-snippets/RANDOM\\\",1726934671862],[\\\"marvinthang.code-snippets/SUBSET_CONVOLUTION\\\",1727026595133],[\\\"marvinthang.code-snippets/GCD\\\",1727162678029],[\\\"marvinthang.code-snippets/FAST_FOURIER_TRANSFORM\\\",1727416752065],[\\\"marvinthang.code-snippets/NUMBER_THEORETIC_TRANSFORM\\\",1727444697170],[\\\"marvinthang.code-snippets/FENWICK_TREE\\\",1727445495955],[\\\"marvinthang.code-snippets/SEGTREE\\\",1727445501719],[\\\"marvinthang.code-snippets/LAZY_SEGTREE\\\",1727445506201],[\\\"marvinthang.code-snippets/BUMP_ALLOCATOR\\\",1727530077555],[\\\"marvinthang.code-snippets/DISJOINT_SET_UNION\\\",1727685659760],[\\\"marvinthang.code-snippets/TWO_SAT\\\",1727750951862],[\\\"marvinthang.code-snippets/GENERATOR\\\",1727771454017],[\\\"marvinthang.code-snippets/GRADER\\\",1727795234426],[\\\"marvinthang.code-snippets/GRAPH\\\",1727837285106],[\\\"marvinthang.code-snippets/OFFSET_VECTOR\\\",1727837713831],[\\\"marvinthang.code-snippets/FASTIO_KACTL\\\",1727838478747],[\\\"marvinthang.code-snippets/MODINT\\\",1727841930860],[\\\"marvinthang.code-snippets/START\\\",1727845225118],[\\\"marvinthang.code-snippets/MAXMIN\\\",1727845358292]]\",\"views.customizations\":\"{\\\"viewContainerLocations\\\":{\\\"workbench.views.service.panel.17827b40-7980-41bf-8535-94638f93a3a1\\\":1},\\\"viewLocations\\\":{\\\"workbench.panel.repl.view\\\":\\\"workbench.views.service.panel.17827b40-7980-41bf-8535-94638f93a3a1\\\"},\\\"viewContainerBadgeEnablementStates\\\":{}}\",\"workbench.view.extension.references-view.state.hidden\":\"[{\\\"id\\\":\\\"references-view.tree\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"CppReferencesView\\\",\\\"isHidden\\\":false}]\",\"cpp.1.isCandidate\":\"false\",\"cpp.1.skipVersion\":\"1.74.2\",\"workbench.view.extension.gitlens.state.hidden\":\"[{\\\"id\\\":\\\"gitlens.views.home\\\",\\\"isHidden\\\":false}]\",\"workbench.view.extension.gitlensPanel.state.hidden\":\"[{\\\"id\\\":\\\"gitlens.views.timeline\\\",\\\"isHidden\\\":false}]\",\"workbench.view.extension.cph-judge-view-container.state.hidden\":\"[{\\\"id\\\":\\\"cph.judgeView\\\",\\\"isHidden\\\":false}]\",\"workbench.view.extension.copilot-labs.state.hidden\":\"[{\\\"id\\\":\\\"copilotSidebar.explain\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"copilotSidebar.translate\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"copilotSidebar.toolbox\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"copilotSidebar.generateTests\\\",\\\"isHidden\\\":false}]\",\"workbench.view.extension.dockerView.state.hidden\":\"[{\\\"id\\\":\\\"dockerContainers\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"dockerImages\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"dockerRegistries\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"dockerNetworks\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"dockerVolumes\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"vscode-docker.views.dockerContexts\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"vscode-docker.views.help\\\",\\\"isHidden\\\":false}]\",\"workbench.panel.chatSidebar.copilot.hidden\":\"[{\\\"id\\\":\\\"workbench.panel.chat.view.copilot\\\",\\\"isHidden\\\":false}]\",\"workbench.welcomePage.hiddenCategories\":\"[\\\"github.copilot\\\",\\\"ms-vscode.cpptools#cppWelcome\\\"]\",\"workbench.view.extension.tabnine.state.hidden\":\"[{\\\"id\\\":\\\"tabnine.chat\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"tabnine.chat.welcome\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"tabnine.authenticate\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"tabnine.loading\\\",\\\"isHidden\\\":false}]\",\"workbench.panel.chatSidebar.hidden\":\"[{\\\"id\\\":\\\"workbench.panel.chat.view.copilot\\\",\\\"isHidden\\\":false}]\",\"extensionsAssistant/importantRecommendationsIgnore\":\"[\\\"ms-vscode.cpptools-extension-pack\\\"]\",\"workbench.activityBar.location\":\"default\",\"inline-chat-history\":\"[\\\"/doc\\\"]\",\"terminal.integrated.showTerminalConfigPrompt\":\"false\",\"extension.features.state\":\"{\\\"GitHub.copilot-chat\\\":{\\\"languageModels\\\":{\\\"disabled\\\":false,\\\"accessCount\\\":151}}}\",\"languageModelAccess.copilot-gpt-4\":\"[\\\"github.copilot-chat\\\"]\",\"languageModelStats.copilot-gpt-4\":\"{\\\"extensions\\\":[{\\\"extensionId\\\":\\\"GitHub.copilot-chat\\\",\\\"requestCount\\\":0,\\\"tokenCount\\\":0,\\\"participants\\\":[{\\\"id\\\":\\\"github.copilot.default\\\",\\\"requestCount\\\":8,\\\"tokenCount\\\":14673}]}]}\",\"languageModelAccess.copilot-gpt-3.5-turbo\":\"[\\\"github.copilot-chat\\\"]\",\"languageModelStats.copilot-gpt-3.5-turbo\":\"{\\\"extensions\\\":[{\\\"extensionId\\\":\\\"GitHub.copilot-chat\\\",\\\"requestCount\\\":8,\\\"tokenCount\\\":13039,\\\"participants\\\":[]}]}\",\"no-updates-running-as-admin\":\"true\",\"languageModelAccess.gpt-4-0125-preview\":\"[\\\"github.copilot-chat\\\"]\",\"languageModelStats.gpt-4-0125-preview\":\"{\\\"extensions\\\":[{\\\"extensionId\\\":\\\"GitHub.copilot-chat\\\",\\\"requestCount\\\":0,\\\"tokenCount\\\":0,\\\"participants\\\":[{\\\"id\\\":\\\"github.copilot.default\\\",\\\"requestCount\\\":69,\\\"tokenCount\\\":142726}]}]}\",\"languageModelAccess.gpt-3.5-turbo\":\"[\\\"github.copilot-chat\\\"]\",\"languageModelStats.gpt-3.5-turbo\":\"{\\\"extensions\\\":[{\\\"extensionId\\\":\\\"GitHub.copilot-chat\\\",\\\"requestCount\\\":66,\\\"tokenCount\\\":225443,\\\"participants\\\":[]}]}\",\"workbench.view.extension.test.state.hidden\":\"[{\\\"id\\\":\\\"workbench.view.testing\\\",\\\"isHidden\\\":false},{\\\"id\\\":\\\"workbench.view.testCoverage\\\",\\\"isHidden\\\":false}]\",\"tabs-list-width-horizontal\":\"116\",\"javascript.1.editedCount\":\"2\",\"javascript.1.editedDate\":\"Sat Jul 27 2024\",\"expandSuggestionDocs\":\"true\",\"userDataProfiles.state.hidden\":\"[{\\\"id\\\":\\\"workbench.views.profiles.export.preview\\\",\\\"isHidden\\\":false}]\",\"workbench.view.extension.chatgpt-activitybar.state.hidden\":\"[{\\\"id\\\":\\\"chatgpt.sidebar\\\",\\\"isHidden\\\":false}]\",\"workbench.views.service.panel.17827b40-7980-41bf-8535-94638f93a3a1.state.hidden\":\"[{\\\"id\\\":\\\"workbench.panel.repl.view\\\",\\\"isHidden\\\":false}]\",\"nps/skipVersion\":\"1.90.2\"}}"}