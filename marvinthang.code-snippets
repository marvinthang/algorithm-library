{
    "START": {
        "scope": "cpp",
        "prefix": "START",
        "body": [
            "/*************************************",
            "*    author: marvinthang             *",
            "*    created: $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND    *",
            "*************************************/",
            "",
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "#define             fi  first",
            "#define             se  second",
            "#define           left  ___left___",
            "#define          right  ___right___",
            "#define   scan_op(...)  istream & operator >> (istream &in, __VA_ARGS__ &u)",
            "#define  print_op(...)  ostream & operator << (ostream &out, const __VA_ARGS__ &u)",
            "#define     file(name)  if (fopen(name\".inp\", \"r\")) { freopen(name\".inp\", \"r\", stdin); freopen(name\".out\", \"w\", stdout); }",
            "#ifdef LOCAL",
            "\t#include \"debug.h\"",
            "#else",
            "\t#define DB(...)",
            "\t#define db(...) \"\"",
            "\t#define debug(...)",
            "#endif",
            "",
            "namespace std {",
            "template <class U, class V> scan_op(pair <U, V>) { return in >> u.first >> u.second; }",
            "template <class T> scan_op(vector <T>) { for (size_t i = 0; i < u.size(); ++i) in >> u[i]; return in; }",
            "template <class U, class V> print_op(pair <U, V>) { return out << '(' << u.first << \", \" << u.second << ')'; }",
            "template <size_t i, class T> ostream &print_tuple_utils(ostream &out, const T &tup) { if constexpr(i == tuple_size<T>::value) return out << \")\"; else return print_tuple_utils<i + 1, T>(out << (i ? \", \" : \"(\") << get<i>(tup), tup); }",
            "template <class...U> print_op(tuple <U...>) { return print_tuple_utils<0, tuple <U...>>(out, u); }",
            "template <class Con, class = decltype(begin(declval<Con>()))>typename enable_if <!is_same<Con, string>::value, ostream &>::type operator << (ostream &out, const Con &con) { out << '{'; for (__typeof(con.begin()) it = con.begin(); it != con.end(); ++it) out << (it == con.begin() ? \"\" : \", \") << *it; return out << '}'; }",
            "template <class T> print_op(stack <T>) { vector <T> v; stack <T> st = u; while (!st.empty()) v.push_back(st.top()), st.pop(); reverse(v.begin(), v.end()); return out << v; }",
            "template <class T> print_op(queue <T>) { queue <T> q = u; out << '{'; while (!q.empty()) { out << q.front(); q.pop(); if (!q.empty()) out << \", \"; } out << '}'; return out; }",
            "template <class T, class X, class Y> print_op(priority_queue <T, X, Y>) { priority_queue <T, X, Y> pq = u; out << '{'; while (!pq.empty()) { out << pq.top(); pq.pop(); if (!pq.empty()) out << \", \"; } out << '}'; return out; }",
            "template <class Fun> class y_combinator_result { Fun fun_; public: template <class T> explicit y_combinator_result(T &&fun): fun_(forward<T>(fun)) {} template <class...Args> decltype(auto)operator()(Args &&...args) { return fun_(ref(*this), forward<Args>(args)...); } };",
            "template <class Fun> decltype(auto)y_combinator(Fun &&fun) { return y_combinator_result<decay_t<Fun>>(forward<Fun>(fun)); }",
            "template <typename T, int D> struct Vec: public vector <Vec<T, D - 1>> { static_assert(D >= 1, \"Vector dimension must be greater than zero!\"); template <typename ...Args> Vec(int n = 0, Args ...args): vector <Vec<T, D - 1>>(n, Vec<T, D - 1>(args...)) {} };",
            "template <typename T> struct Vec<T, 1>: public vector<T>{ Vec(int n = 0, const T &val = T()): vector<T>(n, val) {} };",
            "#if __cplusplus < 202002L",
            "\ttemplate <class T> int ssize(const T &a) { return a.size(); }",
            "#endif",
            "}",
            "",
            "void process(void) {",
            "\t$0",
            "}",
            "",
            "int main(void) {",
            "\tios_base::sync_with_stdio(false); cin.tie(nullptr);",
            "\tfile(\"${TM_DIRECTORY/^.+[\\/\\\\]+(.*)$/$1/}\");",
            "\t// int t; cin >> t; while (t--)",
            "\tprocess();",
            "\treturn (0^0);",
            "}"
        ],
        "description": "START"
    },
    "AHO_CORASICK_ARR": {
        "scope": "cpp",
        "prefix": "AHO_CORASICK_ARR",
        "body": [
            "const int ALPHABET_SIZE = 26;",
            "struct Node {",
            "\tint parent, parChar;",
            "\tint children[ALPHABET_SIZE];",
            "\tint fail, nxt[ALPHABET_SIZE];",
            "\tint cnt;",
            "\tNode(int parent = -1, int parChar = -1): parent(parent), parChar(parChar) {",
            "\t\tfail = -1;",
            "\t\tcnt = 0;",
            "\t\tfor (int i = 0; i < ALPHABET_SIZE; ++i) children[i] = nxt[i] = -1;",
            "\t}",
            "};",
            " ",
            "vector <Node> nodes;",
            "",
            "void addString(const string &s) {",
            "\tint p = 0;",
            "\tREP(i, s.size()) {",
            "\t\tint c = s[i] - 'a';",
            "\t\tif (!~nodes[p].children[c]) {",
            "\t\t\tnodes[p].children[c] = nodes.size();",
            "\t\t\tnodes.push_back(Node(p, c));",
            "\t\t}",
            "\t\tp = nodes[p].children[c];",
            "\t}",
            "\t++nodes[p].cnt;",
            "}",
            " ",
            "void AC_BFS(void) {",
            "\tqueue <int> q;",
            "\tnodes[0].fail = 0;",
            "\tnodes[0].cnt = 0;",
            "\tfor (int i = 0; i < ALPHABET_SIZE; ++i) {",
            "\t\tif (~nodes[0].children[i]) {",
            "\t\t\tnodes[0].nxt[i] = nodes[0].children[i];",
            "\t\t\tq.push(nodes[0].children[i]);",
            "\t\t} else nodes[0].nxt[i] = 0;",
            "\t}",
            "\twhile (!q.empty()) {",
            "\t\tint p = q.front(); q.pop();",
            "\t\tnodes[p].fail = !nodes[p].parent ? 0 : nodes[nodes[nodes[p].parent].fail].nxt[nodes[p].parChar];",
            "\t\tnodes[p].cnt += nodes[nodes[p].fail].cnt;",
            "\t\tfor (int i = 0; i < ALPHABET_SIZE; ++i) {",
            "\t\t\tif (~nodes[p].children[i]) {",
            "\t\t\t\tnodes[p].nxt[i] = nodes[p].children[i];",
            "\t\t\t\tq.push(nodes[p].children[i]);",
            "\t\t\t} else nodes[p].nxt[i] = nodes[nodes[p].fail].nxt[i];",
            "\t\t}",
            "\t}",
            "}",
            ""
        ],
        "description": "AHO_CORASICK_ARR"
    },
    "AHO_CORASICK_PTR": {
        "scope": "cpp",
        "prefix": "AHO_CORASICK_PTR",
        "body": [
            "const int ALPHABET_SIZE = 26;",
            "struct Node {",
            "\tNode *parent;",
            "\tint parChar;",
            "\tNode *children[ALPHABET_SIZE];",
            "\tNode *fail, *nxt[ALPHABET_SIZE];",
            "\tint cnt;",
            "\tNode(Node *parent = nullptr, int parChar = -1): parent(parent), parChar(parChar) {",
            "\t\tfail = nullptr;",
            "\t\tfor (int i = 0; i < ALPHABET_SIZE; ++i) children[i] = nxt[i] = nullptr;",
            "\t\tcnt = 0;",
            "\t}",
            "};",
            " ",
            "int numNode;",
            "Node *root;",
            " ",
            "void addString(const string &s) {",
            "\tNode *p = root;",
            "\tREP(i, s.size()) {",
            "\t\tint c = s[i] - 'a';",
            "\t\tif (p->children[c] == nullptr) p->children[c] = new Node(p, c);",
            "\t\tp = p->children[c];",
            "\t}",
            "\t++p->cnt;",
            "}",
            " ",
            "void AC_BFS(void) {",
            "\tqueue <Node*> q;",
            "\troot->fail = root;",
            "\troot->cnt = 0;",
            "\tfor (int i = 0; i < ALPHABET_SIZE; ++i) {",
            "\t\tif (root->children[i] != nullptr) {",
            "\t\t\troot->nxt[i] = root->children[i];",
            "\t\t\tq.push(root->children[i]);",
            "\t\t} else root->nxt[i] = root;",
            "\t}",
            "\twhile (!q.empty()) {",
            "\t\tNode *p = q.front(); q.pop();",
            "\t\tp->fail = p->parent == root ? root : p->parent->fail->nxt[p->parChar];",
            "\t\tp->cnt += p->fail->cnt;",
            "\t\tfor (int i = 0; i < ALPHABET_SIZE; ++i) {",
            "\t\t\tif (p->children[i] != nullptr) {",
            "\t\t\t\tp->nxt[i] = p->children[i];",
            "\t\t\t\tq.push(p->children[i]);",
            "\t\t\t} else p->nxt[i] = p->fail->nxt[i];",
            "\t\t}",
            "\t}",
            "}",
            ""
        ],
        "description": "AHO_CORASICK_PTR"
    },
    "SPARSE_TABLE": {
        "scope": "cpp",
        "prefix": "SPARSE_TABLE",
        "body": [
            "template <class T, T (*op) (T, T)> class SparseTable {",
            "public:",
            "\tSparseTable() = default;",
            "\tSparseTable(const vector <T> &v): table{v}, n(v.size()) {",
            "\t\tfor (int k = 1; (1 << k) <= n; ++k) {",
            "\t\t\ttable.emplace_back(n - (1 << k) + 1);",
            "\t\t\tfor (int i = 0; i + (1 << k) <= n; i++) table[k][i] = op(table[k - 1][i], table[k - 1][i + (1 << (k - 1))]);",
            "\t\t}",
            "\t}",
            "\tT get(int l, int r) { // [l, r - 1]",
            "\t\tassert(0 <= l && l < r && r <= n);",
            "\t\tint k = __lg(r - l);",
            "\t\treturn op(table[k][l], table[k][r - (1 << k)]);",
            "\t}",
            "private:",
            "\tvector <vector <T>> table;",
            "\tint n;",
            "};",
            "template <class T> T _min(T x, T y) { return x < y ? x : y; }",
            "template <class T> T _max(T x, T y) { return x > y ? x : y; }",
            ""
        ],
        "description": "SPARSE_TABLE"
    },
    "SEGTREE": {
        "scope": "cpp",
        "prefix": "SEGTREE",
        "body": [
            "template<",
            "\tclass T,        // data type for nodes",
            "\tT (*op) (T, T), // operator to combine 2 nodes",
            "\tT (*e)()        // identity element",
            "\t>",
            "struct SegTree {",
            "\tSegTree(): SegTree(0) {}",
            "\tSegTree(int n) : SegTree(vector<T>(n, e())) {}",
            "\tSegTree(const vector <T>& v) : n(v.size()) {",
            "\t\tlog = 0;",
            "\t\twhile ((1 << log) < n) ++log;",
            "\t\tsize = 1 << log;",
            "\t\td = vector<T>(size << 1, e());",
            "\t\tfor (int i = 0; i < n; ++i) d[size + i] = v[i];",
            "\t\tfor (int i = size - 1; i > 0; --i) update(i);",
            "\t}",
            "",
            "\t// 0 <= p < n",
            "\tvoid set(int p, T x) {",
            "\t\tassert(0 <= p && p < n);",
            "\t\tp += size; d[p] = x;",
            "\t\tfor (int i = 1; i <= log; ++i) update(p >> i);",
            "\t}",
            "",
            "\t// 0 <= p < n",
            "\tT get(int p) const {",
            "\t\tassert(0 <= p && p < n);",
            "\t\treturn d[p + size];",
            "\t}",
            "",
            "\t// Get product in range [l, r-1]",
            "\t// 0 <= l <= r <= n",
            "\t// For empty segment (l == r) -> return e()",
            "\tT prod(int l, int r) const {",
            "\t\tassert(0 <= l && l <= r && r <= n);",
            "\t\tT sml = e(), smr = e();",
            "\t\tl += size; r += size;",
            "\t\twhile (l < r) {",
            "\t\t\tif (l & 1) sml = op(sml, d[l++]);",
            "\t\t\tif (r & 1) smr = op(d[--r], smr);",
            "\t\t\tl >>= 1; r >>= 1;",
            "\t\t}",
            "\t\treturn op(sml, smr);",
            "\t}",
            "",
            "\tT all_prod() const { return d[1]; }",
            "",
            "\t// Binary search on SegTree to find largest r:",
            "\t//\tf(op(a[l] .. a[r-1])) = true   (assuming empty array is always true)",
            "\t//\tf(op(a[l] .. a[r])) = false\t(assuming op(..., a[n]), which is out of bound, is always false)",
            "\ttemplate <bool (*f)(T)> int max_right(int l) const { return max_right(l, [](T x) { return f(x); }); }",
            "\ttemplate <class F> int max_right(int l, F f) const {",
            "\t\tassert(0 <= l && l <= n);",
            "\t\tassert(f(e()));",
            "\t\tif (l == n) return n;",
            "\t\tl += size;",
            "\t\tT sm = e();",
            "\t\tdo {",
            "\t\t\twhile (!(l & 1)) l >>= 1;",
            "\t\t\tif (!f(op(sm, d[l]))) {",
            "\t\t\t\twhile (l < size) {",
            "\t\t\t\t\tl = l << 1;",
            "\t\t\t\t\tif (f(op(sm, d[l]))) {",
            "\t\t\t\t\t\tsm = op(sm, d[l]);",
            "\t\t\t\t\t\tl++;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\treturn l - size;",
            "\t\t\t}",
            "\t\t\tsm = op(sm, d[l]);",
            "\t\t\tl++;",
            "\t\t} while ((l & -l) != l);",
            "\t\treturn n;",
            "\t}",
            "",
            "\t// Binary search on SegTree to find smallest l:",
            "\t//\tf(op(a[l] .. a[r-1])) = true\t  (assuming empty array is always true)",
            "\t//\tf(op(a[l-1] .. a[r-1])) = false   (assuming op(a[-1], ..), which is out of bound, is always false)",
            "\ttemplate <bool (*f)(T)> int min_left(int r) const { return min_left(r, [](T x) { return f(x); }); }",
            "\ttemplate <class F> int min_left(int r, F f) const {",
            "\t\tassert(0 <= r && r <= n);",
            "\t\tassert(f(e()));",
            "\t\tif (r == 0) return 0;",
            "\t\tr += size;",
            "\t\tT sm = e();",
            "\t\tdo {",
            "\t\t\tr--;",
            "\t\t\twhile (r > 1 && (r & 1)) r >>= 1;",
            "\t\t\tif (!f(op(d[r], sm))) {",
            "\t\t\t\twhile (r < size) {",
            "\t\t\t\t\tr = r << 1 | 1;",
            "\t\t\t\t\tif (f(op(d[r], sm))) {",
            "\t\t\t\t\t\tsm = op(d[r], sm);",
            "\t\t\t\t\t\tr--;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\treturn r + 1 - size;",
            "\t\t\t}",
            "\t\t\tsm = op(d[r], sm);",
            "\t\t} while ((r & -r) != r);",
            "\t\treturn 0;",
            "\t}",
            "",
            "private:",
            "\tint n, size, log;",
            "\tvector <T> d;",
            "\tvoid update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
            "};",
            ""
        ],
        "description": "SEGTREE"
    },
    "RANDOM": {
        "scope": "cpp",
        "prefix": "RANDOM",
        "body": [
            "mt19937_64 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());",
            "template <class T> T rand(T l, T h) { return uniform_int_distribution <T> (l, h) (rng); }",
            "template <class T> T rand(T h) { return uniform_int_distribution <T> (0, h - 1) (rng); }",
            ""
        ],
        "description": "RANDOM"
    },
    "PARTIALLY_PERSISTENT_DSU": {
        "scope": "cpp",
        "prefix": "PARTIALLY_PERSISTENT_DSU",
        "body": [
            "struct PartiallyPersistentDisjointSet {",
            "\tvector <int> lab, t_unite;",
            "\tPartiallyPersistentDisjointSet(int n = 0): lab(n + 1, -1), t_unite(n + 1, (int) 1e9) {}",
            "\tvoid reset(void) {",
            "\t\tfill(lab.begin(), lab.end(), -1);",
            "\t\tfill(t_unite.begin(), t_unite.end(), (int) 1e9);",
            "\t}",
            "\tvoid resize(int n) {",
            "\t\tlab.assign(n + 1, -1);",
            "\t\tt_unite.assign(n + 1, (int) 1e9);",
            "\t}",
            "\tbool connected(int t, int u, int v) { return find(t, u) == find(t, v); }",
            "\tbool isRoot(int t, int u) { return t_unite[u] > t; }",
            "\tint size(int t, int u) { return -lab[find(t, u)]; }",
            "\tint find(int t, int u) { return t_unite[u] > t ? u : find(t, lab[u]); }",
            "\tbool join(int t, int u, int v) {",
            "\t\tif ((u = find(t, u)) == (v = find(t, v))) return false;",
            "\t\tif (lab[u] > lab[v]) swap(u, v);",
            "\t\tlab[u] += lab[v]; lab[v] = u; t_unite[v] = t;",
            "\t\treturn true;",
            "\t}",
            "};",
            "using PPDS = PartiallyPersistentDisjointSet;",
            ""
        ],
        "description": "PARTIALLY_PERSISTENT_DSU"
    },
    "ORDERED_SET": {
        "scope": "cpp",
        "prefix": "ORDERED_SET",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "template <typename T>",
            "using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            ""
        ],
        "description": "ORDERED_SET"
    },
    "OFFSET_VECTOR": {
        "scope": "cpp",
        "prefix": "OFFSET_VECTOR",
        "body": [
            "template <typename V> struct OffsetVector {",
            "\t// Index should be in [minIndex, maxIndex].",
            "\t// minIndex and maxIndex can be negative.",
            "\tOffsetVector(int minIndex, int maxIndex): x(maxIndex - minIndex + 1), offset(minIndex) {}",
            "\tV & operator [] (int index) { return x[index - offset]; }",
            "\tauto begin() { return x.begin(); }",
            "\tauto end() { return x.end(); }",
            "\tauto size() { return x.size(); }",
            "private:",
            "\tvector <V> x;",
            "\tint offset;",
            "};",
            ""
        ],
        "description": "OFFSET_VECTOR"
    },
    "RABIN_MILLER": {
        "scope": "cpp",
        "prefix": "RABIN_MILLER",
        "body": [
            "namespace RABIN_MILLER {",
            "unsigned mod_mult(unsigned a, unsigned b, unsigned m) { return (uint64_t) a * b % m; }",
            "uint64_t mod_mult64(uint64_t a, uint64_t b, uint64_t m) { return __int128_t(a) * b % m; }",
            "unsigned mod_pow(unsigned a, uint64_t b, unsigned m) {",
            "\tunsigned ret = 1;",
            "\tfor (; b; b >>= 1, a = mod_mult(a, a, m)) if (b & 1) ret = mod_mult(ret, a, m);",
            "\treturn ret;",
            "}",
            "uint64_t mod_pow64(uint64_t a, uint64_t b, uint64_t m) {",
            "\tuint64_t ret = 1;",
            "\tfor (; b; b >>= 1, a = mod_mult64(a, a, m)) if (b & 1) ret = mod_mult64(ret, a, m);",
            "\treturn ret;",
            "}",
            "bool is_prime32(unsigned n) {",
            "\tif (n <= 3) return (n >= 2);",
            "\tstatic const unsigned small[] = {",
            "\t\t2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,",
            "\t\t71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139,",
            "\t};",
            "\tfor (size_t i = 0; i < 34; ++i) if (n%small[i] == 0) return n == small[i];",
            "\tstatic const unsigned millerrabin[] = {2, 7, 61};",
            "\tunsigned s = n - 1, r = 0;",
            "\twhile (!(s & 1)) s >>= 1, ++r;",
            "\tfor (size_t i = 0, j; i < 3; ++i) {",
            "\t\tunsigned md = mod_pow(millerrabin[i], s, n);",
            "\t\tif (md == 1) continue;",
            "\t\tfor (j = 1; j < r && md != n - 1; ++j) md = mod_mult(md, md, n);",
            "\t\tif (md != n - 1) return false;",
            "\t}",
            "\treturn true;",
            "}",
            "bool is_prime64(uint64_t n) {",
            "\tif (n <= 3) return (n >= 2);",
            "\tstatic const uint64_t small[] = {",
            "\t\t2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,",
            "\t\t71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139,",
            "\t\t149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199",
            "\t};",
            "\tfor (size_t i = 0; i < 46; ++i) if (n % small[i] == 0) return n == small[i];",
            "\tstatic const uint64_t millerrabin[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};",
            "\tstatic const uint64_t A014233[] = {",
            "\t\t2047LL, 1373653LL, 25326001LL, 3215031751LL, 2152302898747LL,",
            "\t\t3474749660383LL, 341550071728321LL, 341550071728321LL,",
            "\t\t3825123056546413051LL, 3825123056546413051LL, 3825123056546413051LL, 0",
            "\t};",
            "\tuint64_t s = n - 1, r = 0;",
            "\twhile (!(s & 1)) s >>= 1, ++r;",
            "\tfor (size_t i = 0, j; i < 11; ++i) {",
            "\t\tuint64_t md = mod_pow64(millerrabin[i], s, n);",
            "\t\tif (md != 1) {",
            "\t\t\tfor (j = 1; j < r && md != n - 1; ++j) md = mod_mult64(md, md, n);",
            "\t\t\tif (md != n - 1) return false;",
            "\t\t}",
            "\t\tif (n < A014233[i]) return true;",
            "\t}",
            "\treturn true;",
            "}",
            "} using namespace RABIN_MILLER;",
            ""
        ],
        "description": "RABIN_MILLER"
    },
    "NUMBER_THEORETIC_TRANSFORM": {
        "scope": "cpp",
        "prefix": "NUMBER_THEORETIC_TRANSFORM",
        "body": [
            "namespace NUMBER_THEORETIC_TRANSFORM {",
            "template <typename Modular> class NTT {",
            "public:",
            "\tstatic int md, base, max_base;",
            "\tstatic Modular root;",
            "\tstatic vector <Modular> roots;",
            "\tstatic vector <int> rev;",
            "\tstatic void clear() {",
            "\t\troot = base = max_base = 0;",
            "\t\troots.clear();",
            "\t\trev.clear();",
            "\t}",
            "\tstatic void init() {",
            "\t\tmd = Modular::mod();",
            "\t\tassert(md >= 3 && md % 2 == 1);",
            "\t\tauto tmp = md - 1;",
            "\t\tmax_base = 0;",
            "\t\twhile (!(tmp & 1)) tmp >>= 1, ++max_base;",
            "\t\troot = 2;",
            "\t\twhile (root.pow((md - 1) >> 1).val() == 1) ++root;",
            "\t\tassert(root.pow(md - 1) == 1);",
            "\t\troot = root.pow((md - 1) >> max_base);",
            "\t\tbase = 1; rev = {0, 1}; roots = {0, 1};",
            "\t}",
            "\tstatic void ensure_base(int nbase) {",
            "\t\tif (md != Modular::mod()) clear();",
            "\t\tif (roots.empty()) init();",
            "\t\tif (nbase <= base) return;",
            "\t\tassert(nbase <= max_base);",
            "\t\trev.resize(1 << nbase);",
            "\t\tfor (int i = 0; i < (1 << nbase); ++i) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));",
            "\t\troots.resize(1 << nbase);",
            "\t\twhile (base < nbase) {",
            "\t\t\tModular z = root.pow(1 << (max_base - 1 - base));",
            "\t\t\tfor (int i = 1 << (base - 1); i < (1 << base); ++i) {",
            "\t\t\t\troots[i << 1] = roots[i];",
            "\t\t\t\troots[i << 1 | 1] = roots[i] * z;",
            "\t\t\t}",
            "\t\t\t++base;",
            "\t\t}",
            "\t}",
            "\tstatic void fft(vector <Modular> &a) {",
            "\t\tint n = (int) a.size();",
            "\t\tassert((n & (n - 1)) == 0);",
            "\t\tint zeros = __builtin_ctz(n);",
            "\t\tensure_base(zeros);",
            "\t\tint shift = base - zeros;",
            "\t\tfor (int i = 0; i < n; ++i) if (i < (rev[i] >> shift)) swap(a[i], a[rev[i] >> shift]);",
            "\t\tfor (int k = 1; k < n; k <<= 1) {",
            "\t\t\tfor (int i = 0; i < n; i += k << 1) {",
            "\t\t\t\tfor (int j = 0; j < k; j++) {",
            "\t\t\t\t\tModular x = a[i + j];",
            "\t\t\t\t\tModular y = a[i + j + k] * roots[j + k];",
            "\t\t\t\t\ta[i + j] = x + y;",
            "\t\t\t\t\ta[i + j + k] = x - y;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tstatic vector <Modular> multiply(vector <Modular> a, vector <Modular> b) {",
            "\t\tif (a.empty() || b.empty()) return {};",
            "\t\tint eq = (a == b);",
            "\t\tint need = (int) a.size() + (int) b.size() - 1;",
            "\t\tint nbase = 0;",
            "\t\twhile ((1 << nbase) < need) ++nbase;",
            "\t\tensure_base(nbase);",
            "\t\tint sz = 1 << nbase;",
            "\t\ta.resize(sz); b.resize(sz);",
            "\t\tfft(a);",
            "\t\tif (eq) b = a;",
            "\t\telse fft(b);",
            "\t\tModular inv_sz = static_cast<Modular>(sz).inv();",
            "\t\tfor (int i = 0; i < sz; ++i) a[i] *= b[i] * inv_sz;",
            "\t\treverse(a.begin() + 1, a.end());",
            "\t\tfft(a);",
            "\t\ta.resize(need);",
            "\t\treturn a;",
            "\t}",
            "};",
            "template <typename Modular> int NTT<Modular>::md;",
            "template <typename Modular> Modular NTT<Modular>::root;",
            "template <typename Modular> int NTT<Modular>::base;",
            "template <typename Modular> int NTT<Modular>::max_base;",
            "template <typename Modular> vector<Modular> NTT<Modular>::roots;",
            "template <typename Modular> vector<int> NTT<Modular>::rev;",
            "template <typename Modular> vector <Modular> inverse(const vector <Modular> &a) {",
            "\tassert(!a.empty());",
            "\tint n = (int) a.size();",
            "\tvector <Modular> b = {a[0].inv()};",
            "\twhile ((int) b.size() < n) {",
            "\t\tvector <Modular> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));",
            "\t\tx.resize(b.size() << 1); b.resize(b.size() << 1);",
            "\t\tvector <Modular> c = b;",
            "\t\tNTT<Modular>::fft(c); NTT<Modular>::fft(x);",
            "\t\tModular inv = static_cast<Modular>((int)x.size()).inv();",
            "\t\tfor (int i = 0; i < (int) x.size(); ++i) x[i] *= c[i] * inv;",
            "\t\treverse(x.begin() + 1, x.end());",
            "\t\tNTT<Modular>::fft(x);",
            "\t\trotate(x.begin(), x.begin() + (x.size() >> 1), x.end());",
            "\t\tfill(x.begin() + (x.size() >> 1), x.end(), 0);",
            "\t\tNTT<Modular>::fft(x);",
            "\t\tfor (int i = 0; i < (int) x.size(); ++i) x[i] *= c[i] * inv;",
            "\t\treverse(x.begin() + 1, x.end());",
            "\t\tNTT<Modular>::fft(x);",
            "\t\tfor (int i = 0; i < (int) x.size() >> 1; ++i) b[i + ((int)x.size() >> 1)] = -x[i];",
            "\t}",
            "\tb.resize(n);",
            "\treturn b;",
            "}",
            "template <typename Modular> vector <Modular> inverse_old(vector <Modular> a) {",
            "\tassert(!a.empty());",
            "\tint n = a.size();",
            "\tif (n == 1) return { a[0].inv() };",
            "\tint m = (n + 1) >> 1;",
            "\tvector <Modular> b = inverse(vector<Modular>(a.begin(), a.begin() + m));",
            "\tint need = n << 1, nbase = 0;",
            "\twhile ((1 << nbase) < need) ++nbase;",
            "\tNTT<Modular>::ensure_base(nbase);",
            "\tint size = 1 << nbase;",
            "\ta.resize(size); b.resize(size);",
            "\tNTT<Modular>::fft(a); NTT<Modular>::fft(b);",
            "\tModular inv = static_cast<Modular>(size).inv();",
            "\tfor (int i = 0; i < size; ++i) a[i] = (2 - a[i] * b[i]) * b[i] * inv;",
            "\treverse(a.begin() + 1, a.end());",
            "\tNTT<Modular>::fft(a);",
            "\ta.resize(n);",
            "\treturn a;",
            "}",
            "template <typename Modular> vector <Modular> operator * (const vector <Modular> &a, const vector <Modular> &b) {",
            "\tif (a.empty() || b.empty()) return {};",
            "\tif (min(a.size(), b.size()) < 150) {",
            "\t\tvector <Modular> c(a.size() + b.size() - 1, 0);",
            "\t\tfor (int i = 0; i < (int) a.size(); ++i)",
            "\t\t\tfor (int j = 0; j < (int) b.size(); j++)",
            "\t\t\t\tc[i + j] += a[i] * b[j];",
            "\t\treturn c;",
            "\t}",
            "\treturn NTT<Modular>::multiply(a, b);",
            "}",
            "template <typename Modular> vector <Modular> & operator *= (vector<Modular> &a, const vector <Modular> &b) { return a = a * b; }",
            "}",
            "using NUMBER_THEORETIC_TRANSFORM::operator *;",
            "using NUMBER_THEORETIC_TRANSFORM::operator *=;",
            ""
        ],
        "description": "NUMBER_THEORETIC_TRANSFORM"
    },
    "FAST_FOURIER_TRANSFORM": {
        "scope": "cpp",
        "prefix": "FAST_FOURIER_TRANSFORM",
        "body": [
            "namespace FAST_FOURIER_TRANSFORM {",
            "typedef long double dbl;",
            "struct num {",
            "\tdbl x, y;",
            "\tnum() { x = y = 0; }",
            "\tnum(dbl x_, dbl y_) : x(x_), y(y_) {}",
            "};",
            "num operator + (num a, num b) { return num(a.x + b.x, a.y + b.y); }",
            "num operator - (num a, num b) { return num(a.x - b.x, a.y - b.y); }",
            "num operator * (num a, num b) { return num(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }",
            "num conj(num a) { return num(a.x, -a.y); }",
            "int base = 1;",
            "vector <num> roots = {{0, 0}, {1, 0}};",
            "vector <int> rev = {0, 1};",
            "const dbl PI = static_cast<dbl>(acosl(-1.0));",
            "void ensure_base(int nbase) {",
            "\tif (nbase <= base) return;",
            "\trev.resize(1 << nbase);",
            "\tfor (int i = 0; i < (1 << nbase); ++i) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));",
            "\troots.resize(1 << nbase);",
            "\twhile (base < nbase) {",
            "\t\tdbl angle = 2 * PI / (1 << (base + 1));",
            "\t\tfor (int i = 1 << (base - 1); i < (1 << base); ++i) {",
            "\t\t\troots[i << 1] = roots[i];",
            "\t\t\tdbl angle_i = angle * (2 * i + 1 - (1 << base));",
            "\t\t\troots[(i << 1) + 1] = num(cos(angle_i), sin(angle_i));",
            "\t\t}",
            "\t\tbase++;",
            "\t}",
            "}",
            "void fft(vector <num> &a, int n = -1) {",
            "\tif (n == -1) n = (int) a.size();",
            "\tassert((n & (n - 1)) == 0);",
            "\tint zeros = __builtin_ctz(n);",
            "\tensure_base(zeros);",
            "\tint shift = base - zeros;",
            "\tfor (int i = 0; i < n; ++i) if (i < (rev[i] >> shift)) swap(a[i], a[rev[i] >> shift]);",
            "\tfor (int k = 1; k < n; k <<= 1) {",
            "\t\tfor (int i = 0; i < n; i += k << 1) {",
            "\t\t\tfor (int j = 0; j < k; ++j) {",
            "\t\t\t\tnum z = a[i + j + k] * roots[j + k];",
            "\t\t\t\ta[i + j + k] = a[i + j] - z;",
            "\t\t\t\ta[i + j] = a[i + j] + z;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}",
            "vector <num> fa, fb;",
            "vector <long long> square(const vector <int> &a) {",
            "\tif (a.empty()) return {};",
            "\tint need = (int) a.size() + (int) a.size() - 1, nbase = 1;",
            "\twhile ((1 << nbase) < need) ++nbase;",
            "\tensure_base(nbase);",
            "\tint sz = 1 << nbase;",
            "\tif ((sz >> 1) > (int) fa.size()) fa.resize(sz >> 1);",
            "\tfor (int i = 0; i < (sz >> 1); ++i) {",
            "\t\tint x = (2 * i < (int)a.size() ? a[2 * i] : 0);",
            "\t\tint y = (2 * i + 1 < (int)a.size() ? a[2 * i + 1] : 0);",
            "\t\tfa[i] = num(x, y);",
            "\t}",
            "\tfft(fa, sz >> 1);",
            "\tnum r(1.0 / (sz >> 1), 0.0);",
            "\tfor (int i = 0; i <= (sz >> 2); ++i) {",
            "\t\tint j = ((sz >> 1) - i) & ((sz >> 1) - 1);",
            "\t\tnum fe = (fa[i] + conj(fa[j])) * num(0.5, 0);",
            "\t\tnum fo = (fa[i] - conj(fa[j])) * num(0, -0.5);",
            "\t\tnum aux = fe * fe + fo * fo * roots[(sz >> 1) + i] * roots[(sz >> 1) + i];",
            "\t\tnum tmp = fe * fo;",
            "\t\tfa[i] = r * (conj(aux) + num(0, 2) * conj(tmp));",
            "\t\tfa[j] = r * (aux + num(0, 2) * tmp);",
            "\t}",
            "\tfft(fa, sz >> 1);",
            "\tvector<long long> res(need);",
            "\tfor (int i = 0; i < need; ++i) res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);",
            "\treturn res;",
            "}",
            "vector <long long> multiply(const vector <int> &a, const vector <int> &b) {",
            "\tif (a.empty() || b.empty()) return {};",
            "\tif (a == b) return square(a);",
            "\tint need = (int) a.size() + (int) b.size() - 1, nbase = 1;",
            "\twhile ((1 << nbase) < need) ++nbase;",
            "\tensure_base(nbase);",
            "\tint sz = 1 << nbase;",
            "\tif (sz > (int) fa.size()) fa.resize(sz);",
            "\tfor (int i = 0; i < sz; ++i) {",
            "\t\tint x = (i < (int)a.size() ? a[i] : 0);",
            "\t\tint y = (i < (int)b.size() ? b[i] : 0);",
            "\t\tfa[i] = num(x, y);",
            "\t}",
            "\tfft(fa, sz);",
            "\tnum r(0, -0.25 / (sz >> 1));",
            "\tfor (int i = 0; i <= (sz >> 1); ++i) {",
            "\t\tint j = (sz - i) & (sz - 1);",
            "\t\tnum z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r;",
            "\t\tfa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r;",
            "\t\tfa[i] = z;",
            "\t}",
            "\tfor (int i = 0; i < (sz >> 1); ++i) {",
            "\t\tnum A0 = (fa[i] + fa[i + (sz >> 1)]) * num(0.5, 0);",
            "\t\tnum A1 = (fa[i] - fa[i + (sz >> 1)]) * num(0.5, 0) * roots[(sz >> 1) + i];",
            "\t\tfa[i] = A0 + A1 * num(0, 1);",
            "\t}",
            "\tfft(fa, sz >> 1);",
            "\tvector <long long> res(need);",
            "\tfor (int i = 0; i < need; ++i) res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);",
            "\treturn res;",
            "}",
            "vector <int> multiply_mod(const vector<int> &a, const vector<int> &b, int m) {",
            "\tif (a.empty() || b.empty()) return {};",
            "\tint eq = (a.size() == b.size() && a == b);",
            "\tint need = (int)a.size() + (int)b.size() - 1, nbase = 0;",
            "\twhile ((1 << nbase) < need) ++nbase;",
            "\tensure_base(nbase);",
            "\tint sz = 1 << nbase;",
            "\tif (sz > (int) fa.size()) fa.resize(sz);",
            "\tfor (int i = 0; i < (int) a.size(); ++i) {",
            "\t\tint x = (a[i] % m + m) % m;",
            "\t\tfa[i] = num(x & ((1 << 15) - 1), x >> 15);",
            "\t}",
            "\tfill(fa.begin() + a.size(), fa.begin() + sz, num{0, 0});",
            "\tfft(fa, sz);",
            "\tif (sz > (int) fb.size()) fb.resize(sz);",
            "\tif (eq) copy(fa.begin(), fa.begin() + sz, fb.begin());",
            "\telse {",
            "\t\tfor (int i = 0; i < (int)b.size(); ++i) {",
            "\t\t\tint x = (b[i] % m + m) % m;",
            "\t\t\tfb[i] = num(x & ((1 << 15) - 1), x >> 15);",
            "\t\t}",
            "\t\tfill(fb.begin() + b.size(), fb.begin() + sz, num{0, 0});",
            "\t\tfft(fb, sz);",
            "\t}",
            "\tdbl ratio = 0.25 / sz;",
            "\tnum r2(0, -1);",
            "\tnum r3(ratio, 0);",
            "\tnum r4(0, -ratio);",
            "\tnum r5(0, 1);",
            "\tfor (int i = 0; i <= (sz >> 1); ++i) {",
            "\t\tint j = (sz - i) & (sz - 1);",
            "\t\tnum a1 = (fa[i] + conj(fa[j]));",
            "\t\tnum a2 = (fa[i] - conj(fa[j])) * r2;",
            "\t\tnum b1 = (fb[i] + conj(fb[j])) * r3;",
            "\t\tnum b2 = (fb[i] - conj(fb[j])) * r4;",
            "\t\tif (i != j) {",
            "\t\t\tnum c1 = (fa[j] + conj(fa[i]));",
            "\t\t\tnum c2 = (fa[j] - conj(fa[i])) * r2;",
            "\t\t\tnum d1 = (fb[j] + conj(fb[i])) * r3;",
            "\t\t\tnum d2 = (fb[j] - conj(fb[i])) * r4;",
            "\t\t\tfa[i] = c1 * d1 + c2 * d2 * r5;",
            "\t\t\tfb[i] = c1 * d2 + c2 * d1;",
            "\t\t}",
            "\t\tfa[j] = a1 * b1 + a2 * b2 * r5;",
            "\t\tfb[j] = a1 * b2 + a2 * b1;",
            "\t}",
            "\tfft(fa, sz);",
            "\tfft(fb, sz);",
            "\tvector<int> res(need);",
            "\tfor (int i = 0; i < need; ++i) {",
            "\t\tlong long aa = llround(fa[i].x);",
            "\t\tlong long bb = llround(fb[i].x);",
            "\t\tlong long cc = llround(fa[i].y);",
            "\t\tres[i] = static_cast<int>((aa + ((bb % m) << 15) + ((cc % m) << 30)) % m);",
            "\t}",
            "\treturn res;",
            "}",
            "template <typename Modular> vector <Modular> operator * (const vector <Modular> &a, const vector <Modular> &b) {",
            "\tif (a.empty() || b.empty()) return {};",
            "\tif (min(a.size(), b.size()) < 150) {",
            "\t\tvector <Modular> c(a.size() + b.size() - 1, 0);",
            "\t\tfor (int i = 0; i < (int)a.size(); ++i)",
            "\t\t\tfor (int j = 0; j < (int)b.size(); ++j)",
            "\t\t\t\tc[i + j] += a[i] * b[j];",
            "\t\treturn c;",
            "\t}",
            "\tvector <int> a_mul(a.size());",
            "\tfor (int i = 0; i < (int) a.size(); ++i) a_mul[i] = static_cast<int>(a[i]);",
            "\tvector <int> b_mul(b.size());",
            "\tfor (int i = 0; i < (int) b.size(); ++i) b_mul[i] = static_cast<int>(b[i]);",
            "\tvector <int> c_mul = multiply_mod(a_mul, b_mul, Modular::mod());",
            "\tvector <Modular> c(c_mul.size());",
            "\tfor (int i = 0; i < (int) c.size(); ++i) c[i] = c_mul[i];",
            "\treturn c;",
            "}",
            "template <typename Modular> vector <Modular> & operator *= (vector <Modular> &a, const vector <Modular> &b) { return a = a * b; }",
            "}",
            "using FAST_FOURIER_TRANSFORM::square;",
            "using FAST_FOURIER_TRANSFORM::multiply;",
            "using FAST_FOURIER_TRANSFORM::multiply_mod;",
            "using FAST_FOURIER_TRANSFORM::operator *;",
            "using FAST_FOURIER_TRANSFORM::operator *=;",
            ""
        ],
        "description": "FAST_FOURIER_TRANSFORM"
    },
    "MODINT": {
        "scope": "cpp",
        "prefix": "MODINT",
        "body": [
            "namespace MODINT {",
            "struct barrett {",
            "\tunsigned int _m;",
            "\tunsigned long long im;",
            "\texplicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}",
            "\tunsigned int umod() const { return _m; };",
            "\tunsigned int mul(unsigned int a, unsigned int b) const {",
            "\t\tunsigned long long z = a; z *= b;",
            "\t\tunsigned long long x = (unsigned long long)(((unsigned __int128) z * im) >> 64);",
            "\t\tunsigned long long y = x * _m;",
            "\t\treturn (unsigned int)(z - y + (z < y ? _m : 0));",
            "\t}",
            "};",
            "template <class T> T invGeneral(T a, T b) {",
            "\ta %= b;",
            "\tif (!a) return b == 1 ? 0 : -1;",
            "\tT x = invGeneral(b, a);",
            "\treturn x == -1 ? -1 : ((1 - 1LL * b * x) / a + b) % b;",
            "}",
            "template <int m, enable_if_t<1 <= m>* = nullptr>",
            "struct static_modint {",
            "using mint = static_modint;",
            "public:",
            "\tstatic constexpr int mod() { return m; }",
            "\tstatic mint raw(int v) {",
            "\t\tmint x; x.v = v;",
            "\t\treturn x;",
            "\t}",
            "\tstatic_modint(): v(0) {}",
            "\ttemplate <class T> static_modint(T x) {",
            "\t\tint y;",
            "\t\tif (x < 0) {",
            "\t\t\tif (x < -mod()) y = x % mod();",
            "\t\t\telse y = x;",
            "\t\t\tif (y < 0) y += mod();",
            "\t\t} else {",
            "\t\t\tif (x < mod()) y = x;",
            "\t\t\telse y = x % mod();",
            "\t\t}",
            "\t\tv = y;",
            "\t}",
            "\tunsigned int val() const { return v; }",
            "\tunsigned int operator () () const { return v; }",
            "\tmint & operator ++ () { if (++v == umod()) v = 0; return *this; }",
            "\tmint & operator -- () { if (!v) v = umod(); --v; return *this; }",
            "\tmint operator ++ (int) { mint old = *this; ++*this; return old; }",
            "\tmint operator -- (int) { mint old = *this; --*this; return old; }",
            "\tmint operator + () { return *this; }",
            "\tmint operator - () { return raw(!v ? 0 : umod() - v); }",
            "\tmint & operator += (const mint &rhs) { v += rhs.v; if (v >= umod()) v -= umod(); return *this; }",
            "\tmint & operator -= (const mint &rhs) { v -= rhs.v; if (v >= umod()) v += umod(); return *this; }",
            "\tmint & operator *= (const mint &rhs) {",
            "\t\tunsigned long long z = v; z *= rhs.v; v = z % umod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint & operator /= (const mint &rhs) { return *this *= rhs.inv(); }",
            "\tfriend mint operator + (const mint &lhs, const mint &rhs) { return mint(lhs) += rhs; }",
            "\tfriend mint operator - (const mint &lhs, const mint &rhs) { return mint(lhs) -= rhs; }",
            "\tfriend mint operator * (const mint &lhs, const mint &rhs) { return mint(lhs) *= rhs; }",
            "\tfriend mint operator / (const mint &lhs, const mint &rhs) { return mint(lhs) /= rhs; }",
            "\tmint pow(long long n) const {",
            "\t\tassert(0 <= n);",
            "\t\tmint res = 1, a = *this;",
            "\t\tfor (; n; n >>= 1, a *= a) if (n & 1) res *= a;",
            "\t\treturn res;",
            "\t}",
            "\tmint inv() const {",
            "\t\tint i = invGeneral((int) v, mod());",
            "\t\tassert(~i);",
            "\t\treturn i;",
            "\t}",
            "\tfriend bool operator == (const mint& lhs, const mint& rhs) { return lhs.v == rhs.v; }",
            "\tfriend bool operator != (const mint& lhs, const mint& rhs) { return lhs.v != rhs.v; }",
            "\tfriend ostream & operator << (ostream &out, const mint &x) { return out << x.v; }",
            "\tfriend istream & operator >> (istream &in, mint &x) { long long a; in >> a; x = a; return in; }",
            "\texplicit operator bool() const { return v; }",
            "\texplicit operator int() const { return v; }",
            "private:",
            "\tunsigned int v;",
            "\tstatic constexpr unsigned int umod() { return m; }",
            "};",
            "template <int id> struct dynamic_modint {",
            "using mint = dynamic_modint;",
            "public:",
            "\tstatic int mod() { return (int) bt.umod(); }",
            "\tstatic void set_mod(int m) {",
            "\t\tassert(1 <= m);",
            "\t\tbt = barrett(m);",
            "\t}",
            "\tstatic mint raw(int v) {",
            "\t\tmint x; x.v = v;",
            "\t\treturn x;",
            "\t}",
            "\tdynamic_modint(): v(0) {}",
            "\ttemplate <class T> dynamic_modint(T x) {",
            "\t\tint y;",
            "\t\tif (x < 0) {",
            "\t\t\tif (x < -mod()) y = x % mod();",
            "\t\t\telse y = x;",
            "\t\t\tif (y < 0) y += mod();",
            "\t\t} else {",
            "\t\t\tif (x < mod()) y = x;",
            "\t\t\telse y = x % mod();",
            "\t\t}",
            "\t\tv = y;",
            "\t}",
            "\tunsigned int val() const { return v; }",
            "\tunsigned int operator () () const { return v; }",
            "\tmint & operator ++ () { if (++v == umod()) v = 0; return *this; }",
            "\tmint & operator -- () { if (!v) v = umod(); --v; return *this; }",
            "\tmint operator ++ (int) { mint old = *this; ++*this; return old; }",
            "\tmint operator -- (int) { mint old = *this; --*this; return old; }",
            "\tmint operator + () { return *this; }",
            "\tmint operator - () { return raw(!v ? 0 : umod() - v); }",
            "\tmint & operator += (const mint &rhs) { v += rhs.v; if (v >= umod()) v -= umod(); return *this; }",
            "\tmint & operator -= (const mint &rhs) { v -= rhs.v; if (v >= umod()) v += umod(); return *this; }",
            "\tmint & operator *= (const mint &rhs) {",
            "\t\tv = bt.mul(v, rhs.v);",
            "\t\treturn *this;",
            "\t}",
            "\tmint & operator /= (const mint &rhs) { return *this *= rhs.inv(); }",
            "\tfriend mint operator + (const mint &lhs, const mint &rhs) { return mint(lhs) += rhs; }",
            "\tfriend mint operator - (const mint &lhs, const mint &rhs) { return mint(lhs) -= rhs; }",
            "\tfriend mint operator * (const mint &lhs, const mint &rhs) { return mint(lhs) *= rhs; }",
            "\tfriend mint operator / (const mint &lhs, const mint &rhs) { return mint(lhs) /= rhs; }",
            "\tmint pow(long long n) const {",
            "\t\tassert(0 <= n);",
            "\t\tmint res = 1, a = *this;",
            "\t\tfor (; n; n >>= 1, a *= a) if (n & 1) res *= a;",
            "\t\treturn res;",
            "\t}",
            "\tmint inv() const {",
            "\t\tint i = invGeneral((int) v, mod());",
            "\t\tassert(~i);",
            "\t\treturn i;",
            "\t}",
            "\tfriend bool operator == (const mint& lhs, const mint& rhs) { return lhs.v == rhs.v; }",
            "\tfriend bool operator != (const mint& lhs, const mint& rhs) { return lhs.v != rhs.v; }",
            "\tfriend ostream & operator << (ostream &out, const mint &x) { return out << x.v; }",
            "\tfriend istream & operator >> (istream &in, mint &x) { long long a; in >> a; x = a; return in; }",
            "\texplicit operator bool() const { return v; }",
            "\texplicit operator int() const { return v; }",
            "private:",
            "\tunsigned int v;",
            "\tstatic barrett bt;",
            "\tstatic unsigned int umod() { return bt.umod(); }",
            "};",
            "template <int id> barrett dynamic_modint<id>::bt(998244353);",
            "using modint998244353 = static_modint<998244353>;",
            "using modint1000000007 = static_modint<1000000007>;",
            "using modint = dynamic_modint <-1>;",
            "using Modular = modint1000000007;",
            "} using namespace MODINT;",
            ""
        ],
        "description": "MODINT"
    },
    "MO_ALGORITHM": {
        "scope": "cpp",
        "prefix": "MO_ALGORITHM",
        "body": [
            "long long gilbertOrder(int x, int y, int p, int r) {",
            "\tif (p == 0) return 0;",
            "\tint h = 1 << (p - 1);",
            "\tint s = x < h ? y < h ? 0 : 3 : y < h ? 1 : 2;",
            "\ts = (s + r) & 3;",
            "\tconst int d[4] = {3, 0, 0, 1};",
            "\tint nx = x & (x ^ h), ny = y & (y ^ h);",
            "\tint nrot = (r + d[s]) & 3;",
            "\tlong long t = 1LL << (2 * p - 2);",
            "\tlong long ans = s * t;",
            "\tlong long add = gilbertOrder(nx, ny, p - 1, nrot);",
            "\tans += s == 1 || s == 2 ? add : t - add - 1;",
            "\treturn ans;",
            "}",
            "",
            "struct Query {",
            "\tint l, r, idx;",
            "\tlong long ord;",
            "\tvoid calcOrder() { ord = gilbertOrder(l, r, 21, 0); }",
            "};",
            ""
        ],
        "description": "MO_ALGORITHM"
    },
    "MIN_COST_FLOW": {
        "scope": "cpp",
        "prefix": "MIN_COST_FLOW",
        "body": [
            "struct MaxFlowMinCost {",
            "",
            "\tstatic const long long FLOW_INF = 1e18;",
            "",
            "\tstruct Edge {",
            "\t\tint from, to;",
            "\t\tlong long flow, cost, capa;",
            "\t\tEdge(int u = 0, int v = 0, long long ca = 0, long long co = 0):",
            "\t\t\tfrom(u), to(v), capa(ca), cost(co), flow(0) {};",
            "\t\tlong long residual(void) const { return capa - flow; }",
            "\t\tbool saturating(void) { return !residual(); }",
            "\t};",
            "",
            "\tint n;",
            "\tvector <vector <int>> adj;",
            "\tvector <Edge> edges;",
            "\tvector <long long> dist, trace;",
            "",
            "\tMaxFlowMinCost(int _n = 0) {",
            "\t\tn = _n;",
            "\t\tadj.assign(n + 5, vector <int> ());",
            "\t\tdist.assign(n + 5, 0);",
            "\t\ttrace.assign(n + 5, 0);",
            "\t}",
            "",
            "\tint addEdge(int u, int v, long long ca, long long co) {",
            "\t\tadj[u].push_back(edges.size());",
            "\t\tedges.push_back(Edge(u, v, ca, co));",
            "\t\tadj[v].push_back(edges.size());",
            "\t\tedges.push_back(Edge(v, u, 0, -co));",
            "\t\treturn edges.size() - 2;",
            "\t}",
            "",
            "\tbool FordBellman(int s, int t) {",
            "\t\tfor (int i = 0; i <= n; ++i) {",
            "\t\t\tdist[i] = FLOW_INF;",
            "\t\t\ttrace[i] = -1;",
            "\t\t}",
            "\t\tvector <int> inQueue(n + 5, false);",
            "\t\tqueue <int> q;",
            "\t\tdist[s] = 0; q.push(s), inQueue[s] = true;",
            "\t\twhile (!q.empty()) {",
            "\t\t\tint u = q.front(); q.pop(); inQueue[u] = false;",
            "\t\t\tfor (int id: adj[u]) if (edges[id].residual() > 0) {",
            "\t\t\t\tint v = edges[id].to;",
            "\t\t\t\tif (dist[v] > dist[u] + edges[id].cost) {",
            "\t\t\t\t\tdist[v] = dist[u] + edges[id].cost;",
            "\t\t\t\t\ttrace[v] = id;",
            "\t\t\t\t\tif (!inQueue[v]) {",
            "\t\t\t\t\t\tq.push(v);",
            "\t\t\t\t\t\tinQueue[v] = true;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn dist[t] < FLOW_INF;",
            "\t}",
            "",
            "\tpair <long long, long long> getFlow(int s, int t) {",
            "\t\tfor (Edge &e: edges) e.flow = 0;",
            "\t\tlong long totFlow = 0, totCost = 0;",
            "\t\twhile (FordBellman(s, t)) {",
            "\t\t\tlong long delta = FLOW_INF;",
            "\t\t\tfor (int u = t; u != s; u = edges[trace[u]].from) ",
            "\t\t\t\tdelta = min(delta, edges[trace[u]].residual());",
            "\t\t\tfor (int u = t; u != s; u = edges[trace[u]].from) {",
            "\t\t\t\tedges[trace[u]].flow += delta;",
            "\t\t\t\tedges[trace[u] ^ 1].flow -= delta;",
            "\t\t\t}",
            "\t\t\ttotFlow += delta;",
            "\t\t\ttotCost += delta * dist[t];",
            "\t\t}",
            "\t\treturn make_pair(totFlow, totCost);",
            "\t}",
            "",
            "\tbool saturating(int s, int t) {",
            "\t\tgetFlow(s, t);",
            "\t\tfor (int &id: adj[s]) if (!edges[id].saturating()) return false;",
            "\t\treturn true;",
            "\t}",
            "",
            "};",
            ""
        ],
        "description": "MIN_COST_FLOW"
    },
    "MAXMIN": {
        "scope": "cpp",
        "prefix": "MAXMIN",
        "body": [
            "template <class A, class B> bool minimize(A &a, B b)  { return a > b ? a = b, true : false; }",
            "template <class A, class B> bool maximize(A &a, B b)  { return a < b ? a = b, true : false; }",
            ""
        ],
        "description": "MAXMIN"
    },
    "MATRIX": {
        "scope": "cpp",
        "prefix": "MATRIX",
        "body": [
            "template <class T> struct Matrix {",
            "\tint numRow, numCol; vector <T> val;",
            "\t// accessors",
            "\ttypename vector<T>::iterator operator [] (int r) { return val.begin() + r * numCol; }",
            "\tinline T & at(int r, int c) { return val[r * numCol + c]; }",
            "\tinline T get(int r, int c) const { return val[r * numCol + c]; }",
            "\t// constructors",
            "\tMatrix() {}",
            "\tMatrix(int r, int c): numRow(r), numCol(c), val(r * c) {}",
            "\tMatrix(const vector <vector <T>> &d) {",
            "\t\tnumRow = d.size();",
            "\t\tnumCol = numRow ? d[0].size() : 0;",
            "\t\tfor (int i = 0; i < numRow; ++i) {",
            "\t\t\tassert((int) d[i].size() == numCol);",
            "\t\t\tcopy(d[i].begin(), d[i].end(), back_inserter(val));",
            "\t\t}",
            "\t}",
            "\tMatrix & set_value(T v) {",
            "\t\tfor (int i = 0; i < numRow * numCol; ++i) val[i] = v;",
            "\t\treturn *this;",
            "\t}",
            "\t// convert to 2D vector",
            "\tvector <vector <T>> vecvec(void) const {",
            "\t\tvector <vector <T>> res(numRow);",
            "\t\tfor (int i = 0; i < numRow; ++i)",
            "\t\t\tcopy(val.begin() + i * numCol, val.begin() + (i + 1) * numCol, back_inserter(res[i]));",
            "\t\treturn res;",
            "\t}",
            "\toperator vector <vector <T>> () const { return vecvec(); }",
            "\tstatic Matrix identity(int n) {",
            "\t\tMatrix res(n, n);",
            "\t\tfor (int i = 0; i < n; ++i) res.at(i, i) = T(1);",
            "\t\treturn res;",
            "\t}",
            "\tfriend istream & operator >> (istream &in, Matrix &res) {",
            "\t\tfor (T &x: res.val) in >> x;",
            "\t\treturn in;",
            "\t}",
            "\tfriend ostream & operator << (ostream &out, const Matrix &res) {",
            "\t\tfor (int i = 0; i < res.numRow * res.numCol; ++i)",
            "\t\t\tcout << res.val[i] << \" \\n\"[i % res.numCol == res.numCol - 1];",
            "\t\treturn out;",
            "\t}",
            "\tMatrix operator - (void) {",
            "\t\tMatrix res(numRow, numCol);",
            "\t\tfor (int i = 0; i < numRow * numCol; ++i) res.val[i] = -val[i];",
            "\t\treturn res;",
            "\t}",
            "\tMatrix operator * (const T &v) {",
            "\t\tMatrix res = *this;",
            "\t\tfor (T &x: res.val) x *= v;",
            "\t\treturn res;",
            "\t} ",
            "\tMatrix operator / (const T &v) {",
            "\t\tMatrix res = *this;",
            "\t\tconst T inv = T(1) / v;",
            "\t\tfor (T &x: res.val) x *= inv;",
            "\t\treturn res;",
            "\t}",
            "\tMatrix operator + (const Matrix &other) const {",
            "\t\tint M = numRow, N = numCol;",
            "\t\tassert(M == other.numRow); assert(N == other.numCol);",
            "\t\tMatrix res = *this;",
            "\t\tfor (int i = 0; i < numRow * numCol; ++i) res.val[i] += other.val[i];",
            "\t\treturn res;",
            "\t}",
            "\tMatrix operator - (const Matrix &other) const {",
            "\t\tint M = numRow, N = numCol;",
            "\t\tassert(M == other.numRow); assert(N == other.numCol);",
            "\t\tMatrix res = *this;",
            "\t\tfor (int i = 0; i < numRow * numCol; ++i) res.val[i] -= other.val[i];",
            "\t\treturn res;",
            "\t}",
            "\tMatrix operator * (const Matrix &other) const {",
            "\t\tint M = numRow, N = numCol, P = other.numCol;",
            "\t\tassert(N == other.numRow);",
            "\t\tMatrix t_other = other.transpose();",
            "\t\tMatrix res(M, P);",
            "\t\tfor (int i = 0; i < M; ++i)",
            "\t\t\tfor (int j = 0; j < P; ++j)",
            "\t\t\t\tres.at(i, j) = inner_product(this->val.begin() + N * i, this->val.begin() + N * (i + 1), t_other.val.begin() + t_other.numCol * j, T(0));",
            "\t\treturn res;",
            "\t}",
            "\tMatrix & operator *= (const T &v) { return *this = *this * v; }",
            "\tMatrix & operator /= (const T &v) { return *this = *this / v; }",
            "\tMatrix & operator += (const Matrix &other) { return *this = *this + other; }",
            "\tMatrix & operator -= (const Matrix &other) { return *this = *this - other; }",
            "\tMatrix & operator *= (const Matrix &other) { return *this = *this * other; }",
            "\tMatrix pow(long long Exp) const {",
            "\t\tint M = numRow;",
            "\t\tassert(M == numCol); assert(Exp >= 0);",
            "\t\tMatrix res = identity(M);",
            "\t\tif (!Exp) return res;",
            "\t\tbool is_id = true;",
            "\t\tfor (int i = 63 - __builtin_clzll(Exp); i >= 0; --i) {",
            "\t\t\tif (!is_id) res *= res;",
            "\t\t\tif (Exp >> i & 1) res *= *this, is_id = false;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tMatrix transpose(void) const {",
            "\t\tMatrix res(numCol, numRow);",
            "\t\tfor (int i = 0; i < numRow; ++i)",
            "\t\t\tfor (int j = 0; j < numCol; ++j)",
            "\t\t\t\tres.at(j, i) = this->get(i, j);",
            "\t\treturn res;",
            "\t}",
            "};",
            ""
        ],
        "description": "MATRIX"
    },
    "LINE_CONTAINER": {
        "scope": "cpp",
        "prefix": "LINE_CONTAINER",
        "body": [
            "struct Line {",
            "\tmutable long long k, m, p;",
            "\tLine(long long k, long long m, long long p): k(k), m(m), p(p) {}",
            "\tbool operator < (const Line& o) const { return k < o.k; }",
            "\tbool operator < (long long x) const { return p < x; }",
            "};",
            "struct LineContainer: multiset <Line, less<>> {",
            "\t// (for doubles, use inf = 1/.0, div(a,b) = a/b)",
            "\tstatic const long long inf = 4e18;",
            "\tlong long div(long long a, long long b) { // floored division",
            "\t\treturn a / b - ((a ^ b) < 0 && a % b);",
            "\t}",
            "\tbool isect(iterator x, iterator y) {",
            "\t\tif (y == end()) return x->p = inf, 0;",
            "\t\tif (x->k == y->k) x->p = x->m > y->m ? inf : -inf;",
            "\t\telse x->p = div(y->m - x->m, x->k - y->k);",
            "\t\treturn x->p >= y->p;",
            "\t}",
            "\tvoid add(long long k, long long m) {",
            "\t\tauto z = emplace(k, m, 0), y = z++, x = y;",
            "\t\twhile (isect(y, z)) z = erase(z);",
            "\t\tif (x != begin() && isect(--x, y)) isect(x, y = erase(y));",
            "\t\twhile ((y = x) != begin() && (--x)->p >= y->p)",
            "\t\t\tisect(x, erase(y));",
            "\t}",
            "\tlong long query(long long x) {",
            "\t\tassert(!empty());",
            "\t\tauto l = *lower_bound(x);",
            "\t\treturn l.k * x + l.m;",
            "\t}",
            "};",
            ""
        ],
        "description": "LINE_CONTAINER"
    },
    "LICHAO_TREE": {
        "scope": "cpp",
        "prefix": "LICHAO_TREE",
        "body": [
            "// not tested yet",
            "template<",
            "\tclass T,  // for segment & coordinates data types, e.g. long long",
            "\tclass TM  // for intermediate computations, e.g. __int128_t",
            "> ",
            "struct LichaoTree {",
            "\tstruct Line {",
            "\t\tT a, b;",
            "\t\tint id;",
            "\t\tbool is_valid;",
            "\t\tLine(T a, T b, int id, bool is_valid): a(a), b(b), id(id), is_valid(is_valid) {}",
            "\t\tTM eval(T x) { return TM(a) * x + b; }",
            "\t};",
            "\tstruct Result {",
            "\t\tT line_a, line_b;",
            "\t\tint line_id;",
            "\t\tbool is_valid;",
            "\t\tTM min_val;",
            "\t\tResult(T a, T b, int id, bool iv, TM m): line_a(a), line_b(b), line_id(id), is_valid(iv), min_val(m) {}",
            "\t};",
            "\tint n, size, log;",
            "\tvector <T> xs;",
            "\tvector <Line> lines;",
            "\tLichaoTree(const vector <T> &_xs): xs(_xs) {",
            "\t\tsort(xs.begin(), xs.end());",
            "\t\txs.erase(unique(ALL(xs)), xs.end());",
            "\t\tn = xs.size();",
            "\t\tlog = 0;",
            "\t\twhile ((1 << log) < n) ++log;",
            "\t\tsize = 1 << log;",
            "\t\txs.resize(size, xs.back());",
            "\t\tlines.assign(size << 1, Line(0, 0, -1, false));",
            "\t}",
            "\tvoid update(int i, int l, int r, int u, int v, Line line) {",
            "\t\tif (l >= v || r <= u) return;",
            "\t\tif (u <= l && r <= v) {",
            "\t\t\tif (!lines[i].is_valid) {",
            "\t\t\t\tlines[i] = line;",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "\t\t\tint m = l + r >> 1;",
            "\t\t\tbool lef = line.eval(l) < lines[i].eval(l);",
            "\t\t\tbool mid = line.eval(m) < lines[i].eval(m);",
            "\t\t\tif (mid) swap(lines[i], line);",
            "\t\t\tif (r - l == 1) return;",
            "\t\t\ti << 1;",
            "\t\t\tif (lef != mid) i <<= 1, r = m;",
            "\t\t\telse i = i << 1 | 1, l = m;",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint m = l + r >> 1;",
            "\t\tupdate(i << 1, l, m, u, v, line);",
            "\t\tupdate(i << 1 | 1, m, r, u, v, line);",
            "\t};",
            "\tvoid add_line(T a, T b, int id = -1) {",
            "\t\tupdate(1, 0, size, 0, size, Line(a, b, id, true));",
            "\t}",
            "\tvoid add_segment(T l, T r, T a, T b, int id = -1) {",
            "\t\tl = lower_bound(ALL(xs), l) - xs.begin();",
            "\t\tr = upper_bound(ALL(xs), r) - xs.begin();",
            "\t\tif (l >= r) return;",
            "\t\tupdate(1, 0, size, l, r, Line(a, b, id, true));",
            "\t}",
            "\tResult get(T x) {",
            "\t\tint i = lower_bound(xs.begin(), xs.end(), x) - xs.begin();",
            "\t\tLine res = lines[i];",
            "\t\tTM val = res.eval(x);",
            "\t\tfor (i += size; (i >>= 1) > 0; ) if (lines[i].is_valid) {",
            "\t\t\tTM cur = lines[i].eval(x);",
            "\t\t\tif (!res.is_valid || val > cur) res = lines[i], val = cur;",
            "\t\t}",
            "\t\treturn Result(res.a, res.b, res.id, res.is_valid, val);",
            "\t}",
            "};",
            ""
        ],
        "description": "LICHAO_TREE"
    },
    "LCA_RMQ": {
        "scope": "cpp",
        "prefix": "LCA_RMQ",
        "body": [
            "struct LCA {",
            "\tint n, root;",
            "\tvector <vector <int>> adj;",
            "\tvector <int> tin, tout, depth;",
            "\tvector <pair <int, int>> order;",
            "\tvector <vector <int>> rmq;",
            "\tLCA(const vector <vector <int>> & _adj, int _root): n(_adj.size()), root(_root), adj(_adj) { build(); }",
            "\tLCA(const vector <vector <pair <int, int>>> & _adj, int _root): n(_adj.size()), root(_root) {",
            "\t\tadj.resize(n);",
            "\t\tfor (int u = 0; u < (int) adj.size(); ++u) {",
            "\t\t\tadj[u].reserve(_adj[u].size());",
            "\t\t\tfor (auto [w, v]: _adj[u]) adj[u].push_back(v);",
            "\t\t}",
            "\t\tbuild();",
            "\t}",
            "\tvoid build(void) {",
            "\t\tassert(0 <= root && root < n);",
            "\t\ttin.resize(n);",
            "\t\ttout.resize(n);",
            "\t\tdepth.resize(n);",
            "\t\torder.reserve(2 * n - 1);",
            "\t\tdepth[root] = 0;",
            "\t\trmq.emplace_back(0);",
            "\t\tdfs(root, -1);",
            "\t\tint m = rmq[0].size();",
            "\t\tfor (int k = 1; (1 << k) <= m; ++k) {",
            "\t\t\trmq.emplace_back(m - (1 << k) + 1);",
            "\t\t\tfor (int i = 0; i + (1 << k) <= m; ++i) rmq[k][i] = op(rmq[k - 1][i], rmq[k - 1][i + (1 << (k - 1))]);",
            "\t\t}",
            "\t}",
            "\tbool is_anc(int x, int y) { return tin[x] <= tin[y] && tout[y] <= tout[x]; }",
            "\tint op(int x, int y) { return depth[x] < depth[y] ? x : y; }",
            "\tvoid dfs(int u, int par) {",
            "\t\ttin[u] = rmq[0].size();",
            "\t\trmq[0].push_back(u);",
            "\t\tfor (int v: adj[u]) if (v != par) {",
            "\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\tdfs(v, u);",
            "\t\t\trmq[0].push_back(u);",
            "\t\t}",
            "\t\ttout[u] = rmq[0].size();",
            "\t}",
            "\tint lca(int u, int v) {",
            "\t\tassert(0 <= u && u < n);",
            "\t\tassert(0 <= v && v < n);",
            "\t\tu = tin[u]; v = tin[v];",
            "\t\tif (u > v) swap(u, v);",
            "\t\tint h = __lg(v - u + 1);",
            "\t\treturn op(rmq[h][u], rmq[h][v - (1 << h) + 1]);",
            "\t}",
            "};",
            ""
        ],
        "description": "LCA_RMQ"
    },
    "LCA_BL": {
        "scope": "cpp",
        "prefix": "LCA_BL",
        "body": [
            "struct LCA {",
            "\tint n, root, t, log;",
            "\tvector <vector <int>> adj, anc;",
            "\tvector <int> tin, tout, depth;",
            "\tLCA(const vector <vector <int>> & _adj, int _root): n(_adj.size()), root(_root), adj(_adj) { build(); }",
            "\tLCA(const vector <vector <pair <int, int>>> & _adj, int _root): n(_adj.size()), root(_root) {",
            "\t\tadj.resize(n);",
            "\t\tfor (int u = 0; u < (int) adj.size(); ++u) {",
            "\t\t\tadj[u].reserve(_adj[u].size());",
            "\t\t\tfor (auto [w, v]: _adj[u]) adj[u].push_back(v);",
            "\t\t}",
            "\t\tbuild();",
            "\t}",
            "\tvoid build(void) {",
            "\t\tassert(0 <= root && root < n);",
            "\t\tlog = 1;",
            "\t\twhile ((1 << log) < n) ++log;",
            "\t\tanc.resize(n, vector<int>(log, -1));",
            "\t\ttin.resize(n);",
            "\t\ttout.resize(n);",
            "\t\tdepth.resize(n);",
            "\t\tdepth[root] = 0;",
            "\t\tt = 0;",
            "\t\tdfs(root);",
            "\t}",
            "\tvoid dfs(int u) {",
            "\t\ttin[u] = t++;",
            "\t\tfor (int v: adj[u]) if (v != anc[u][0]) {",
            "\t\t\tanc[v][0] = u;",
            "\t\t\tfor (int i = 1; i < log; ++i) {",
            "\t\t\t\tanc[v][i] = anc[anc[v][i - 1]][i - 1];",
            "\t\t\t\tif (anc[v][i] == -1) break;",
            "\t\t\t}",
            "\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\tdfs(v);",
            "\t\t}",
            "\t\ttout[u] = t;",
            "\t}",
            "\tint lca(int u, int v) {",
            "\t\tassert(0 <= u && u < n);",
            "\t\tassert(0 <= v && v < n);",
            "\t\tif (depth[u] < depth[v]) swap(u, v);",
            "\t\tint h = depth[u] - depth[v];",
            "\t\tfor (int i = 0; i < log; ++i) if (h >> i & 1) u = anc[u][i];",
            "\t\tif (u == v) return u;",
            "\t\tfor (int i = log - 1; i >= 0; --i) if (anc[u][i] != anc[v][i]) {",
            "\t\t\tu = anc[u][i];",
            "\t\t\tv = anc[v][i];",
            "\t\t}",
            "\t\treturn anc[u][0];",
            "\t}",
            "};",
            ""
        ],
        "description": "LCA_BL"
    },
    "LAZY_SEGTREE": {
        "scope": "cpp",
        "prefix": "LAZY_SEGTREE",
        "body": [
            "template <",
            "\tclass S,                 // node data type",
            "\tS (*op) (S, S),          // combine 2 nodes",
            "\tS (*e) (),               // identity element",
            "\tclass F,                 // lazy propagation tag",
            "\tS (*mapping) (F, S),     // apply tag F on a node",
            "\tF (*composition) (F, F), // combine 2 tags",
            "\tF (*id)()                // identity tag",
            "\t>",
            "struct LazySegTree {",
            "\tLazySegTree() : LazySegTree(0) {}",
            "\tLazySegTree(int n) : LazySegTree(vector<S>(n, e())) {}",
            "\tLazySegTree(const vector <S> &v) : n(v.size()) {",
            "\t\tlog = 0;",
            "\t\twhile ((1 << log) < n) ++log;",
            "\t\tsize = 1 << log;",
            "\t\td = vector<S>(size << 1, e());",
            "\t\tlz = vector<F>(size, id());",
            "\t\tfor (int i = 0; i < n; ++i) d[i + size] = v[i];",
            "\t\tfor (int i = size - 1; i > 0; --i) update(i);",
            "\t}",
            "",
            "\t// 0 <= p < n",
            "\tvoid set(int p, S x) {",
            "\t\tassert(0 <= p && p < n);",
            "\t\tp += size;",
            "\t\tfor (int i = log; i > 0; --i) push(p >> i);",
            "\t\td[p] = x;",
            "\t\tfor (int i = 1; i <= log; ++i) update(p >> i);",
            "\t}",
            "",
            "\t// 0 <= p < n",
            "\tS get(int p) {",
            "\t\tassert(0 <= p && p < n);",
            "\t\tp += size;",
            "\t\tfor (int i = log; i > 0; --i) push(p >> i);",
            "\t\treturn d[p];",
            "\t}",
            "",
            "\t// Get product in range [l, r-1]",
            "\t// 0 <= l <= r <= n",
            "\t// For empty segment (l == r) -> return e()",
            "\tS prod(int l, int r) {",
            "\t\tassert(0 <= l && l <= r && r <= n);",
            "\t\tif (l == r) return e();",
            "\t\tl += size; r += size;",
            "\t\tfor (int i = log; i > 0; --i) {",
            "\t\t\tif (((l >> i) << i) != l) push(l >> i);",
            "\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);",
            "\t\t}",
            "\t\tS sml = e(), smr = e();",
            "\t\twhile (l < r) {",
            "\t\t\tif (l & 1) sml = op(sml, d[l++]);",
            "\t\t\tif (r & 1) smr = op(d[--r], smr);",
            "\t\t\tl >>= 1; r >>= 1;",
            "\t\t}",
            "\t\treturn op(sml, smr);",
            "\t}",
            "",
            "\tS all_prod() { return d[1]; }",
            "",
            "\t// 0 <= p < n",
            "\tvoid apply(int p, F f) {",
            "\t\tassert(0 <= p && p < n);",
            "\t\tp += size;",
            "\t\tfor (int i = log; i > 0; --i) push(p >> i);",
            "\t\td[p] = mapping(f, d[p]);",
            "\t\tfor (int i = 1; i <= log; ++i) update(p >> i);",
            "\t}",
            "",
            "\t// Apply f on all elements in range [l, r-1]",
            "\t// 0 <= l <= r <= n",
            "\tvoid apply(int l, int r, F f) {",
            "\t\tassert(0 <= l && l <= r && r <= n);",
            "\t\tif (l == r) return;",
            "\t\tl += size; r += size;",
            "\t\tfor (int i = log; i > 0; --i) {",
            "\t\t\tif (((l >> i) << i) != l) push(l >> i);",
            "\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);",
            "\t\t}",
            "\t\tint l2 = l, r2 = r;",
            "\t\twhile (l < r) {",
            "\t\t\tif (l & 1) all_apply(l++, f);",
            "\t\t\tif (r & 1) all_apply(--r, f);",
            "\t\t\tl >>= 1; r >>= 1;",
            "\t\t}",
            "\t\tl = l2; r = r2;",
            "\t\tfor (int i = 1; i <= log; ++i) {",
            "\t\t\tif (((l >> i) << i) != l) update(l >> i);",
            "\t\t\tif (((r >> i) << i) != r) update((r - 1) >> i);",
            "\t\t}",
            "\t}",
            "",
            "\t// Binary search on SegTree to find largest r:",
            "\t//\tf(op(a[l] .. a[r-1])) = true   (assuming empty array is always true)",
            "\t//\tf(op(a[l] .. a[r])) = false\t(assuming op(..., a[n]), which is out of bound, is always false)",
            "\ttemplate <bool (*g)(S)> int max_right(int l) { return max_right(l, [](S x) { return g(x); }); }",
            "\ttemplate <class G> int max_right(int l, G g) {",
            "\t\tassert(0 <= l && l <= n);",
            "\t\tassert(g(e()));",
            "\t\tif (l == n) return n;",
            "\t\tl += size;",
            "\t\tfor (int i = log; i > 0; --i) push(l >> i);",
            "\t\tS sm = e();",
            "\t\tdo {",
            "\t\t\twhile (!(l & 1)) l >>= 1;",
            "\t\t\tif (!g(op(sm, d[l]))) {",
            "\t\t\t\twhile (l < size) {",
            "\t\t\t\t\tpush(l);",
            "\t\t\t\t\tl = l << 1;",
            "\t\t\t\t\tif (g(op(sm, d[l]))) {",
            "\t\t\t\t\t\tsm = op(sm, d[l]);",
            "\t\t\t\t\t\tl++;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\treturn l - size;",
            "\t\t\t}",
            "\t\t\tsm = op(sm, d[l]);",
            "\t\t\tl++;",
            "\t\t} while ((l & -l) != l);",
            "\t\treturn n;",
            "\t}",
            "",
            "\t// Binary search on SegTree to find smallest l:",
            "\t//\tf(op(a[l] .. a[r-1])) = true\t  (assuming empty array is always true)",
            "\t//\tf(op(a[l-1] .. a[r-1])) = false   (assuming op(a[-1], ..), which is out of bound, is always false)",
            "\ttemplate <bool (*g)(S)> int min_left(int r) { return min_left(r, [](S x) { return g(x); }); }",
            "\ttemplate <class G> int min_left(int r, G g) {",
            "\t\tassert(0 <= r && r <= n);",
            "\t\tassert(g(e()));",
            "\t\tif (!r) return 0;",
            "\t\tr += size;",
            "\t\tfor (int i = log; i > 0; --i) push((r - 1) >> i);",
            "\t\tS sm = e();",
            "\t\tdo {",
            "\t\t\tr--;",
            "\t\t\twhile (r > 1 && (r & 1)) r >>= 1;",
            "\t\t\tif (!g(op(d[r], sm))) {",
            "\t\t\t\twhile (r < size) {",
            "\t\t\t\t\tpush(r);",
            "\t\t\t\t\tr = r << 1 | 1;",
            "\t\t\t\t\tif (g(op(d[r], sm))) {",
            "\t\t\t\t\t\tsm = op(d[r], sm);",
            "\t\t\t\t\t\tr--;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\treturn r + 1 - size;",
            "\t\t\t}",
            "\t\t\tsm = op(d[r], sm);",
            "\t\t} while ((r & -r) != r);",
            "\t\treturn 0;",
            "\t}",
            "",
            "private:",
            "\tint n, size, log;",
            "\tvector<S> d;",
            "\tvector<F> lz;",
            "\tvoid update(int k) { d[k] = op(d[k << 1], d[k << 1 | 1]); }",
            "\tvoid all_apply(int k, F f) {",
            "\t\td[k] = mapping(f, d[k]);",
            "\t\tif (k < size) lz[k] = composition(f, lz[k]);",
            "\t}",
            "\tvoid push(int k) {",
            "\t\tall_apply(k << 1, lz[k]);",
            "\t\tall_apply(k << 1 | 1, lz[k]);",
            "\t\tlz[k] = id();",
            "\t}",
            "};",
            ""
        ],
        "description": "LAZY_SEGTREE"
    },
    "KNUTH_MORRIS_PRATT": {
        "scope": "cpp",
        "prefix": "KNUTH_MORRIS_PRATT",
        "body": [
            "template <typename T> vector <int> kmp_table(int n, const T &s) {",
            "\tvector<int> pi(n);",
            "\tfor (int i = 1; i < n; i++) {",
            "\t\tint &j = pi[i];",
            "\t\tj = pi[i - 1];",
            "\t\twhile (j > 0 && s[i] != s[j]) j = pi[j - 1];",
            "\t\tif (s[i] == s[j]) j++;",
            "\t}",
            "\treturn pi;",
            "}",
            "template <typename T> vector <int> kmp_table(const T &s) { return kmp_table(s.size(), s); }",
            "template <typename T> vector <int> kmp_search(int n, const T &s, int m, const T &w, const vector <int> &pi) {",
            "\tassert(n >= 1 && (int) pi.size() == n);",
            "\tvector <int> res;",
            "\tint j = 0;",
            "\tfor (int i = 0; i < m; i++) {",
            "\t\twhile (j > 0 && (j == n || w[i] != s[j])) j = pi[j - 1];",
            "\t\tif (w[i] == s[j]) j++;",
            "\t\tif (j == n) res.push_back(i - n + 1);",
            "\t}",
            "\treturn res;",
            "}",
            "template <typename T> vector <int> kmp_search(const T &s, const T &w, const vector <int> &pi) { return kmp_search(s.size(), s, w.size(), w, pi); }",
            ""
        ],
        "description": "KNUTH_MORRIS_PRATT"
    },
    "GRAPH": {
        "scope": "cpp",
        "prefix": "GRAPH",
        "body": [
            "namespace GRAPH {",
            "template <typename T> class graph {",
            "public:",
            "\tstruct edge {",
            "\t\tint from, to; T cost;",
            "\t\tedge(int from, int to, T cost): from(from), to(to), cost(cost) {}",
            "\t};",
            "\tvector <edge> edges;",
            "\tint n;",
            "\tvector <vector<int>> adj;",
            "\tgraph(int _n): n(_n), adj(_n) {}",
            "\tvirtual int add(int from, int to, T cost) = 0;",
            "};",
            "template <typename T> class undigraph: public graph<T> {",
            "public:",
            "\tusing graph<T>::edges, graph<T>::adj, graph<T>::n;",
            "\tundigraph(int _n): graph<T>(_n) {}",
            "\tint add(int u, int v, T cost = 1) {",
            "\t\tassert(0 <= u && u < n && 0 <= v && v < n);",
            "\t\tint i = (int) edges.size();",
            "\t\tadj[u].push_back(i);",
            "\t\tadj[v].push_back(i);",
            "\t\tedges.emplace_back(u, v, cost);",
            "\t\treturn i;",
            "\t}",
            "};",
            "template <typename T> class forest: public graph<T> {",
            "public:",
            "\tusing graph<T>::edges, graph<T>::adj, graph<T>::n;",
            "\tforest(int _n): graph<T>(_n) {}",
            "\tint add(int u, int v, T cost = 1) {",
            "\t\tassert(0 <= u && u < n && 0 <= v && v < n);",
            "\t\tint i = (int) edges.size();",
            "\t\tadj[u].push_back(i);",
            "\t\tadj[v].push_back(i);",
            "\t\tedges.emplace_back(u, v, cost);",
            "\t\treturn i;",
            "\t}",
            "};",
            "template <typename T> class dfs_undigraph: public undigraph<T> {",
            "public:",
            "\tusing undigraph<T>::edges, undigraph<T>::adj, undigraph<T>::n;",
            "\tvector <int> par, par_e, order, tin, tout, sz, root, depth, min_depth, was;",
            "\tvector<T> dist;",
            "\tint attempt;",
            "\tdfs_undigraph(int _n): undigraph<T>(_n) {}",
            "\tvoid init() {",
            "\t\tpar = par_e = tin = tout = root = depth = min_depth = was = vector<int>(n, -1);",
            "\t\torder.clear();",
            "\t\tsz = vector<int>(n, 0);",
            "\t\tdist = vector<T>(n);",
            "\t\tattempt = 0;",
            "\t}",
            "\tvoid clear() {",
            "\t\tpar.clear(); par_e.clear(); order.clear(); tin.clear(); tout.clear(); sz.clear();",
            "\t\troot.clear(); depth.clear(); min_depth.clear(); dist.clear(); was.clear();",
            "\t}",
            "private:",
            "\tvoid do_dfs(int u) {",
            "\t\twas[u] = attempt;",
            "\t\ttin[u] = (int) order.size();",
            "\t\torder.push_back(u);",
            "\t\tsz[u] = 1;",
            "\t\tmin_depth[u] = depth[u];",
            "\t\tfor (int i: adj[u]) if (i != par_e[u]) {",
            "\t\t\t\tauto &e = edges[i];",
            "\t\t\t\tint v = e.from ^ e.to ^ u;",
            "\t\t\t\tif (was[v] == attempt) min_depth[u] = min(min_depth[u], depth[v]);",
            "\t\t\t\telse {",
            "\t\t\t\t\troot[v] = root[u];",
            "\t\t\t\t\tpar[v] = u;",
            "\t\t\t\t\tpar_e[v] = i;",
            "\t\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\t\tdist[v] = dist[u] + e.cost;",
            "\t\t\t\t\tdo_dfs(v);",
            "\t\t\t\t\tsz[u] += sz[v];",
            "\t\t\t\t\tmin_depth[u] = min(min_depth[u], min_depth[v]);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\ttout[u] = order.size();",
            "\t}",
            "\tvoid dfs_from(int u) {",
            "\t\t++attempt;",
            "\t\tdepth[u] = 0; dist[u] = T{}; root[u] = u;",
            "\t\tpar[u] = par_e[u] = -1;",
            "\t\tdo_dfs(u);",
            "\t}",
            "public:",
            "\tvoid dfs(int u, bool clear_order = true) {",
            "\t\tif (par.empty()) init();",
            "\t\telse if (clear_order) order.clear();",
            "\t\tdfs_from(u);",
            "\t}",
            "\tvoid dfs_all() {",
            "\t\tinit();",
            "\t\tfor (int u = 0; u < n; u++) if (depth[u] == -1) dfs_from(u);",
            "\t}",
            "};",
            "template <typename T> class dfs_forest: public forest<T> {",
            "public:",
            "\tusing forest<T>::edges, forest<T>::adj, forest<T>::n;",
            "\tvector <int> par, par_e, order, tin, tout, sz, root, depth;",
            "\tvector<T> dist;",
            "\tdfs_forest(int _n): forest<T>(_n) {}",
            "\tvoid init() {",
            "\t\tpar = par_e = tin = tout = root = depth = vector<int>(n, -1);",
            "\t\torder.clear();",
            "\t\tsz = vector<int>(n, 0);",
            "\t\tdist = vector<T>(n);",
            "\t}",
            "\tvoid clear() {",
            "\t\tpar.clear(); par_e.clear(); order.clear(); tin.clear();",
            "\t\ttout.clear(); sz.clear(); root.clear(); depth.clear();",
            "\t}",
            "private:",
            "\tvoid do_dfs(int u) {",
            "\t\ttin[u] = order.size();",
            "\t\torder.push_back(u);",
            "\t\tsz[u] = 1;",
            "\t\tfor (int i: adj[u]) if (i != par_e[u]) {",
            "\t\t\t\tauto &e = edges[i];",
            "\t\t\t\tint v = e.from ^ e.to ^ u;",
            "\t\t\t\troot[v] = (root[u] != -1 ? root[u]: v);",
            "\t\t\t\tpar[v] = u;",
            "\t\t\t\tpar_e[v] = i;",
            "\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\tdist[v] = dist[u] + e.cost;",
            "\t\t\t\tdo_dfs(v);",
            "\t\t\t\tsz[u] += sz[v];",
            "\t\t\t}",
            "\t\ttout[u] = order.size();",
            "\t}",
            "\tvoid dfs_from(int u) {",
            "\t\tdepth[u] = 0;",
            "\t\tdist[u] = T{};",
            "\t\troot[u] = u;",
            "\t\tpar[u] = par_e[u] = -1;",
            "\t\tdo_dfs(u);",
            "\t}",
            "public:",
            "\tvoid dfs(int u, bool clear_order = true) {",
            "\t\tif (par.empty()) init();",
            "\t\telse if (clear_order) order.clear();",
            "\t\tdfs_from(u);",
            "\t}",
            "\tvoid dfs_all() {",
            "\t\tinit();",
            "\t\tfor (int u = 0; u < n; u++) if (depth[u] == -1) dfs_from(u);",
            "\t}",
            "\tbool is_anc(int x, int y) { return tin[x] <= tin[y] && tout[y] <= tout[x]; }",
            "};",
            "template <typename T> class lca_binlift_forest: public dfs_forest<T> {",
            "public:",
            "\tusing dfs_forest<T>::adj, dfs_forest<T>::n, dfs_forest<T>::par, dfs_forest<T>::depth, dfs_forest<T>::is_anc, dfs_forest<T>::root;",
            "\tint h;",
            "\tvector <vector <int>> anc;",
            "\tlca_binlift_forest(int _n): dfs_forest<T>(_n) {}",
            "\tvoid build_lca() {",
            "\t\tassert(!par.empty());",
            "\t\tint max_depth = *max_element(depth.begin(), depth.end());",
            "\t\th = 1; while ((1 << h) <= max_depth) h++;",
            "\t\tanc.resize(n);",
            "\t\tfor (int i = 0; i < n; ++i) {",
            "\t\t\tanc[i].resize(h);",
            "\t\t\tanc[i][0] = par[i];",
            "\t\t}",
            "\t\tfor (int j = 1; j < h; j++) for (int i = 0; i < n; ++i)",
            "\t\t\t\tanc[i][j] = (anc[i][j - 1] == -1 ? -1: anc[anc[i][j - 1]][j - 1]);",
            "\t}",
            "\tint go_up(int x, int up) {",
            "\t\tup = min(up, (1 << h) - 1);",
            "\t\tfor (int j = h; j-- > 0; ) if (up & (1 << j)) {",
            "\t\t\t\tx = anc[x][j];",
            "\t\t\t\tif (x == -1) break;",
            "\t\t\t}",
            "\t\treturn x;",
            "\t}",
            "\tint lca(int x, int y) {",
            "\t\tif (root[x] != root[y]) return -1;",
            "\t\tif (is_anc(x, y)) return x;",
            "\t\tif (is_anc(y, x)) return y;",
            "\t\tfor (int j = h; j-- > 0; ) if (anc[x][j] != -1 && !is_anc(anc[x][j], y)) x = anc[x][j];",
            "\t\treturn anc[x][0];",
            "\t}",
            "};",
            "template <typename T> class lca_rmq_forest: public dfs_forest<T> {",
            "public:",
            "\tusing dfs_forest<T>::edges, dfs_forest<T>::adj, dfs_forest<T>::n, dfs_forest<T>::par, dfs_forest<T>::depth, dfs_forest<T>::root;",
            "\tlca_rmq_forest(int _n): dfs_forest<T>(_n) {}",
            "\tvoid build_lca() {",
            "\t\tassert(!par.empty());",
            "\t\tpos.resize(n, -1);",
            "\t\trmq.emplace_back(0);",
            "\t\tfor (int i = 0; i < n; ++i) if (root[i] == i) do_dfs(i);",
            "\t\tint m = rmq[0].size();",
            "\t\tfor (int k = 1; (1 << k) <= m; ++k) {",
            "\t\t\trmq.emplace_back(m - (1 << k) + 1);",
            "\t\t\tfor (int i = 0; i + (1 << k) <= m; ++i) rmq[k][i] = op(rmq[k - 1][i], rmq[k - 1][i + (1 << (k - 1))]);",
            "\t\t}",
            "\t}",
            "private:",
            "\tint h;",
            "\tvector <vector <int>> rmq;",
            "\tvector <int> pos;",
            "\tint op(int x, int y) { return depth[x] < depth[y] ? x : y; }",
            "\tvoid do_dfs(int u) {",
            "\t\tpos[u] = rmq[0].size();",
            "\t\trmq[0].push_back(u);",
            "\t\tfor (int i: adj[u]) {",
            "\t\t\tauto &e = edges[i];",
            "\t\t\tint v = e.from ^ e.to ^ u;",
            "\t\t\tif (v == par[u]) continue;",
            "\t\t\tdo_dfs(v);",
            "\t\t\trmq[0].push_back(u);",
            "\t\t}",
            "\t}",
            "public:",
            "\tint lca(int u, int v) {",
            "\t\tif (root[u] != root[v]) return -1;",
            "\t\tu = pos[u]; v = pos[v];",
            "\t\tif (u > v) swap(u, v);",
            "\t\tint h = __lg(v - u + 1);",
            "\t\treturn op(rmq[h][u], rmq[h][v - (1 << h) + 1]);",
            "\t}",
            "};",
            "template <typename T> class hld_forest: public dfs_forest<T> {",
            "public:",
            "\tusing dfs_forest<T>::edges, dfs_forest<T>::adj, dfs_forest<T>::n, dfs_forest<T>::par, dfs_forest<T>::depth, dfs_forest<T>::sz, dfs_forest<T>::tin, dfs_forest<T>::order, dfs_forest<T>::root, dfs_forest<T>::dfs, dfs_forest<T>::dfs_all;",
            "\tvector <int> head, visited;",
            "\thld_forest(int _n) : dfs_forest<T>(_n), visited(_n) {}",
            "\tvoid build_hld(const vector <int> &vs) {",
            "\t\tfor (int tries = 0; tries < 2; ++tries) {",
            "\t\t\tif (vs.empty()) dfs_all();",
            "\t\t\telse {",
            "\t\t\t\torder.clear();",
            "\t\t\t\tfor (int v: vs) dfs(v, false);",
            "\t\t\t\tassert((int) order.size() == n);",
            "\t\t\t}",
            "\t\t\tif (tries) break;",
            "\t\t\tfor (int u = 0; u < n; ++u) {",
            "\t\t\t\tif (adj[u].empty()) continue;",
            "\t\t\t\tint best = -1, bid = 0;",
            "\t\t\t\tfor (int i = 0; i < (int) adj[u].size(); ++i) {",
            "\t\t\t\t\tint id = adj[u][i];",
            "\t\t\t\t\tint v = edges[id].from ^ edges[id].to ^ u;",
            "\t\t\t\t\tif (par[v] != u) continue;",
            "\t\t\t\t\tif (sz[v] > best) {",
            "\t\t\t\t\t\tbest = sz[v];",
            "\t\t\t\t\t\tbid = i;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\tswap(adj[u][0], adj[u][bid]);",
            "\t\t\t}",
            "\t\t}",
            "\t\thead.resize(n);",
            "\t\tiota(head.begin(), head.end(), 0);",
            "\t\tfor (int i = 0; i < n - 1; ++i) {",
            "\t\t\tint x = order[i];",
            "\t\t\tint y = order[i + 1];",
            "\t\t\tif (par[y] == x) head[y] = head[x];",
            "\t\t}",
            "\t}",
            "\tvoid build_hld(int v) { build_hld(vector<int>(1, v)); }",
            "\tvoid build_hld_all() { build_hld(vector<int>()); }",
            "\tint lca(int u, int v) {",
            "\t\tif (root[u] != root[v]) return -1;",
            "\t\twhile (head[u] != head[v]) {",
            "\t\t\tif (depth[head[u]] < depth[head[v]]) swap(u, v);",
            "\t\t\tu = par[head[u]];",
            "\t\t}",
            "\t\treturn tin[u] < tin[v] ? u : v;",
            "\t}",
            "\tint go_up(int x, int up) {",
            "\t\tint target = depth[x] - up;",
            "\t\tif (target < 0) return -1;",
            "\t\twhile (depth[head[x]] > target) x = par[head[x]];",
            "\t\treturn order[tin[x] - depth[x] + target];",
            "\t}",
            "\tbool apply_on_path(int u, int v, bool with_lca, function<void(int, int, bool)> f) {",
            "\t\t// f(u, v, up): up -- whether this part of the path goes up",
            "\t\tassert(!head.empty());",
            "\t\tif (root[u] != root[v]) return false;",
            "\t\tint cnt = 0;",
            "\t\twhile (head[u] != head[v]) {",
            "\t\t\tif (depth[head[u]] > depth[head[v]]) {",
            "\t\t\t\tf(tin[head[u]], tin[u], true);",
            "\t\t\t\tu = par[head[u]];",
            "\t\t\t} else {",
            "\t\t\t\tvisited[cnt++] = v;",
            "\t\t\t\tv = par[head[v]];",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (tin[u] > tin[v]) f(tin[v], tin[u] - !with_lca, true);",
            "\t\telse if (tin[u] + !with_lca <= tin[v]) f(tin[u] + !with_lca, tin[v], false);",
            "\t\tfor (int i = cnt - 1; i >= 0; i--) {",
            "\t\t\tv = visited[i];",
            "\t\t\tf(tin[head[v]], tin[v], false);",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "};",
            "template <typename T> class digraph: public graph<T> {",
            "public:",
            "\tusing graph<T>::edges, graph<T>::adj, graph<T>::n;",
            "\tdigraph(int _n) : graph<T>(_n) {}",
            "\tint add(int from, int to, T cost = 1) {",
            "\t\tassert(0 <= from && from < n && 0 <= to && to < n);",
            "\t\tint i = (int) edges.size();",
            "\t\tadj[from].push_back(i);",
            "\t\tedges.push_back({from, to, cost});",
            "\t\treturn i;",
            "\t}",
            "\tdigraph<T> reverse() const {",
            "\t\tdigraph <T> rev(n);",
            "\t\tfor (auto &e : edges) rev.add(e.to, e.from, e.cost);",
            "\t\treturn rev;",
            "\t}",
            "};",
            "template <typename T> vector <bool> find_bridges(const dfs_undigraph <T> &g) {",
            "\tassert(!g.par.empty());",
            "\tvector <bool> bridge(g.edges.size());",
            "\tfor (int i = 0; i < g.n; ++i) if (g.par[i] != -1 && g.min_depth[i] == g.depth[i]) bridge[g.par_e[i]] = true;",
            "\treturn bridge;",
            "}",
            "template <typename T> vector <bool> find_cutpoints(const dfs_undigraph <T> &g) {",
            "\tassert(!g.par.empty());",
            "\tvector <bool> cutpoint(g.n);",
            "\tfor (int i = 0; i < g.n; ++i) if (g.par[i] != -1 && g.min_depth[i] >= g.depth[g.par[i]]) cutpoint[g.par[i]] = true;",
            "\tvector <int> children(g.n, 0);",
            "\tfor (int i = 0; i < g.n; ++i) if (g.par[i] != -1) children[g.par[i]]++;",
            "\tfor (int i = 0; i < g.n; ++i) if (g.par[i] == -1 && children[i] < 2) cutpoint[i] = false;",
            "\treturn cutpoint;",
            "}",
            "template <typename T> vector <int> find_bicone(const dfs_undigraph <T> &g, int &cnt) {",
            "\tassert(!g.par.empty());",
            "\tvector <int> groups(g.n);",
            "\tcnt = 0;",
            "\tfor (int u: g.order) {",
            "\t\tif (g.par[u] == -1 || g.min_depth[u] == g.depth[u]) groups[u] = cnt++;",
            "\t\telse groups[u] = groups[g.par[u]];",
            "\t}",
            "\treturn groups;",
            "}",
            "template <typename T> vector <int> find_biconv(const dfs_undigraph <T> &g, int &cnt) {",
            "\tassert(!g.par.empty());",
            "\tvector <int> vertex_comp(g.n);",
            "\tcnt = 0;",
            "\tfor (int u: g.order) {",
            "\t\tif (g.par[u] == -1) vertex_comp[u] = -1;",
            "\t\telse if (g.min_depth[u] >= g.depth[g.par[u]]) vertex_comp[u] = cnt++;",
            "\t\telse vertex_comp[u] = vertex_comp[g.par[u]];",
            "\t}",
            "\tvector <int> edge_comp(g.edges.size(), -1);",
            "\tfor (int i = 0; i < (int) g.edges.size(); ++i) {",
            "\t\tint x = g.edges[i].from;",
            "\t\tint y = g.edges[i].to;",
            "\t\tedge_comp[i] = vertex_comp[g.depth[x] > g.depth[y] ? x : y];",
            "\t}",
            "\treturn edge_comp;",
            "}",
            "template <typename T> vector <int> find_mst(const undigraph <T> &g, T &res) {",
            "\tvector <int> order(g.edges.size());",
            "\tiota(order.begin(), order.end(), 0);",
            "\tsort(order.begin(), order.end(), [&g] (int a, int b) {",
            "\t\treturn g.edges[a].cost < g.edges[b].cost;",
            "\t});",
            "\tvector <int> par(g.n, -1);",
            "\tauto find = [&] (auto find, int u) -> int {",
            "\t\treturn par[u] < 0 ? u : par[u] = find(find, par[u]);",
            "\t};",
            "\tauto join = [&] (int u, int v) -> bool {",
            "\t\tif ((u = find(find, u)) == (v = find(find, v))) return false;",
            "\t\tif (par[u] > par[v]) swap(u, v);",
            "\t\tpar[u] += par[v];",
            "\t\tpar[v] = u;",
            "\t\treturn true;",
            "\t};",
            "\tvector <int> lst;",
            "\tres = 0;",
            "\tfor (int i: order) {",
            "\t\tauto &e = g.edges[i];",
            "\t\tif (join(e.from, e.to)) {",
            "\t\t\tlst.push_back(i);",
            "\t\t\tres += e.cost;",
            "\t\t}",
            "\t}",
            "\treturn lst;",
            "}",
            "template <typename T> vector <T> dijkstra(const graph <T> &g, int start) {",
            "\tassert(0 <= start && start < g.n);",
            "\tvector <T> dist(g.n, numeric_limits<T>::max());",
            "\tpriority_queue <pair <T, int>, vector <pair <T, int>>, greater <pair <T, int>>> pq;",
            "\tpq.emplace(dist[start] = 0, start);",
            "\twhile (!pq.empty()) {",
            "\t\tauto [du, u] = pq.top(); pq.pop();",
            "\t\tif (dist[u] != du) continue;",
            "\t\tfor (int i: g.adj[u]) {",
            "\t\t\tauto &e = g.edges[i];",
            "\t\t\tint v = e.from ^ e.to ^ u;",
            "\t\t\tif (dist[v] > du + e.cost) pq.emplace(dist[v] = du + e.cost, v);",
            "\t\t}",
            "\t}",
            "\treturn dist;",
            "}",
            "template <typename T> vector <T> dijkstra(const graph <T> &g, int start, vector <int> &trace) {",
            "\tassert(0 <= start && start < g.n);",
            "\ttrace.assign(g.n, -1);",
            "\tvector <T> dist(g.n, numeric_limits<T>::max());",
            "\tpriority_queue <pair <T, int>, vector <pair <T, int>>, greater <pair <T, int>>> pq;",
            "\tpq.emplace(dist[start] = 0, start);",
            "\twhile (!pq.empty()) {",
            "\t\tauto [du, u] = pq.top(); pq.pop();",
            "\t\tif (dist[u] != du) continue;",
            "\t\tfor (int i: g.adj[u]) {",
            "\t\t\tauto &e = g.edges[i];",
            "\t\t\tint v = e.from ^ e.to ^ u;",
            "\t\t\tif (dist[v] > du + e.cost) {",
            "\t\t\t\ttrace[v] = i;",
            "\t\t\t\tpq.emplace(dist[v] = du + e.cost, v);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn dist;",
            "}",
            "template <typename T> vector <int> find_eulerian_path(const graph <T> &g, int &root) {",
            "\tif (g.edges.empty()) {",
            "\t\troot = 0;",
            "\t\treturn vector<int>();",
            "\t}",
            "\tvector <int> in_deg(g.n, 0), out_deg(g.n, 0);",
            "\tfor (int i = 0; i < (int) g.edges.size(); ++i) {",
            "\t\tauto &e = g.edges[i];",
            "\t\t++out_deg[e.from]; ++in_deg[e.to];",
            "\t}",
            "\troot = -1;",
            "\tint odd = 0;",
            "\tfor (int i = 0; i < g.n; ++i) if ((in_deg[i] + out_deg[i]) & 1) {",
            "\t\todd++;",
            "\t\tif (root == -1 || out_deg[i] - in_deg[i] > out_deg[root] - in_deg[root]) root = i;",
            "\t}",
            "\tif (odd > 2) {",
            "\t\troot = -1;",
            "\t\treturn vector<int>();",
            "\t}",
            "\tif (root == -1) {",
            "\t\troot = 0;",
            "\t\twhile (root < g.n && in_deg[root] + out_deg[root] == 0) root++;",
            "\t}",
            "\tvector <bool> used(g.edges.size(), false);",
            "\tvector <int> ptr(g.n, 0), balance(g.n, 0), res(g.edges.size());",
            "\tint stack_ptr = 0, write_ptr = g.edges.size(), u = root;",
            "\twhile (true) {",
            "\t\tbool found = false;",
            "\t\twhile (ptr[u] < (int) g.adj[u].size()) {",
            "\t\t\tint i = g.adj[u][ptr[u]++];",
            "\t\t\tif (used[i]) continue;",
            "\t\t\tused[i] = true;",
            "\t\t\tres[stack_ptr++] = i;",
            "\t\t\tauto &e = g.edges[i];",
            "\t\t\tbalance[u]++;",
            "\t\t\tu ^= e.from ^ e.to;",
            "\t\t\tbalance[u]--;",
            "\t\t\tfound = true;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif (!found) {",
            "\t\t\tif (!stack_ptr) break;",
            "\t\t\tint i = res[--stack_ptr];",
            "\t\t\tres[--write_ptr] = i;",
            "\t\t\tauto &e = g.edges[i];",
            "\t\t\tu ^= e.from ^ e.to;",
            "\t\t}",
            "\t}",
            "\tint disbalance = 0;",
            "\tfor (int i = 0; i < g.n; ++i) disbalance += abs(balance[i]);",
            "\tif (write_ptr != 0 || disbalance > 2) {",
            "\t\troot = -1;",
            "\t\treturn vector<int>();",
            "\t}",
            "\treturn res;",
            "}",
            "template <typename T> vector <int> find_topsort(const digraph <T> &g) {",
            "\tvector <int> deg(g.n, 0), res;",
            "\tfor (int i = 0; i < (int) g.edges.size(); ++i) ++deg[g.edges[i].to];",
            "\tfor (int i = 0; i < g.n; ++i) if (!deg[i]) res.push_back(i);",
            "\tfor (int i = 0; i < (int) res.size(); i++) {",
            "\t\tint u = res[i];",
            "\t\tfor (int i: g.adj[u]) {",
            "\t\t\tint v = g.edges[i].to;",
            "\t\t\tif (!--deg[v]) res.push_back(v);",
            "\t\t}",
            "\t}",
            "\tif ((int) res.size() != g.n) return vector<int>();",
            "\treturn res;",
            "}",
            "template <typename T> vector <int> tarjan(const digraph <T> &g, int &cnt) {",
            "\tvector <int> low(g.n, -1), num(g.n, -1), groups(g.n, -1);",
            "\tstack <int> st;",
            "\tint t = 0;",
            "\tcnt = 0;",
            "\tauto dfs = [&] (auto dfs, int u) -> void {",
            "\t\tlow[u] = num[u] = t++;",
            "\t\tst.push(u);",
            "\t\tfor (int i: g.adj[u]) {",
            "\t\t\tint v = g.edges[i].to;",
            "\t\t\tif (num[v] == -1) {",
            "\t\t\t\tdfs(dfs, v);",
            "\t\t\t\tlow[u] = min(low[u], low[v]);",
            "\t\t\t} else low[u] = min(low[u], num[v]);",
            "\t\t}",
            "\t\tif (low[u] == num[u]) {",
            "\t\t\tint v;",
            "\t\t\tdo {",
            "\t\t\t\tv = st.top(); st.pop();",
            "\t\t\t\tlow[v] = num[v] = g.n;",
            "\t\t\t\tgroups[v] = cnt;",
            "\t\t\t} while (v != u);",
            "\t\t\t++cnt;",
            "\t\t}",
            "\t};",
            "\tfor (int i = 0; i < g.n; ++i) if (num[i] == -1) dfs(dfs, i);",
            "\treturn groups;",
            "}",
            "template <typename T> vector <int> kosaraju(const digraph <T> &g, int &cnt) {",
            "\tdigraph <T> g_rev = g.reverse();",
            "\tvector <int> order;",
            "\tvector <bool> visited(g.n);",
            "\tauto dfs1 = [&] (auto dfs1, int u) -> void {",
            "\t\tvisited[u] = true;",
            "\t\tfor (int i: g.adj[u]) {",
            "\t\t\tauto &e = g.edges[i];",
            "\t\t\tint v = e.to;",
            "\t\t\tif (!visited[v]) dfs1(dfs1, v);",
            "\t\t}",
            "\t\torder.push_back(u);",
            "\t};",
            "\tfor (int i = 0; i < g.n; ++i) if (!visited[i]) dfs1(dfs1, i);",
            "\tvector <int> c(g.n, -1);",
            "\tauto dfs2 = [&] (auto dfs2, int u) -> void {",
            "\t\tfor (int i: g_rev.adj[u]) {",
            "\t\t\tauto &e = g_rev.edges[i];",
            "\t\t\tint v = e.to;",
            "\t\t\tif (c[v] == -1) {",
            "\t\t\t\tc[v] = c[u];",
            "\t\t\t\tdfs2(dfs2, v);",
            "\t\t\t}",
            "\t\t}",
            "\t};",
            "\tcnt = 0;",
            "\tfor (int id = g.n; id-- > 0; ) {",
            "\t\tint i = order[id];",
            "\t\tif (c[i] != -1) continue;",
            "\t\tc[i] = cnt++;",
            "\t\tdfs2(dfs2, i);",
            "\t}",
            "\treturn c;",
            "}",
            "template <typename T> vector<int> find_dominators(const digraph <T> &g, int root) {",
            "\tint n = g.n;",
            "\tvector <int> pos(n, -1), order, parent(n, -1);",
            "\tfunction <void(int)> dfs = [&g, &pos, &order, &parent, &dfs] (int u) {",
            "\t\tpos[u] = (int) order.size();",
            "\t\torder.push_back(u);",
            "\t\tfor (int i: g.adj[u]) {",
            "\t\t\tint v = g.edges[i].to;",
            "\t\t\tif (pos[v] == -1) {",
            "\t\t\t\tparent[v] = u;",
            "\t\t\t\tdfs(v);",
            "\t\t\t}",
            "\t\t}",
            "\t};",
            "\tdfs(root);",
            "\tvector <int> p(n), best(n), sdom = pos;",
            "\tiota(p.begin(), p.end(), 0);",
            "\tiota(best.begin(), best.end(), 0);",
            "\tfunction <int(int)> find_best = [&p, &best, &sdom, &find_best] (int x) {",
            "\t\tif (p[x] != x) {",
            "\t\t\tint u = find_best(p[x]);",
            "\t\t\tif (sdom[u] < sdom[best[x]]) best[x] = u;",
            "\t\t\tp[x] = p[p[x]];",
            "\t\t}",
            "\t\tif (sdom[best[p[x]]] < sdom[best[x]]) best[x] = best[p[x]];",
            "\t\treturn best[x];",
            "\t};",
            "\tdigraph <T> g_rev = g.reverse();",
            "\tvector <int> idom(n, -1), link(n, 0);",
            "\tvector <vector <int>> bucket(n);",
            "\tfor (int i = (int) order.size() - 1; i >= 0; i--) {",
            "\t\tint u = order[i];",
            "\t\tfor (int i: g_rev.adj[u]) {",
            "\t\t\tint v = g_rev.edges[i].to;",
            "\t\t\tif (pos[v] != -1) sdom[u] = min(sdom[u], sdom[find_best(v)]);",
            "\t\t}",
            "\t\tidom[u] = order[sdom[u]];",
            "\t\tfor (int v: bucket[u]) link[v] = find_best(v);",
            "\t\tfor (int i: g.adj[u]) {",
            "\t\t\tint v = g.edges[i].to;",
            "\t\t\tif (parent[v] == u) p[v] = u;",
            "\t\t}",
            "\t\tbucket[order[sdom[u]]].push_back(u);",
            "\t}",
            "\tfor (int i = 1; i < (int) order.size(); ++i) {",
            "\t\tint u = order[i];",
            "\t\tidom[u] = idom[link[u]];",
            "\t}",
            "\treturn idom;",
            "}",
            "} using namespace GRAPH;",
            ""
        ],
        "description": "GRAPH"
    },
    "GRADER": {
        "scope": "cpp",
        "prefix": "GRADER",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "#define\t\t\t\t  fi  first",
            "#define\t\t\t\t  se  second",
            "#define\t\t\t\tleft  ___left",
            "#define\t\t\t   right  ___right",
            "#define\t\tscan_op(...)  istream & operator >> (istream &in, __VA_ARGS__ &u)",
            "#define\t   print_op(...)  ostream & operator << (ostream &out, const __VA_ARGS__ &u)",
            "#ifdef LOCAL",
            "\t#include \"debug.h\"",
            "#else",
            "\t#define file(name) if (fopen(name\".inp\", \"r\")) { freopen(name\".inp\", \"r\", stdin); freopen(name\".out\", \"w\", stdout); }",
            "\t#define DB(...) 23",
            "\t#define db(...) 23",
            "\t#define debug(...) 23",
            "#endif",
            "",
            "namespace std {",
            "template <class U, class V> scan_op(pair <U, V>) { return in >> u.first >> u.second; }",
            "template <class T> scan_op(vector <T>) { for (size_t i = 0; i < u.size(); ++i) in >> u[i]; return in; }",
            "template <class U, class V> print_op(pair <U, V>) { return out << '(' << u.first << \", \" << u.second << ')'; }",
            "template <size_t i, class T> ostream &print_tuple_utils(ostream &out, const T &tup) { if constexpr(i == tuple_size<T>::value) return out << \")\"; else return print_tuple_utils<i + 1, T>(out << (i ? \", \" : \"(\") << get<i>(tup), tup); }",
            "template <class...U> print_op(tuple <U...>) { return print_tuple_utils<0, tuple <U...>>(out, u); }",
            "template <class Con, class = decltype(begin(declval<Con>()))>typename enable_if <!is_same<Con, string>::value, ostream &>::type operator << (ostream &out, const Con &con) { out << '{'; for (__typeof(con.begin()) it = con.begin(); it != con.end(); ++it) out << (it == con.begin() ? \"\" : \", \") << *it; return out << '}'; }",
            "template <class T> print_op(stack <T>) { vector <T> v; stack <T> st = u; while (!st.empty()) v.push_back(st.top()), st.pop(); reverse(v.begin(), v.end()); return out << v; }",
            "template <class T> print_op(queue <T>) { queue <T> q = u; out << '{'; while (!q.empty()) { out << q.front(); q.pop(); if (!q.empty()) out << \", \"; } out << '}'; return out; }",
            "template <class T, class X, class Y> print_op(priority_queue <T, X, Y>) { priority_queue <T, X, Y> pq = u; out << '{'; while (!pq.empty()) { out << pq.top(); pq.pop(); if (!pq.empty()) out << \", \"; } out << '}'; return out; }",
            "template <class Fun> class y_combinator_result { Fun fun_; public: template <class T> explicit y_combinator_result(T &&fun): fun_(forward<T>(fun)) {} template <class...Args> decltype(auto)operator()(Args &&...args) { return fun_(ref(*this), forward<Args>(args)...); } };",
            "template <class Fun> decltype(auto)y_combinator(Fun &&fun) { return y_combinator_result<decay_t<Fun>>(forward<Fun>(fun)); }",
            "template <typename T, int D> struct Vec: public vector <Vec<T, D - 1>> { static_assert(D >= 1, \"Vector dimension must be greater than zero!\"); template <typename ...Args> Vec(int n = 0, Args ...args): vector <Vec<T, D - 1>>(n, Vec<T, D - 1>(args...)) {} };",
            "template <typename T> struct Vec<T, 1>: public vector<T>{ Vec(int n = 0, const T &val = T()): vector<T>(n, val) {} };",
            "#if __cplusplus < 202002L",
            "template <class T> int ssize(const T &a) { return a.size(); }",
            "#endif",
            "}",
            "",
            "struct Benchmark {",
            "\tunsigned long long tim, newtim;",
            "\tunsigned long long get_cur_time() { return chrono::steady_clock::now().time_since_epoch().count(); }",
            "\tBenchmark() { tim = newtim = get_cur_time(); }",
            "\tpair <string, long double> section(string name) {",
            "\t\tnewtim = get_cur_time(); long double res = (long double) (newtim - tim) / 1e9;",
            "\t\tstringstream ss; ss << fixed << setprecision(9) << name << \": \" << res << \"s.\";",
            "\t\ttim = newtim; string ans; getline(ss, ans); return pair {ans, res};",
            "\t}",
            "};",
            "",
            "const string NAME = \"${TM_DIRECTORY/^.+[\\/\\\\]+(.*)$/$1/}\";",
            "const int NUM_TEST = 1000;",
            "const long double TIME_LIMIT = 10;",
            "",
            "void check_status(int status, const string &where) {",
            "\tif (!status) return;",
            "\tcout << where << \" -> program exited abnormally\\n\";",
            "\texit(0);",
            "}",
            "",
            "int main(void) {",
            "\tfor (int iTest = 1; iTest <= NUM_TEST; ++iTest) {",
            "\t\tcout << \"Running on test \" << iTest;",
            "\t\tcheck_status(system(\"./gen.exe\"), \"\\t./generator\");",
            "\t\tBenchmark bm;",
            "\t\tcheck_status(system((\"./\" + NAME + \".exe\").c_str()), \"\\t./\" + NAME);",
            "\t\tauto bms = bm.section(\"\\ttime\");",
            "\t\t// cout << bms.fi;$0",
            "\t\tcout << endl;",
            "\t\tif (bms.se > TIME_LIMIT) {",
            "\t\t\tcout << \"Time limit exceeded on test \" << iTest << '\\n';",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t\tcheck_status(system((\"./\" + NAME + \"_bf.exe\").c_str()), \"\\t./\" + NAME + \"_bf\");",
            "\t\tif (system((\"diff -w \" + NAME + \".out \" + NAME + \".ans\").c_str())) {",
            "\t\t\tcout << \"Wrong answer on test \" << iTest << '\\n';",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t\tif (iTest % 5 == 0) system(\"clear\");",
            "\t}",
            "\tcout << \"Accepted!\\n\";",
            "\treturn 0;",
            "}"
        ],
        "description": "GRADER"
    },
    "GEOMETRY": {
        "scope": "cpp",
        "prefix": "GEOMETRY",
        "body": [
            "struct Point {",
            "\tlong long x, y;",
            "\tPoint(long long x = 0, long long y = 0): x(x), y(y) {}",
            "\tfriend scan_op(Point) { return in >> u.x >> u.y; }",
            "\tfriend print_op(Point) { return out << make_pair(u.x, u.y); }",
            "\tbool operator == (const Point &other) const { return x == other.x && y == other.y; }",
            "\tbool operator < (const Point &other) const { return make_pair(x, y) < make_pair(other.x, other.y); }",
            "\tPoint & operator += (const Point &other) {x += other.x; y += other.y; return *this; }",
            "\tPoint & operator -= (const Point &other) { x -= other.x; y -= other.y; return *this; }",
            "\tPoint & operator *= (long long v) { x *= v; y *= v; return *this; }",
            "\tPoint & operator /= (long long v) { x /= v; y /= v; return *this; }",
            "\tPoint operator + (const Point &other) const { return Point(*this) += other; }",
            "\tPoint operator - (const Point &other) const { return Point(*this) -= other; }",
            "\tPoint operator * (long long v) const { return Point(*this) *= v; }",
            "\tPoint operator / (long long v) const { return Point(*this) /= v; }",
            "\tlong long dot(const Point &other) const { return x * other.x + y * other.y; }",
            "\tlong long cross(const Point &other) const { return x * other.y - y * other.x; }",
            "\tlong long norm(void) const { return x * x + y * y; }",
            "\tdouble length(void) const { return sqrtl(norm()); }",
            "\tdouble angle(const Point &other) const { return acos(dot(other) / length() / other.length()); }",
            "\tlong long cross(const Point &a, const Point &b) const { return (a - *this).cross(b - *this); }",
            "};",
            "int sgn(long long val) { return val < 0 ? -1 : !!val; }",
            "int ccw(const Point &a, const Point &b, const Point &c) { return sgn(a.cross(b, c)); }",
            "double linePointDist(const Point &a, const Point &b, const Point &c, bool isSegment) {",
            "\tdouble dist = abs((b - a).cross(c - a)) / (a - b).length();",
            "\tif (isSegment) {",
            "\t\tif ((a - b).dot(c - b) < 0) return (b - c).length();",
            "\t\tif ((b - a).dot(c - a) < 0) return (a - c).length();",
            "\t}",
            "\treturn dist;",
            "}",
            "bool inter1(long long a, long long b, long long c, long long d) {",
            "\tif (a > b) swap(a, b);",
            "\tif (c > d) swap(c, d);",
            "\treturn max(a, c) <= min(b, d);",
            "}",
            "bool check_inter(const Point &a, const Point &b, const Point &p) {",
            "\treturn !a.cross(b, p) && inter1(a.x, b.x, p.x, p.x) && inter1(a.y, b.y, p.y, p.y);",
            "}",
            "bool check_inter(const Point &a, const Point &b, const Point &c, const Point &d) {",
            "\tif (!c.cross(a, d) && !c.cross(b, d)) ",
            "\t\treturn inter1(a.x, b.x, c.x, d.x) && inter1(a.y, b.y, c.y, d.y);",
            "\treturn ccw(a, b, c) != ccw(a, b, d) && ccw(c, d, a) != ccw(c, d, b);",
            "}",
            "struct Line {",
            "\t// ax + by = c",
            "\tlong long a, b, c;",
            "\tLine(long long a = 0, long long b = 0, long long c = 0): a(a), b(b), c(c) {}",
            "\tLine(const Point &m, const Point &n) {",
            "\t\ta = m.y - n.y;",
            "\t\tb = n.x - m.x;",
            "\t\tc = a * m.x + b * m.y;",
            "\t}",
            "\tbool intersect(const Line &other, Point &res) const {",
            "\t\tlong long x = a * other.b - b * other.a;",
            "\t\tif (!x) return false;",
            "\t\tres.x = (other.b * c - b * other.c) / x;",
            "\t\tres.y = (a * other.c - c * other.a) / x;",
            "\t\treturn true;",
            "\t}",
            "\tbool parallel(const Line &other) const {",
            "\t\treturn a * other.b - b * other.a == 0;",
            "\t}",
            "\tbool equivalent(const Line &other) const {",
            "\t\treturn a * other.b - b * other.a == 0",
            "\t\t\t&& a * other.c - c * other.a == 0",
            "\t\t\t&& b * other.c - c * other.b == 0;",
            "\t}",
            "};",
            "void convex_hull(vector <Point> &p) {",
            "\tif (p.size() <= 1) return;",
            "\tsort(p.begin(), p.end());",
            "\tPoint p1 = p[0], p2 = p.back();",
            "\tvector <Point> up {p1}, down {p1};",
            "\tfor (int i = 1; i < (int) p.size(); ++i) {",
            "\t\tint c = ccw(p1, p[i], p2);",
            "\t\tif (i == (int) p.size() - 1 || c < 0) {",
            "\t\t\twhile (up.size() > 1 && ccw(up.end()[-2], up.back(), p[i]) >= 0) up.pop_back();",
            "\t\t\tup.push_back(p[i]);",
            "\t\t}",
            "\t\tif (i == (int) p.size() - 1 || c > 0) {",
            "\t\t\twhile (down.size() > 1 && ccw(down.end()[-2], down.back(), p[i]) <= 0) down.pop_back();",
            "\t\t\tdown.push_back(p[i]);",
            "\t\t}",
            "\t}",
            "\tp = move(up);",
            "\tp.insert(p.end(), down.rbegin() + 1, down.rend() - 1);",
            "\tif (p.size() == 2 && p[0] == p[1]) p.pop_back();",
            "}",
            "long long area_x2(const vector <Point> &p) {",
            "\tlong long res = 0;",
            "\tfor (int i = 0; i < (int) p.size(); ++i) res += p[i].cross(p[i == (int) p.size() - 1 ? 0 : i + 1]);",
            "\treturn abs(res);",
            "}",
            "int n;",
            "vector <Point> seq;",
            "Point translation;",
            "void prepareConvexPolygon(vector <Point> &p) {",
            "\tif (ccw(p[0], p[1], p[2]) < 0) reverse(p.begin(), p.end());",
            "\tn = p.size();",
            "\tint pos = 0;",
            "\tfor (int i = 1; i < n; ++i) if (p[i] < p[pos]) pos = i;",
            "\trotate(p.begin(), p.begin() + pos, p.end());",
            "\t--n;",
            "\tseq.resize(n);",
            "\ttranslation = p[0];",
            "\tfor (int i = 0; i < n; ++i) seq[i] = p[i + 1] - translation;",
            "}",
            "bool pointInTriangle(const Point &a, const Point &b, const Point &c, const Point &p) {",
            "\treturn abs(a.cross(b, c)) == abs(p.cross(a, b)) + abs(p.cross(b, c)) + abs(p.cross(c, a));",
            "}",
            "bool pointInConvexPolygon(Point p) {",
            "\tp -= translation;",
            "\tif (seq[0].cross(p) < 0) return false;",
            "\tif (seq[n - 1].cross(p) > 0) return false;",
            "\tif (!seq[0].cross(p)) return seq[0].norm() >= p.norm();",
            "\tint l = 0, r = n - 2;",
            "\twhile (l <= r) {",
            "\t\tint m = (l + r) >> 1;",
            "\t\tif (seq[m].cross(p) > 0) l = m + 1;",
            "\t\telse r = m - 1;",
            "\t}",
            "\treturn pointInTriangle(seq[r], seq[r + 1], Point(0, 0), p);",
            "}",
            ""
        ],
        "description": "GEOMETRY"
    },
    "GENERATOR": {
        "scope": "cpp",
        "prefix": "GENERATOR",
        "body": [
            "#include \"testlib.h\"",
            "#include \"gen_tree.h\"",
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "#define\t\t\t\t  fi  first",
            "#define\t\t\t\t  se  second",
            "#define\t\t\t\tleft  ___left",
            "#define\t\t\t   right  ___right",
            "#define\t\tscan_op(...)  istream & operator >> (istream &in, __VA_ARGS__ &u)",
            "#define\t   print_op(...)  ostream & operator << (ostream &out, const __VA_ARGS__ &u)",
            "#ifdef LOCAL",
            "\t#include \"debug.h\"",
            "#else",
            "\t#define file(name) if (fopen(name\".inp\", \"r\")) { freopen(name\".inp\", \"r\", stdin); freopen(name\".out\", \"w\", stdout); }",
            "\t#define DB(...) 23",
            "\t#define db(...) 23",
            "\t#define debug(...) 23",
            "#endif",
            "",
            "namespace std {",
            "template <class U, class V> scan_op(pair <U, V>) { return in >> u.first >> u.second; }",
            "template <class T> scan_op(vector <T>) { for (size_t i = 0; i < u.size(); ++i) in >> u[i]; return in; }",
            "template <class U, class V> print_op(pair <U, V>) { return out << '(' << u.first << \", \" << u.second << ')'; }",
            "template <size_t i, class T> ostream &print_tuple_utils(ostream &out, const T &tup) { if constexpr(i == tuple_size<T>::value) return out << \")\"; else return print_tuple_utils<i + 1, T>(out << (i ? \", \" : \"(\") << get<i>(tup), tup); }",
            "template <class...U> print_op(tuple <U...>) { return print_tuple_utils<0, tuple <U...>>(out, u); }",
            "template <class Con, class = decltype(begin(declval<Con>()))>typename enable_if <!is_same<Con, string>::value, ostream &>::type operator << (ostream &out, const Con &con) { out << '{'; for (__typeof(con.begin()) it = con.begin(); it != con.end(); ++it) out << (it == con.begin() ? \"\" : \", \") << *it; return out << '}'; }",
            "template <class T> print_op(stack <T>) { vector <T> v; stack <T> st = u; while (!st.empty()) v.push_back(st.top()), st.pop(); reverse(v.begin(), v.end()); return out << v; }",
            "template <class T> print_op(queue <T>) { queue <T> q = u; out << '{'; while (!q.empty()) { out << q.front(); q.pop(); if (!q.empty()) out << \", \"; } out << '}'; return out; }",
            "template <class T, class X, class Y> print_op(priority_queue <T, X, Y>) { priority_queue <T, X, Y> pq = u; out << '{'; while (!pq.empty()) { out << pq.top(); pq.pop(); if (!pq.empty()) out << \", \"; } out << '}'; return out; }",
            "template <class Fun> class y_combinator_result { Fun fun_; public: template <class T> explicit y_combinator_result(T &&fun): fun_(forward<T>(fun)) {} template <class...Args> decltype(auto)operator()(Args &&...args) { return fun_(ref(*this), forward<Args>(args)...); } };",
            "template <class Fun> decltype(auto)y_combinator(Fun &&fun) { return y_combinator_result<decay_t<Fun>>(forward<Fun>(fun)); }",
            "template <typename T, int D> struct Vec: public vector <Vec<T, D - 1>> { static_assert(D >= 1, \"Vector dimension must be greater than zero!\"); template <typename ...Args> Vec(int n = 0, Args ...args): vector <Vec<T, D - 1>>(n, Vec<T, D - 1>(args...)) {} };",
            "template <typename T> struct Vec<T, 1>: public vector<T>{ Vec(int n = 0, const T &val = T()): vector<T>(n, val) {} };",
            "#if __cplusplus < 202002L",
            "template <class T> int ssize(const T &a) { return a.size(); }",
            "#endif",
            "}",
            "",
            "const int argc = 2;",
            "int seed = chrono::steady_clock::now().time_since_epoch().count();",
            "string s = to_string(seed);",
            "char* argv[argc] = {&s[0], &s[0]};",
            "",
            "int main(void) {",
            "\tios_base::sync_with_stdio(false); cin.tie(nullptr); // cout.tie(nullptr);",
            "\tregisterGen(argc, argv, 1);",
            "\tfreopen(\"${TM_DIRECTORY/^.+[\\/\\\\]+(.*)$/$1/}.inp\", \"w\", stdout);",
            "\t$0",
            "\t// cerr << \"Time elapsed: \" << TIME << \" s.\\n\";",
            "\treturn 0;",
            "}"
        ],
        "description": "GENERATOR"
    },
    "GAUSS_ELIMINATION": {
        "scope": "cpp",
        "prefix": "GAUSS_ELIMINATION",
        "body": [
            "int GaussianElimination(vector <vector <double>> a, vector <double> &res) {",
            "\tint n = a.size();",
            "\tint m = (int) a[0].size() - 1;",
            "\tvector <int> where(m, -1);",
            "\tfor (int i = 0, j = 0; i < n && j < m; ++j) {",
            "\t\tint pos = i;",
            "\t\tfor (int k = i + 1; k < n; ++k) if (abs(a[k][j]) > abs(a[pos][j])) pos = k;",
            "\t\tif (abs(a[pos][j]) < EPS) continue;",
            "\t\tfor (int k = j; k <= m; ++k) swap(a[i][k], a[pos][k]);",
            "\t\twhere[j] = i;",
            "\t\tfor (int k = 0; k < n; ++k) if (k != i) {",
            "\t\t\tdouble c = a[k][j] / a[i][j];",
            "\t\t\tfor (int l = j; l <= m; ++l) a[k][l] -= a[i][l] * c;",
            "\t\t}",
            "\t\t++i;",
            "\t}",
            "\tres.assign(m, 0);",
            "\tfor (int i = 0; i < m; ++i) if (where[i] != -1) res[i] = a[where[i]][m] / a[where[i]][i];",
            "\tfor (int i = 0; i < n; ++i) {",
            "\t\tdouble sum = 0;",
            "\t\tfor (int j = 0; j < m; ++j) sum += res[j] * a[i][j];",
            "\t\tif (abs(sum - a[i][m]) > EPS) return 0;",
            "\t}",
            "\tfor (int i = 0; i < m; ++i) if (where[i] == -1) return 2; // INF",
            "\treturn 1;",
            "}",
            ""
        ],
        "description": "GAUSS_ELIMINATION"
    },
    "FENWICK_TREE": {
        "scope": "cpp",
        "prefix": "FENWICK_TREE",
        "body": [
            "template <class T> struct FenwickTree {",
            "\tint n; vector <T> bit;",
            "\tFenwickTree() = default;",
            "\tFenwickTree(int _n): n(_n), bit(n + 1, T{}) {}",
            "\tFenwickTree(const vector <T> &a): n(a.size()), bit(a.size() + 1, T{}) {",
            "\t\tfor (int i = 1; i <= n; ++i) {",
            "\t\t\tbit[i] += a[i - 1];",
            "\t\t\tif (i + (i & -i) <= n) bit[i + (i & -i)] += bit[i];",
            "\t\t}",
            "\t}",
            "\tvoid reset(void) { fill(bit.begin(), bit.end(), T{}); }",
            "\tvoid update(int i, T val) { for (i = max(1, i + 1); i <= n; i += i & -i) bit[i] += val; }",
            "\tT get(int i) {",
            "\t\tif (i < 0) return T{};",
            "\t\tT res = T{};",
            "\t\tfor (i = min(i + 1, n); i > 0; i &= i - 1) res += bit[i];",
            "\t\treturn res;",
            "\t}",
            "\tT get(int l, int r) { return get(r) - get(l - 1); }",
            "\tint upper_bound(T val) {",
            "\t\tint res = 0;",
            "\t\tfor (int i = __lg(n); i >= 0; --i)",
            "\t\t\tif ((res | (1 << i)) <= n && val >= bit[res | (1 << i)]) res |= (1 << i), val -= bit[res];",
            "\t\treturn res;",
            "\t}",
            "\tint lower_bound(T val) {",
            "\t\tint res = 0;",
            "\t\tfor (int i = __lg(n); i >= 0; --i)",
            "\t\t\tif ((res | (1 << i)) <= n && val > bit[res | (1 << i)]) res |= (1 << i), val -= bit[res];",
            "\t\treturn res;",
            "\t}",
            "};",
            ""
        ],
        "description": "FENWICK_TREE"
    },
    "FENWICK_TREE_RANGE": {
        "scope": "cpp",
        "prefix": "FENWICK_TREE_RANGE",
        "body": [
            "template<",
            "\tclass T,  // data type for nodes",
            "\tT (*op) (T, T),  // operator to combine 2 nodes",
            "\tT (*e)() // identity element",
            "\t>",
            "struct FenwickTree_R {",
            "\tint n; vector <T> bit1, bit2, a;",
            "\tFenwickTree_R() = default;",
            "\tFenwickTree_R(int _n): n(_n), bit1(n + 1, e()), bit2(n + 1, e()), a(n + 1, e()) {}",
            "\tvoid reset(void) {",
            "\t\tfill(bit1.begin(), bit1.end(), e());",
            "\t\tfill(bit2.begin(), bit2.end(), e());",
            "\t\tfill(a.begin(), a.end(), e());",
            "\t}",
            "#define lowbit(x) ((x) & -(x))",
            "\tFenwickTree_R(const vector <T> &v): n(v.size()), bit1(n + 1, e()), bit2(n + 1, e()), a(n + 1, e()) {",
            "\t\tfor (int i = 1; i <= n; ++i) {",
            "\t\t\ta[i] = v[i - 1];",
            "\t\t\tbit1[i] = op(bit1[i], a[i]);",
            "\t\t\tif (i + lowbit(i) <= n) bit1[i + lowbit(i)] = op(bit1[i + lowbit(i)], bit1[i]);",
            "\t\t}",
            "\t\tfor (int i = n; i > 0; --i) {",
            "\t\t\tbit2[i] = op(a[i], bit2[i]);",
            "\t\t\tif (i - lowbit(i) > 0) bit2[i - lowbit(i)] = op(bit2[i], bit2[i - lowbit(i)]);",
            "\t\t}",
            "\t}",
            "\tvoid set(int p, T val) {",
            "\t\tassert(0 <= p && p < n);",
            "\t\t++p;",
            "\t\ta[p] = val;",
            "\t\tT cur = val;",
            "\t\tfor (int i = p, l = p - 1, r = p + 1; i <= n; i += lowbit(i)) {",
            "\t\t\tfor (; r < i; r += lowbit(r)) cur = op(cur, bit2[r]);",
            "\t\t\tfor (; l > i - lowbit(i); l -= lowbit(l)) cur = op(bit1[l], cur);",
            "\t\t\tbit1[i] = i == p ? cur : op(cur, a[r]);",
            "\t\t}",
            "\t\tcur = val;",
            "\t\tfor (int i = p, l = p - 1, r = p + 1; i > 0; i -= lowbit(i)) {",
            "\t\t\tfor (; r < min(n + 1, i + lowbit(i)); r += lowbit(r)) cur = op(cur, bit2[r]);",
            "\t\t\tfor (; l > i; l -= lowbit(l)) cur = op(bit1[l], cur);",
            "\t\t\tbit2[i] = i == p ? cur : op(a[l], cur);",
            "\t\t}",
            "\t}",
            "\tvoid get(int p) const { return a[p]; }",
            "\t// Get product in range [l, r-1]",
            "\t// For empty segment (l == r) -> return e()",
            "\tT prod(int l, int r) const {",
            "\t\tassert(0 <= l && l <= r && r <= n);",
            "\t\tif (l == r) return e();",
            "\t\t++l;",
            "\t\tT lft = e(), rgt = e();",
            "\t\tint i;",
            "\t\tfor (i = l; i + lowbit(i) <= r; i += lowbit(i)) lft = op(lft, bit2[i]);",
            "\t\tlft = op(lft, a[i]);",
            "\t\tfor (i = r; i - lowbit(i) >= l; i -= lowbit(i)) rgt = op(bit1[i], rgt);",
            "\t\treturn op(lft, rgt);",
            "\t}",
            "\tT all_prod() const {",
            "\t\tT res = e();",
            "\t\tfor (int i = n; i > 0; i -= lowbit(i)) res = op(bit1[i], res);",
            "\t\treturn res;",
            "\t}",
            "};",
            "// FenwickTree_R examples {{{",
            "// Examples: Commonly used FenwickTree_R ops: max / min",
            "struct MaxFenwickOp {",
            "\tstatic int op(int x, int y) { return max(x, y); }",
            "\tstatic int e() { return -1e9; }",
            "};",
            "struct MinFenwickOP {",
            "\tstatic int op(int x, int y) { return min(x, y); }",
            "\tstatic int e() { return 1e9; }",
            "};",
            "using MaxFenwick = FenwickTree_R <int, MaxFenwickOp::op, MaxFenwickOp::e>;",
            "using MinFenwick = FenwickTree_R <int, MinFenwickOP::op, MinFenwickOP::e>;",
            "// }}}",
            ""
        ],
        "description": "FENWICK_TREE_RANGE"
    },
    "FASTIO_KACTL": {
        "scope": "cpp",
        "prefix": "FASTIO_KACTL",
        "body": [
            "inline char gc() { // like getchar()",
            "\tstatic char buf[1 << 16];",
            "\tstatic size_t bc, be;",
            "\tif (bc >= be) {",
            "\t\tbuf[0] = 0, bc = 0;",
            "\t\tbe = fread(buf, 1, sizeof(buf), stdin);",
            "\t}",
            "\treturn buf[bc++]; // returns 0 on EOF",
            "}",
            "",
            "int readInt() {",
            "\tint a, c;",
            "\twhile ((a = gc()) < 40);",
            "\tif (a == '-') return -readInt();",
            "\twhile ((c = gc()) >= 48) a = a * 10 + c - 480;",
            "\treturn a - 48;",
            "}",
            ""
        ],
        "description": "FASTIO_KACTL"
    },
    "EDMONDS_KARP": {
        "scope": "cpp",
        "prefix": "EDMONDS_KARP",
        "body": [
            "struct MaxFlow {",
            "",
            "\tstatic const long long INF = 1e18;",
            "",
            "\tstruct Edge {",
            "\t\tint from, to;",
            "\t\tlong long capa, flow;",
            "\t\tEdge(int from = 0, int to = 0, long long capa = 0):",
            "\t\t\tfrom(from), to(to), capa(capa), flow(0) {}",
            "\t\tlong long residual(void) const { return capa - flow; }",
            "\t\tbool saturating(void) { return !residual(); }",
            "\t};",
            "",
            "\tvector <Edge> edges;",
            "\tvector <vector <int>> adj;",
            "\tvector <int> dist, par;",
            "",
            "\tMaxFlow(int n) {",
            "\t\tadj.assign(n + 1, vector<int> ());",
            "\t\tdist.resize(n + 1);",
            "\t\tpar.resize(n + 1);",
            "\t}",
            "",
            "\tvoid addEdge(int u, int v, long long c) {",
            "\t\tadj[u].push_back(edges.size());",
            "\t\tedges.push_back(Edge(u, v, c));",
            "\t\tadj[v].push_back(edges.size());",
            "\t\tedges.push_back(Edge(v, u, 0));",
            "\t}",
            "",
            "\tbool findPath(int s, int t) {",
            "\t\tfill(dist.begin(), dist.end(), -1);",
            "\t\tfill(par.begin(), par.end(), -1);",
            "\t\tqueue <int> q;",
            "\t\tdist[s] = 0; q.push(s);",
            "\t\twhile (!q.empty()) {",
            "\t\t\tint u = q.front(); q.pop();",
            "\t\t\tfor (int &id: adj[u]) if (edges[id].residual() > 0) {",
            "\t\t\t\tint v = edges[id].to;",
            "\t\t\t\tif (dist[v] == -1) {",
            "\t\t\t\t\tdist[v] = dist[u] + 1;",
            "\t\t\t\t\tpar[v] = id;",
            "\t\t\t\t\tq.push(v);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn dist[t] != -1;",
            "\t}",
            "",
            "\tlong long getFlow(int s, int t) {",
            "\t\tfor (Edge &e: edges) e.flow = 0;",
            "\t\tlong long totFlow = 0;",
            "\t\twhile (findPath(s, t)) {",
            "\t\t\tlong long delta = INF;",
            "\t\t\tfor (int u = t; u != s; u = edges[par[u]].from)",
            "\t\t\t\tdelta = min(delta, edges[par[u]].residual());",
            "\t\t\ttotFlow += delta;",
            "\t\t\tfor (int u = t; u != s; u = edges[par[u]].from) {",
            "\t\t\t\tedges[par[u]].flow += delta;",
            "\t\t\t\tedges[par[u] ^ 1].flow -= delta;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn totFlow;",
            "\t}",
            "",
            "\tbool saturating(int s, int t) {",
            "\t\tmaxFlow(s, t);",
            "\t\tfor (int &id: adj[s]) if (edges[id].from == s && !edges[id].saturating()) return false;",
            "\t\treturn true;",
            "\t}",
            "",
            "};",
            ""
        ],
        "description": "EDMONDS_KARP"
    },
    "DISJOINT_SPARSE_TABLE": {
        "scope": "cpp",
        "prefix": "DISJOINT_SPARSE_TABLE",
        "body": [
            "template <class T, T (*op) (T, T)> struct DisjointSparseTable {",
            "\tint n;",
            "\tvector <vector <T>> st;",
            "\tDisjointSparseTable() {}",
            "\tDisjointSparseTable(const vector <T> &a): n(a.size()) {",
            "\t\tst.push_back(a);",
            "\t\tfor (int p = 1; 1 << p < n; p++) {",
            "\t\t\tst.emplace_back(n);",
            "\t\t\tfor (int mid = 1 << p; mid < n; mid += 1 << (p + 1)) {",
            "\t\t\t\tst[p][mid - 1] = a[mid - 1];",
            "\t\t\t\tfor (int j = mid - 2; j >= mid - (1 << p); --j) st[p][j] = op(a[j], st[p][j + 1]);",
            "\t\t\t\tst[p][mid] = a[mid];",
            "\t\t\t\tfor (int j = mid + 1; j < min(n, mid + (1 << p)); ++j) st[p][j] = op(st[p][j - 1], a[j]);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tT get(int l, int r) const {",
            "\t\tassert(0 <= l && l < r && r <= n);",
            "\t\tif (r - l == 1) return st[0][l];",
            "\t\tint p = __lg(l ^ (r - 1));",
            "\t\treturn op(st[p][l], st[p][r - 1]);",
            "\t}",
            "};",
            ""
        ],
        "description": "DISJOINT_SPARSE_TABLE"
    },
    "DISJOINT_SET_UNION": {
        "scope": "cpp",
        "prefix": "DISJOINT_SET_UNION",
        "body": [
            "struct DisjointSet {",
            "\tvector <int> par;",
            "\tDisjointSet(int n = 0): par(n, -1) {}",
            "\tvoid reset(void) { fill(par.begin(), par.end(), -1); }",
            "\tvoid resize(int n) { par.assign(n, -1); }",
            "\tbool connected(int u, int v) { return find(u) == find(v); }",
            "\tbool isRoot(int u) { return par[u] < 0; }",
            "\tint size(int u) { return -par[find(u)]; }",
            "\tint find(int u) { return par[u] < 0 ? u : par[u] = find(par[u]); }",
            "\tbool join(int u, int v) {",
            "\t\tif ((u = find(u)) == (v = find(v))) return false;",
            "\t\tif (par[u] > par[v]) swap(u, v);",
            "\t\tpar[u] += par[v]; par[v] = u;",
            "\t\treturn true;",
            "\t}",
            "};",
            "using DSU = DisjointSet;",
            ""
        ],
        "description": "DISJOINT_SET_UNION"
    },
    "CONVEX_HULL_TRICK": {
        "scope": "cpp",
        "prefix": "CONVEX_HULL_TRICK",
        "body": [
            "struct Line {",
            "\tlong long a, b;",
            "\tLine(long long a = 0, long long b = INF): a(a), b(b) {}",
            "\tlong long eval(long long x) { return a * x + b; }",
            "};",
            "struct ConvexHullTrick {",
            "\tvector <Line> lines; int ptr;",
            "\tConvexHullTrick(): ptr(0) {}",
            "\tbool bad(Line a, Line b, Line c) { return (long double) (c.b - a.b) / (a.a - c.a) < (long double) (b.b - a.b) / (a.a - b.a); }",
            "\tvoid addLine(long long a, long long b) {",
            "\t\tLine l(a, b);",
            "\t\twhile (lines.size() >= 2 && bad(lines.end()[-2], lines.back(), l)) lines.pop_back();",
            "\t\tlines.push_back(l);",
            "\t}",
            "\tLine getMin(long long x) {",
            "\t\tif (ptr >= (int) lines.size()) ptr = (int) lines.size() - 1;",
            "\t\twhile (ptr < (int) lines.size() - 1 && lines[ptr].eval(x) > lines[ptr + 1].eval(x)) ++ptr;",
            "\t\treturn lines[ptr];",
            "\t}",
            "};",
            "using CHT = ConvexHullTrick;",
            ""
        ],
        "description": "CONVEX_HULL_TRICK"
    },
    "COMPRESS": {
        "scope": "cpp",
        "prefix": "COMPRESS",
        "body": [
            "template <class InIter, class OutIter>  void compress(InIter first, InIter last, OutIter result) { vector <__typeof(*first)> v(first, last); sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); while (first != last) { *result = lower_bound(v.begin(), v.end(), *first) - v.begin(); ++first; ++result; } }",
            ""
        ],
        "description": "COMPRESS"
    },
    "BUMP_ALLOCATOR": {
        "scope": "cpp",
        "prefix": "BUMP_ALLOCATOR",
        "body": [
            "static char buf[450 << 20];",
            "void* operator new(size_t s) {",
            "\tstatic size_t i = sizeof buf;",
            "\tassert(s < i);",
            "\treturn (void*) &buf[i -= s];",
            "}",
            "void operator delete(void*) {}",
            ""
        ],
        "description": "BUMP_ALLOCATOR"
    },
    "BRIDGE_ARTICULATION": {
        "scope": "cpp",
        "prefix": "BRIDGE_ARTICULATION",
        "body": [
            "struct BridgeArticulation {",
            "\tint n, m, tecc_num, bc_num;",
            "\tvector <int> cuts, low, num, tecc_ids;",
            "\tvector <vector <int>> bc_groups;",
            "\tvector <pair <int, int>> bridges;",
            "\tvector <bool> articulation, is_bridge;",
            "\tstruct edge {",
            "\t\tint to, id;",
            "\t\tedge(int to = -1, int id = -1): to(to), id(id) {}",
            "\t};",
            "\tvector <pair <int, edge>> edges;",
            "\tBridgeArticulation(int _n = 0) : n(_n), m(0) {}",
            "\tvoid add(int u, int v) {",
            "\t\tedges.emplace_back(u, edge(v, m));",
            "\t\tedges.emplace_back(v, edge(u, m++));",
            "\t}",
            "\tvoid init() {",
            "\t\tcsr <edge> g = csr<edge>(n, edges);",
            "\t\tint t = 0;",
            "\t\tarticulation.resize(n);",
            "\t\tis_bridge.resize(m);",
            "\t\tlow.resize(n);",
            "\t\tnum.assign(n, -1);",
            "\t\ttecc_num = bc_num = 0;",
            "\t\tvector <bool> used(m);",
            "\t\tvector <int> tecc_st, bc_st;",
            "\t\ttecc_ids.resize(n);",
            "\t\tbc_groups.clear();",
            "\t\tfor (int r = 0; r < n; r++) if (num[r] == -1) {",
            "\t\t\tint child = 0;",
            "\t\t\tauto dfs = [&] (auto dfs, int u) -> void {",
            "\t\t\t\ttecc_st.push_back(u);",
            "\t\t\t\tbc_st.push_back(u);",
            "\t\t\t\tnum[u] = t++;",
            "\t\t\t\tlow[u] = n;",
            "\t\t\t\tfor (int i = g.st[u]; i < g.st[u + 1]; i++) {",
            "\t\t\t\t\tint id = g.lst[i].id;",
            "\t\t\t\t\tif (used[id]) continue;",
            "\t\t\t\t\tused[id] = true;",
            "\t\t\t\t\tint v = g.lst[i].to;",
            "\t\t\t\t\tif (num[v] == -1) {",
            "\t\t\t\t\t\tif (u == r) ++child;",
            "\t\t\t\t\t\tdfs(dfs, v);",
            "\t\t\t\t\t\tif (low[v] >= num[u]) {",
            "\t\t\t\t\t\t\tarticulation[u] = true;",
            "\t\t\t\t\t\t\tint w;",
            "\t\t\t\t\t\t\tbc_groups.push_back({u});",
            "\t\t\t\t\t\t\tdo {",
            "\t\t\t\t\t\t\t\tw = bc_st.back(); bc_st.pop_back();",
            "\t\t\t\t\t\t\t\tbc_groups.back().push_back(w);",
            "\t\t\t\t\t\t\t} while (w != v);",
            "\t\t\t\t\t\t\t++bc_num;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tif (low[v] > num[u]) {",
            "\t\t\t\t\t\t\tis_bridge[id] = true;",
            "\t\t\t\t\t\t\tbridges.emplace_back(u, v);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tlow[u] = min(low[u], low[v]);",
            "\t\t\t\t\t} else low[u] = min(low[u], num[v]);",
            "\t\t\t\t}",
            "\t\t\t\tif (low[u] >= num[u]) {",
            "\t\t\t\t\tint v;",
            "\t\t\t\t\tdo {",
            "\t\t\t\t\t\tv = tecc_st.back(); tecc_st.pop_back();",
            "\t\t\t\t\t\ttecc_ids[v] = tecc_num;",
            "\t\t\t\t\t} while (v != u);",
            "\t\t\t\t\t++tecc_num;",
            "\t\t\t\t}",
            "\t\t\t};",
            "\t\t\tdfs(dfs, r);",
            "\t\t\tarticulation[r] = child > 1;",
            "\t\t\tif (!child) {",
            "\t\t\t\tbc_groups.push_back({r});",
            "\t\t\t\t++bc_num;",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor (int i = 0; i < n; ++i) if (articulation[i]) cuts.push_back(i);",
            "\t}",
            "\tvector <vector <int>> tecc() {",
            "\t\tvector <int> cnt(tecc_num);",
            "\t\tfor (int x: tecc_ids) cnt[x]++;",
            "\t\tvector <vector <int>> groups(tecc_num);",
            "\t\tfor (int i = 0; i < tecc_num; i++) groups[i].reserve(cnt[i]);",
            "\t\tfor (int i = 0; i < n; i++) groups[tecc_ids[i]].push_back(i);",
            "\t\treturn groups;",
            "\t}",
            "};",
            ""
        ],
        "description": "BRIDGE_ARTICULATION"
    },
    "BITSET_TRICK": {
        "scope": "cpp",
        "prefix": "BITSET_TRICK",
        "body": [
            "template <size_t bitset_size> void solve(int n) {",
            "",
            "}",
            "",
            "template <size_t bit = 0> void try_solve(int n) {",
            "\tif constexpr(bit < 30) {",
            "\t\tif (n <= (1u << bit)) solve<(1u << bit)>(n);",
            "\t\telse try_solve<bit + 1>(n);",
            "\t}",
            "}",
            ""
        ],
        "description": "BITSET_TRICK"
    },
    "BIGINT": {
        "scope": "cpp",
        "prefix": "BIGINT",
        "body": [
            "const int BASE_DIGITS = 9;",
            "const int BASE = 1000000000;",
            "struct BigInt {",
            "\tint sign;",
            "\tvector <int> a;",
            "\tBigInt() : sign(1) {}",
            "\tBigInt(long long v) { *this = v; }",
            "\tBigInt & operator = (long long v) {",
            "\t\tsign = 1; if (v < 0) sign = -1, v = -v; a.clear();",
            "\t\tfor (; v > 0; v = v / BASE) a.push_back(v % BASE);",
            "\t\treturn *this;",
            "\t}",
            "\tBigInt(const string& s) { read(s); }",
            "\tvoid read(const string &s) {",
            "\t\tsign = 1; a.clear(); int pos = 0;",
            "\t\twhile (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {",
            "\t\t\tif (s[pos] == '-') sign = -sign;",
            "\t\t\t++pos;",
            "\t\t}",
            "\t\tfor (int i = (int) s.size() - 1; i >= pos; i -= BASE_DIGITS) {",
            "\t\t\tint x = 0;",
            "\t\t\tfor (int j = max(pos, i - BASE_DIGITS + 1); j <= i; j++) x = x * 10 + s[j] - '0';",
            "\t\t\ta.push_back(x);",
            "\t\t}",
            "\t\ttrim();",
            "\t}",
            "\tfriend istream & operator >> (istream &stream, BigInt &v) { string s; stream >> s; v.read(s); return stream; }",
            "\tfriend ostream & operator << (ostream &stream, const BigInt &v) {",
            "\t\tif (v.sign == -1 && !v.isZero()) stream << '-';",
            "\t\tstream << (v.a.empty() ? 0 : v.a.back());",
            "\t\tfor (int i = (int) v.a.size() - 2; i >= 0; --i) stream << setw(BASE_DIGITS) << setfill('0') << v.a[i];",
            "\t\treturn stream;",
            "\t}",
            "\tbool operator < (const BigInt &v) const {",
            "\t\tif (sign != v.sign) return sign < v.sign;",
            "\t\tif (a.size() != v.a.size()) return a.size() * sign < v.a.size() * v.sign;",
            "\t\tfor (int i = ((int) a.size()) - 1; i >= 0; i--) if (a[i] != v.a[i]) return a[i] * sign < v.a[i] * sign;",
            "\t\treturn false;",
            "\t}",
            "\tbool operator>(const BigInt &v) const { return v < *this; }",
            "\tbool operator<=(const BigInt &v) const { return !(v < *this); }",
            "\tbool operator>=(const BigInt &v) const { return !(*this < v); }",
            "\tbool operator==(const BigInt &v) const { return !(*this < v) && !(v < *this); }",
            "\tbool operator!=(const BigInt &v) const { return *this < v || v < *this; }",
            "\tfriend int __compare_abs(const BigInt &x, const BigInt &y) {",
            "\t\tif (x.a.size() != y.a.size()) return x.a.size() < y.a.size() ? -1 : 1;",
            "\t\tfor (int i = ((int) x.a.size()) - 1; i >= 0; --i) if (x.a[i] != y.a[i]) return x.a[i] < y.a[i] ? -1 : 1;",
            "\t\treturn 0;",
            "\t}",
            "\tBigInt operator - () const { BigInt res = *this; if (isZero()) return res; res.sign = -sign; return res; }",
            "\tvoid __internal_add(const BigInt &v) {",
            "\t\tif (a.size() < v.a.size()) a.resize(v.a.size(), 0);",
            "\t\tfor (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {",
            "\t\t\tif (i == (int) a.size()) a.push_back(0);",
            "\t\t\ta[i] += carry + (i < (int) v.a.size() ? v.a[i] : 0);",
            "\t\t\tcarry = a[i] >= BASE; if (carry) a[i] -= BASE;",
            "\t\t}",
            "\t}",
            "\tvoid __internal_sub(const BigInt &v) {",
            "\t\tfor (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {",
            "\t\t\ta[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);",
            "\t\t\tcarry = a[i] < 0; if (carry) a[i] += BASE;",
            "\t\t}",
            "\t\tthis->trim();",
            "\t}",
            "\tBigInt operator += (const BigInt &v) {",
            "\t\tif (sign == v.sign) __internal_add(v);",
            "\t\telse {",
            "\t\t\tif (__compare_abs(*this, v) >= 0) __internal_sub(v);",
            "\t\t\telse { BigInt vv = v; swap(*this, vv); __internal_sub(vv); }",
            "\t\t}",
            "\t\treturn *this;",
            "\t}",
            "\tBigInt operator -= (const BigInt &v) {",
            "\t\tif (sign == v.sign) {",
            "\t\t\tif (__compare_abs(*this, v) >= 0) __internal_sub(v);",
            "\t\t\telse { BigInt vv = v; swap(*this, vv); __internal_sub(vv); this->sign = -this->sign; }",
            "\t\t} else __internal_add(v);",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename L, typename R> typename enable_if <is_convertible<L, BigInt>::value && is_convertible<R, BigInt>::value && is_lvalue_reference < R&& >::value, BigInt>::type friend operator + (L &&l, R &&r) {",
            "\t\tBigInt result(forward<L>(l)); result += r; return result;",
            "\t}",
            "\ttemplate <typename L, typename R> typename enable_if <is_convertible<L, BigInt>::value && is_convertible<R, BigInt>::value && is_rvalue_reference < R&& >::value, BigInt>::type friend operator + (L &&l, R &&r) {",
            "\t\tBigInt result(move(r)); result += l; return result;",
            "\t}",
            "\ttemplate <typename L, typename R> typename enable_if <is_convertible<L, BigInt>::value && is_convertible<R, BigInt>::value, BigInt>::type friend operator - (L &&l, R &&r) {",
            "\t\tBigInt result(forward<L>(l)); result -= r; return result;",
            "\t}",
            "\tfriend pair <BigInt, BigInt> divmod(const BigInt &a1, const BigInt &b1) {",
            "\t\tassert(b1 > 0);",
            "\t\tlong long norm = BASE / (b1.a.back() + 1);",
            "\t\tBigInt a = a1.abs() * norm, b = b1.abs() * norm, q = 0, r = 0;",
            "\t\tq.a.resize(a.a.size());",
            "\t\tfor (int i = a.a.size() - 1; i >= 0; i--) {",
            "\t\t\tr *= BASE; r += a.a[i];",
            "\t\t\tlong long s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];",
            "\t\t\tlong long s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];",
            "\t\t\tlong long d = ((long long) BASE * s1 + s2) / b.a.back();",
            "\t\t\tr -= b * d; while (r < 0) r += b, --d; q.a[i] = d;",
            "\t\t}",
            "\t\tq.sign = a1.sign * b1.sign; r.sign = a1.sign; q.trim(); r.trim();",
            "\t\tauto res = make_pair(q, r / norm); if (res.second < 0) res.second += b1; return res;",
            "\t}",
            "\tBigInt operator / (const BigInt &v) const {",
            "\t\tif (v < 0) return divmod(-*this, -v).first;",
            "\t\treturn divmod(*this, v).first;",
            "\t}",
            "",
            "\tBigInt operator % (const BigInt &v) const { return divmod(*this, v).second; }",
            "\tvoid operator /= (int v) {",
            "\t\tassert(v > 0);",
            "\t\tif (llabs(v) >= BASE) { *this /= BigInt(v); return; }",
            "\t\tif (v < 0) sign = -sign, v = -v;",
            "\t\tfor (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {",
            "\t\t\tlong long cur = a[i] + rem * (long long) BASE;",
            "\t\t\ta[i] = (int) (cur / v); rem = (int) (cur % v);",
            "\t\t}",
            "\t\ttrim();",
            "\t}",
            "\tBigInt operator / (int v) const {",
            "\t\tassert(v > 0);",
            "\t\tif (llabs(v) >= BASE) return *this / BigInt(v);",
            "\t\tBigInt res = *this; res /= v; return res;",
            "\t}",
            "\tvoid operator /= (const BigInt &v) { *this = *this / v; }",
            "\tlong long operator % (long long v) const {",
            "\t\tassert(v > 0); assert(v < BASE);",
            "\t\tint m = 0; for (int i = (int) a.size() - 1; i >= 0; --i) m = (a[i] + m * (long long) BASE) % v;",
            "\t\treturn m * sign;",
            "\t}",
            "\tvoid operator *= (int v) {",
            "\t\tif (llabs(v) >= BASE) { *this *= BigInt(v); return; }",
            "\t\tif (v < 0) sign = -sign, v = -v;",
            "\t\tfor (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {",
            "\t\t\tif (i == (int) a.size()) a.push_back(0);",
            "\t\t\tlong long cur = a[i] * (long long) v + carry;",
            "\t\t\tcarry = (int) (cur / BASE);",
            "\t\t\ta[i] = (int) (cur % BASE);",
            "\t\t}",
            "\t\ttrim();",
            "\t}",
            "\tBigInt operator*(int v) const {",
            "\t\tif (llabs(v) >= BASE) return *this * BigInt(v);",
            "\t\tBigInt res = *this; res *= v; return res;",
            "\t}",
            "\tstatic vector <int> convert_base(const vector<int> &a, int old_digits, int new_digits) {",
            "\t\tvector<long long> p(max(old_digits, new_digits) + 1); p[0] = 1;",
            "\t\tfor (int i = 1; i < (int) p.size(); i++) p[i] = p[i - 1] * 10;",
            "\t\tvector <int> res; long long cur = 0; int cur_digits = 0;",
            "\t\tfor (int i = 0; i < (int) a.size(); i++) {",
            "\t\t\tcur += a[i] * p[cur_digits]; cur_digits += old_digits;",
            "\t\t\twhile (cur_digits >= new_digits) {",
            "\t\t\t\tres.push_back((long long)(cur % p[new_digits]));",
            "\t\t\t\tcur /= p[new_digits]; cur_digits -= new_digits;",
            "\t\t\t}",
            "\t\t}",
            "\t\tres.push_back((int) cur); while (!res.empty() && !res.back()) res.pop_back();",
            "\t\treturn res;",
            "\t}",
            "\tvoid fft(vector <complex <double>> &x, bool invert) const {",
            "\t\tint n = (int) x.size();",
            "\t\tfor (int i = 1, j = 0; i < n; ++i) {",
            "\t\t\tint bit = n >> 1; for (; j >= bit; bit >>= 1) j -= bit;",
            "\t\t\tj += bit; if (i < j) swap(x[i], x[j]);",
            "\t\t}",
            "\t\tfor (int len = 2; len <= n; len <<= 1) {",
            "\t\t\tdouble ang = 2 * 3.14159265358979323846 / len * (invert ? -1 : 1);",
            "\t\t\tcomplex <double> wlen(cos(ang), sin(ang));",
            "\t\t\tfor (int i = 0; i < n; i += len) {",
            "\t\t\t\tcomplex <double> w(1);",
            "\t\t\t\tfor (int j = 0; j < len / 2; ++j) {",
            "\t\t\t\t\tcomplex<double> u = x[i + j]; complex<double> v = x[i + j + len / 2] * w;",
            "\t\t\t\t\tx[i + j] = u + v; x[i + j + len / 2] = u - v; w *= wlen;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (invert) for (int i = 0; i < n; ++i) x[i] /= n;",
            "\t}",
            "\tvoid multiply_fft(const vector <int> &x, const vector <int> &y, vector <int> &res) const {",
            "\t\tvector <complex <double> > fa(x.begin(), x.end());",
            "\t\tvector <complex <double> > fb(y.begin(), y.end());",
            "\t\tint n = 1; while (n < (int) max(x.size(), y.size())) n <<= 1; n <<= 1;",
            "\t\tfa.resize(n); fb.resize(n); fft(fa, false); fft(fb, false);",
            "\t\tfor (int i = 0; i < n; ++i) fa[i] *= fb[i];",
            "\t\tfft(fa, true); res.resize(n); long long carry = 0;",
            "\t\tfor (int i = 0; i < n; ++i) {",
            "\t\t\tlong long t = (long long) (fa[i].real() + 0.5) + carry;",
            "\t\t\tcarry = t / 1000; res[i] = t % 1000;",
            "\t\t}",
            "\t}",
            "\tBigInt mul_simple(const BigInt &v) const {",
            "\t\tBigInt res;",
            "\t\tres.sign = sign * v.sign;",
            "\t\tres.a.resize(a.size() + v.a.size());",
            "\t\tfor (int i = 0; i < (int) a.size(); ++i)",
            "\t\t\tif (a[i])",
            "\t\t\t\tfor (int j = 0, carry = 0; j < (int) v.a.size() || carry; ++j) {",
            "\t\t\t\t\tlong long cur = res.a[i + j] + (long long) a[i] * (j < (int) v.a.size() ? v.a[j] : 0) + carry;",
            "\t\t\t\t\tcarry = (int) (cur / BASE);",
            "\t\t\t\t\tres.a[i + j] = (int) (cur % BASE);",
            "\t\t\t\t}",
            "\t\tres.trim();",
            "\t\treturn res;",
            "\t}",
            "\ttypedef vector <long long> vll;",
            "\tstatic vll karatsubaMultiply(const vll &a, const vll &b) {",
            "\t\tint n = a.size();",
            "\t\tvll res(n + n);",
            "\t\tif (n <= 32) {",
            "\t\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) res[i + j] += a[i] * b[j];",
            "\t\t\treturn res;",
            "\t\t}",
            "\t\tint k = n >> 1;",
            "\t\tvll a1(a.begin(), a.begin() + k), a2(a.begin() + k, a.end()), b1(b.begin(), b.begin() + k), b2(b.begin() + k, b.end());",
            "\t\tvll a1b1 = karatsubaMultiply(a1, b1), a2b2 = karatsubaMultiply(a2, b2);",
            "\t\tfor (int i = 0; i < k; i++) a2[i] += a1[i];",
            "\t\tfor (int i = 0; i < k; i++) b2[i] += b1[i];",
            "\t\tvll r = karatsubaMultiply(a2, b2);",
            "\t\tfor (int i = 0; i < (int) a1b1.size(); i++) r[i] -= a1b1[i];",
            "\t\tfor (int i = 0; i < (int) a2b2.size(); i++) r[i] -= a2b2[i];",
            "\t\tfor (int i = 0; i < (int) r.size(); i++) res[i + k] += r[i];",
            "\t\tfor (int i = 0; i < (int) a1b1.size(); i++) res[i] += a1b1[i];",
            "\t\tfor (int i = 0; i < (int) a2b2.size(); i++) res[i + n] += a2b2[i];",
            "\t\treturn res;",
            "\t}",
            "\tBigInt mul_karatsuba(const BigInt &v) const {",
            "\t\tvector <int> x6 = convert_base(this->a, BASE_DIGITS, 6);",
            "\t\tvector <int> y6 = convert_base(v.a, BASE_DIGITS, 6);",
            "\t\tvll x(x6.begin(), x6.end()), y(y6.begin(), y6.end());",
            "\t\twhile (x.size() < y.size()) x.push_back(0);",
            "\t\twhile (y.size() < x.size()) y.push_back(0);",
            "\t\twhile (x.size() & (x.size() - 1)) x.push_back(0), y.push_back(0);",
            "\t\tvll c = karatsubaMultiply(x, y);",
            "\t\tBigInt res; res.sign = sign * v.sign; long long carry = 0;",
            "\t\tfor (int i = 0; i < (int) c.size(); i++) {",
            "\t\t\tlong long cur = c[i] + carry; res.a.push_back((int) (cur % 1000000)); carry = cur / 1000000;",
            "\t\t}",
            "\t\tres.a = convert_base(res.a, 6, BASE_DIGITS); res.trim(); return res;",
            "\t}",
            "\tvoid operator*=(const BigInt &v) { *this = *this * v; }",
            "\tBigInt operator*(const BigInt &v) const {",
            "\t\tif (a.size() * v.a.size() <= 1000111) return mul_simple(v);",
            "\t\tif (a.size() > 500111 || v.a.size() > 500111) return mul_fft(v);",
            "\t\treturn mul_karatsuba(v);",
            "\t}",
            "\tBigInt mul_fft(const BigInt& v) const {",
            "\t\tBigInt res; res.sign = sign * v.sign;",
            "\t\tmultiply_fft(convert_base(a, BASE_DIGITS, 3), convert_base(v.a, BASE_DIGITS, 3), res.a);",
            "\t\tres.a = convert_base(res.a, 3, BASE_DIGITS); res.trim(); return res;",
            "\t}",
            "\tBigInt abs() const { BigInt res = *this; res.sign *= res.sign; return res; }",
            "\tvoid trim() { while (!a.empty() && !a.back()) a.pop_back(); if (a.empty()) sign = 1; }",
            "\tbool isZero() const { return a.empty() || (a.size() == 1 && !a[0]); }",
            "\tfriend BigInt gcd(const BigInt &x, const BigInt &y) { return y.isZero() ? x : gcd(y, x % y); }",
            "\tfriend BigInt lcm(const BigInt &x, const BigInt &y) { return x / gcd(x, y) * y; }",
            "\tfriend BigInt sqrt(const BigInt &a1) {",
            "\t\tBigInt a = a1;",
            "\t\twhile (a.a.empty() || a.a.size() % 2 == 1) a.a.push_back(0);",
            "\t\tint n = a.a.size();",
            "\t\tint firstDigit = (int) sqrt((double) a.a[n - 1] * BASE + a.a[n - 2]), norm = BASE / (firstDigit + 1);",
            "\t\ta *= norm; a *= norm;",
            "\t\twhile (a.a.empty() || a.a.size() % 2 == 1) a.a.push_back(0);",
            "\t\tBigInt r = (long long) a.a[n - 1] * BASE + a.a[n - 2];",
            "\t\tfirstDigit = (int) sqrt((double) a.a[n - 1] * BASE + a.a[n - 2]);",
            "\t\tint q = firstDigit; BigInt res;",
            "\t\tfor (int j = n / 2 - 1; j >= 0; j--) {",
            "\t\t\tfor (; ; --q) {",
            "\t\t\t\tBigInt r1 = (r - (res * 2 * BigInt(BASE) + q) * q) * BigInt(BASE) * BigInt(BASE) + (j > 0 ? (long long) a.a[2 * j - 1] * BASE + a.a[2 * j - 2] : 0);",
            "\t\t\t\tif (r1 >= 0) { r = r1; break; }",
            "\t\t\t}",
            "\t\t\tres *= BASE; res += q;",
            "\t\t\tif (j > 0) {",
            "\t\t\t\tint d1 = res.a.size() + 2 < r.a.size() ? r.a[res.a.size() + 2] : 0;",
            "\t\t\t\tint d2 = res.a.size() + 1 < r.a.size() ? r.a[res.a.size() + 1] : 0;",
            "\t\t\t\tint d3 = res.a.size() < r.a.size() ? r.a[res.a.size()] : 0;",
            "\t\t\t\tq = ((long long) d1 * BASE * BASE + (long long) d2 * BASE + d3) / (firstDigit * 2);",
            "\t\t\t}",
            "\t\t}",
            "\t\tres.trim(); return res / norm;",
            "\t}",
            "};",
            ""
        ],
        "description": "BIGINT"
    },
    "BENCHMARK": {
        "scope": "cpp",
        "prefix": "BENCHMARK",
        "body": [
            "struct Benchmark {",
            "\tunsigned long long tim, newtim;",
            "",
            "\tunsigned long long get_cur_time(){",
            "\t\treturn chrono::steady_clock::now().time_since_epoch().count();",
            "\t}",
            "",
            "\tBenchmark() {",
            "\t\ttim = newtim = get_cur_time();",
            "\t}",
            "",
            "\tstring section(string name) {",
            "\t\tnewtim = get_cur_time();",
            "\t\tstringstream ss;",
            "\t\tss << fixed << setprecision(9);",
            "\t\tss << name << \": \" << (long double) (newtim - tim) / 1e9;",
            "\t\ttim = newtim;",
            "\t\tstring ans;",
            "\t\tgetline(ss, ans);",
            "\t\treturn ans;",
            "\t}",
            "};",
            ""
        ],
        "description": "BENCHMARK"
    },
    "Z_FUNCTION": {
        "scope": "cpp",
        "prefix": "Z_FUNCTION",
        "body": [
            "template <typename T> vector <int> z_function(int n, const T &s) {",
            "\tif (!n) return {};",
            "\tvector <int> z(n);",
            "\tz[0] = 0;",
            "\tfor (int i = 1, j = 0; i < n; i++) {",
            "\t\tint &k = z[i];",
            "\t\tk = j + z[j] <= i ? 0 : min(j + z[j] - i, z[i - j]);",
            "\t\twhile (i + k < n && s[k] == s[i + k]) k++;",
            "\t\tif (j + z[j] < i + z[i]) j = i;",
            "\t}",
            "\tz[0] = n;",
            "\treturn z;",
            "}",
            "template <typename T> vector <int> z_function(const T &s) { return z_function(s.size(), s); }",
            ""
        ],
        "description": "Z_FUNCTION"
    },
    "WAVELET_TREE": {
        "scope": "cpp",
        "prefix": "WAVELET_TREE",
        "body": [
            "struct WaveletTree {",
            "\tint lo, hi, mid;",
            "\tvector <int> b;",
            "\tWaveletTree *left, *right;",
            "\ttemplate <class RandomIt> WaveletTree(RandomIt first, RandomIt last) {",
            "\t\tif (first == last) return;",
            "\t\tauto x = minmax_element(first, last);",
            "\t\tlo = *x.fi; hi = *x.se;",
            "\t\tif (lo == hi) return;",
            "\t\tmid = lo + hi >> 1;",
            "\t\tauto f = [&] (int x) { return x <= mid; };",
            "\t\tb.reserve(last - first + 1);",
            "\t\tb.push_back(0);",
            "\t\tfor (auto it = first; it != last; ++it) b.push_back(b.back() + f(*it));",
            "\t\tauto mid = stable_partition(first, last, f);",
            "\t\tleft = new WaveletTree(first, mid);",
            "\t\tright = new WaveletTree(mid, last);",
            "\t}",
            "\t// kth smallest element in [l, r)",
            "\tint kth_smallest(int l, int r, int k) {",
            "\t\tif (l > r) return 0;",
            "\t\tif (lo == hi) return lo;",
            "\t\tint inLeft = b[r] - b[l];",
            "\t\tif (k <= inLeft) return left->kth_smallest(b[l], b[r], k);",
            "\t\treturn right->kth_smallest(l - b[l], r - b[r], k - inLeft);",
            "\t}",
            "\t// kth largest element in [l, r)",
            "\tint kth_largest(int l, int r, int k) {",
            "\t\tif (l > r) return 0;",
            "\t\tif (lo == hi) return lo;",
            "\t\tint inRight = r - l - b[r] + b[l];",
            "\t\tif (k <= inRight) return right->kth_largest(l - b[l], r - b[r], k);",
            "\t\treturn left->kth_largest(b[l], b[r], k - inRight);",
            "\t}",
            "\t// count of nos in [l, r) Less than or equal to k",
            "\tint LTE(int l, int r, int k) {",
            "\t\tif (l > r || k < lo) return 0;",
            "\t\tif (hi <= k) return r - l;",
            "\t\treturn left->LTE(b[l], b[r], k) + right->LTE(l - b[l], r - b[r], k);",
            "\t}",
            "\t// count of nos in [l, r) equal to k",
            "\tint count(int l, int r, int k) {",
            "\t\tif (l > r || k < lo || k > hi) return 0;",
            "\t\tif (lo == hi) return r - l;",
            "\t\tif (k <= mid) return left->count(b[l], b[r], k);",
            "\t\treturn right->count(l - b[l], r - b[r], k);",
            "\t}",
            "};",
            ""
        ],
        "description": "WAVELET_TREE"
    },
    "TWO_SAT": {
        "scope": "cpp",
        "prefix": "TWO_SAT",
        "body": [
            "class TwoSat {",
            "private: ",
            "\tint n;",
            "\tvector <int> order, used, comp;",
            "\tvector <bool> _answer;",
            "\tvector <vector <int>> adj, r_adj;",
            "\tvoid addEdge(int u, int v) {",
            "\t\tadj[u].push_back(v);",
            "\t\tr_adj[v].push_back(u);",
            "\t}",
            "\tvoid dfs1(int u) {",
            "\t\tused[u] = true;",
            "\t\tfor (int v: adj[u]) if (!used[v]) dfs1(v);",
            "\t\torder.push_back(u);",
            "\t}",
            "\tvoid dfs2(int u, int cl) {",
            "\t\tcomp[u] = cl;",
            "\t\tfor (int v: r_adj[u]) if (!~comp[v]) dfs2(v, cl);",
            "\t}",
            "public:",
            "\tTwoSat(int _n = 0) {",
            "\t\tn = _n;",
            "\t\tadj.assign(n << 1, vector<int>());",
            "\t\tr_adj.assign(n << 1, vector<int>());",
            "\t\tused.resize(n << 1);",
            "\t\tcomp.resize(n << 1);",
            "\t}",
            "\tvoid addChoiceCondition(int var1, int type1, int var2, int type2) { ",
            "\t\t// condition type: A or B",
            "\t\tassert(0 <= var1 && var1 < n);",
            "\t\tassert(0 <= type1 && type1 < 2);",
            "\t\tassert(0 <= var2 && var2 < n);",
            "\t\tassert(0 <= type2 && type2 < 2);",
            "\t\tvar1 = var1 << 1 | type1;",
            "\t\tvar2 = var2 << 1 | type2;",
            "\t\taddEdge(var1 ^ 1, var2);",
            "\t\taddEdge(var2 ^ 1, var1);",
            "\t}",
            "\tvoid addMustFalseCondition(int var) {",
            "\t\t// Condition type: A = false",
            "\t\taddChoiceCondition(var, false, var, false);",
            "\t}",
            "\tvoid addMustTrueCondition(int var) {",
            "\t\t// Condition type: A = true",
            "\t\taddChoiceCondition(var, true, var, true);",
            "\t}",
            "\tvoid addInferCondition(int var1, int type1, int var2, int type2) {",
            "\t\t// Condition type: A -> B",
            "\t\taddChoiceCondition(var1, !type1, var2, type2);",
            "\t}",
            "\tbool satisfiable(void) {",
            "\t\torder.clear();",
            "\t\tfill(used.begin(), used.end(), false);",
            "\t\tfill(comp.begin(), comp.end(), -1);",
            "\t\tfor (int i = 0; i < n << 1; ++i) if (!used[i]) dfs1(i);",
            "\t\tfor (int i = n << 1, j = 0; i--; ) {",
            "\t\t\tint u = order[i];",
            "\t\t\tif (!~comp[u]) dfs2(u, j++);",
            "\t\t}",
            "\t\t_answer.resize(n);",
            "\t\tfor (int i = 0; i < n << 1; i += 2) {",
            "\t\t\tif (comp[i] == comp[i + 1]) return false;",
            "\t\t\t_answer[i >> 1] = comp[i] < comp[i + 1];",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "\tvector <bool> answer() { return _answer; }",
            "};",
            ""
        ],
        "description": "TWO_SAT"
    },
    "SUFFIX_ARRAY": {
        "scope": "cpp",
        "prefix": "SUFFIX_ARRAY",
        "body": [
            "namespace SUFFIX_ARRAY {",
            "vector<int> sa_naive(const vector<int>& s) {",
            "\tint n = s.size();",
            "\tvector <int> sa(n);",
            "\tiota(sa.begin(), sa.end(), 0);",
            "\tsort(sa.begin(), sa.end(), [&](int l, int r) {",
            "\t\tif (l == r) return false;",
            "\t\twhile (l < n && r < n) {",
            "\t\t\tif (s[l] != s[r]) return s[l] < s[r];",
            "\t\t\tl++; r++;",
            "\t\t}",
            "\t\treturn l == n;",
            "\t});",
            "\treturn sa;",
            "}",
            "vector <int> sa_doubling(const vector <int>& s) {",
            "\tint n = s.size();",
            "\tvector <int> sa(n), rnk = s, tmp(n);",
            "\tiota(sa.begin(), sa.end(), 0);",
            "\tfor (int k = 1; k < n; k <<= 1) {",
            "\t\tauto cmp = [&](int x, int y) {",
            "\t\t\tif (rnk[x] != rnk[y]) return rnk[x] < rnk[y];",
            "\t\t\tint rx = x + k < n ? rnk[x + k] : -1;",
            "\t\t\tint ry = y + k < n ? rnk[y + k] : -1;",
            "\t\t\treturn rx < ry;",
            "\t\t};",
            "\t\tsort(sa.begin(), sa.end(), cmp);",
            "\t\ttmp[sa[0]] = 0;",
            "\t\tfor (int i = 1; i < n; ++i) tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);",
            "\t\tswap(tmp, rnk);",
            "\t}",
            "\treturn sa;",
            "}",
            "template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40> ",
            "vector <int> sa_is(const vector <int> &s, int upper) {",
            "\tint n = int(s.size());",
            "\tif (n == 0) return {};",
            "\tif (n == 1) return {0};",
            "\tif (n == 2) {",
            "\t\tif (s[0] < s[1]) return {0, 1};",
            "\t\treturn {1, 0};",
            "\t}",
            "\tif (n < THRESHOLD_NAIVE) return sa_naive(s);",
            "\tif (n < THRESHOLD_DOUBLING) return sa_doubling(s);",
            "\tvector <int> sa(n);",
            "\tvector <bool> ls(n);",
            "\tfor (int i = n - 2; i >= 0; --i) ls[i] = s[i] == s[i + 1] ? ls[i + 1] : s[i] < s[i + 1];",
            "\tvector <int> sum_l(upper + 1), sum_s(upper + 1);",
            "\tfor (int i = 0; i < n; ++i) (ls[i] ? sum_l[s[i] + 1] : sum_s[s[i]])++;",
            "\tfor (int i = 0; i <= upper; ++i) {",
            "\t\tsum_s[i] += sum_l[i];",
            "\t\tif (i < upper) sum_l[i + 1] += sum_s[i];",
            "\t}",
            "\tauto induce = [&](const vector <int>& lms) {",
            "\t\tfill(sa.begin(), sa.end(), -1);",
            "\t\tvector <int> buf(upper + 1);",
            "\t\tcopy(sum_s.begin(), sum_s.end(), buf.begin());",
            "\t\tfor (auto d: lms) if (d != n) sa[buf[s[d]]++] = d;",
            "\t\tcopy(sum_l.begin(), sum_l.end(), buf.begin());",
            "\t\tsa[buf[s[n - 1]]++] = n - 1;",
            "\t\tfor (int i = 0; i < n; ++i) {",
            "\t\t\tint v = sa[i];",
            "\t\t\tif (v >= 1 && !ls[v - 1]) sa[buf[s[v - 1]]++] = v - 1;",
            "\t\t}",
            "\t\tcopy(sum_l.begin(), sum_l.end(), buf.begin());",
            "\t\tfor (int i = n - 1; i >= 0; --i) {",
            "\t\t\tint v = sa[i];",
            "\t\t\tif (v >= 1 && ls[v - 1]) sa[--buf[s[v - 1] + 1]] = v - 1;",
            "\t\t}",
            "\t};",
            "\tvector <int> lms_map(n + 1, -1);",
            "\tint m = 0;",
            "\tfor (int i = 1; i < n; ++i) if (!ls[i - 1] && ls[i]) lms_map[i] = m++;",
            "\tvector <int> lms;",
            "\tlms.reserve(m);",
            "\tfor (int i = 1; i < n; ++i) if (!ls[i - 1] && ls[i]) lms.push_back(i);",
            "\tinduce(lms);",
            "\tif (m) {",
            "\t\tvector <int> sorted_lms;",
            "\t\tsorted_lms.reserve(m);",
            "\t\tfor (int v: sa) if (lms_map[v] != -1) sorted_lms.push_back(v);",
            "\t\tvector <int> rec_s(m);",
            "\t\tint rec_upper = 0;",
            "\t\trec_s[lms_map[sorted_lms[0]]] = 0;",
            "\t\tfor (int i = 1; i < m; ++i) {",
            "\t\t\tint l = sorted_lms[i - 1], r = sorted_lms[i];",
            "\t\t\tint end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;",
            "\t\t\tint end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;",
            "\t\t\tbool same = true;",
            "\t\t\tif (end_l - l != end_r - r) same = false;",
            "\t\t\telse {",
            "\t\t\t\twhile (l < end_l) {",
            "\t\t\t\t\tif (s[l] != s[r]) break;",
            "\t\t\t\t\tl++; r++;",
            "\t\t\t\t}",
            "\t\t\t\tif (l == n || s[l] != s[r]) same = false;",
            "\t\t\t}",
            "\t\t\tif (!same) rec_upper++;",
            "\t\t\trec_s[lms_map[sorted_lms[i]]] = rec_upper;",
            "\t\t}",
            "\t\tauto rec_sa = sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);",
            "\t\tfor (int i = 0; i < m; ++i) sorted_lms[i] = lms[rec_sa[i]];",
            "\t\tinduce(sorted_lms);",
            "\t}",
            "\treturn sa;",
            "}",
            "vector <int> suffix_array(const vector <int> &s, int upper) {",
            "\tassert(0 <= upper);",
            "\tfor (int d: s) assert(0 <= d && d <= upper);",
            "\tauto sa = sa_is(s, upper);",
            "\treturn sa;",
            "}",
            "template <class T> vector <int> suffix_array(const vector <T> &s) {",
            "\tint n = s.size();",
            "\tvector <int> idx(n);",
            "\tiota(idx.begin(), idx.end(), 0);",
            "\tsort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });",
            "\tvector <int> s2(n);",
            "\tint now = 0;",
            "\tfor (int i = 0; i < n; ++i) {",
            "\t\tif (i && s[idx[i - 1]] != s[idx[i]]) now++;",
            "\t\ts2[idx[i]] = now;",
            "\t}",
            "\treturn sa_is(s2, now);",
            "}",
            "vector <int> suffix_array(const string& s) {",
            "\tint n = s.size();",
            "\tvector <int> s2(n);",
            "\tfor (int i = 0; i < n; ++i) s2[i] = s[i];",
            "\treturn sa_is(s2, 255);",
            "}",
            "template <class T> vector <int> lcp_array(const vector <T> &s, const vector <int> &sa) {",
            "\tint n = s.size();",
            "\tassert(n > 0);",
            "\tvector <int> rnk(n);",
            "\tfor (int i = 0; i < n; ++i) rnk[sa[i]] = i;",
            "\tvector <int> lcp(n - 1);",
            "\tint h = 0;",
            "\tfor (int i = 0; i < n; ++i) {",
            "\t\tif (h > 0) h--;",
            "\t\tif (!rnk[i]) continue;",
            "\t\tint j = sa[rnk[i] - 1];",
            "\t\tfor (; j + h < n && i + h < n; h++) if (s[j + h] != s[i + h]) break;",
            "\t\tlcp[rnk[i] - 1] = h;",
            "\t}",
            "\treturn lcp;",
            "}",
            "vector <int> lcp_array(const string &s, const vector <int> &sa) {",
            "\tint n = s.size();",
            "\tvector <int> s2(n);",
            "\tfor (int i = 0; i < n; i++) s2[i] = s[i];",
            "\treturn lcp_array(s2, sa);",
            "}",
            "} using namespace SUFFIX_ARRAY;",
            ""
        ],
        "description": "SUFFIX_ARRAY"
    },
    "SUBSET_CONVOLUTION": {
        "scope": "cpp",
        "prefix": "SUBSET_CONVOLUTION",
        "body": [
            "namespace SUBSET_CONVOLUTION {",
            "\ttemplate <class T> void zeta_transform(vector <T> &a, bool rev = false) {",
            "\t\tint n = 0; while ((1 << n) < (int) a.size()) ++n;",
            "\t\ta.resize(1 << n);",
            "\t\tfor (int i = 0; i < n; ++i)",
            "\t\t\tfor (int mask = 0; mask < 1 << n; ++mask)",
            "\t\t\t\tif ((mask >> i & 1) ^ rev) a[mask] += a[mask ^ (1 << i)];",
            "\t}",
            "\ttemplate <class T> void mobius_transform(vector <T> &a, bool rev = false) {",
            "\t\tint n = 0; while ((1 << n) < (int) a.size()) ++n;",
            "\t\ta.resize(1 << n);",
            "\t\tfor (int i = 0; i < n; ++i)",
            "\t\t\tfor (int mask = 0; mask < 1 << n; ++mask)",
            "\t\t\t\tif ((mask >> i & 1) ^ rev) a[mask] -= a[mask ^ (1 << i)];",
            "\t}",
            "\ttemplate <class T> vector <T> subset_sum_convolution(const vector <T> &f, const vector <T> &g) {",
            "\t\tint n = 0; while ((1 << n) < (int) max(f.size(), g.size())) ++n;",
            "\t\tvector <vector <T>> fhat(n + 1, vector<T>(1 << n)), ghat(n + 1, vector<T>(1 << n));",
            "\t\tfor (int mask = 0; mask < 1 << n; ++mask) {",
            "\t\t\tint i = __builtin_popcount(mask);",
            "\t\t\tif (mask < (int) f.size()) fhat[i][mask] = f[mask];",
            "\t\t\tif (mask < (int) g.size()) ghat[i][mask] = g[mask];",
            "\t\t}",
            "\t\tfor (int i = 0; i < n; ++i) {",
            "\t\t\tzeta_transform(fhat[i]);",
            "\t\t\tzeta_transform(ghat[i]);",
            "\t\t}",
            "\t\tvector <T> res(1 << n), h(1 << n);",
            "\t\tfor (int i = 0; i <= n; ++i) {",
            "\t\t\tfor (int j = 0; j <= i; ++j)",
            "\t\t\t\tfor (int mask = 0; mask < 1 << n; ++mask)",
            "\t\t\t\t\t\th[mask] += fhat[j][mask] * ghat[i - j][mask];",
            "\t\t\tmobius_transform(h);",
            "\t\t\tfor (int mask = 0; mask < 1 << n; ++mask)",
            "\t\t\t\tif (__builtin_popcount(mask) == i) res[mask] = h[mask];",
            "\t\t\tfill(h.begin(), h.end(), T{});",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\ttemplate <class T> void fft(vector <T> &a, bool rev = false) {",
            "\t\tint n = a.size();",
            "\t\tfor (int i = 1; i < n; i <<= 1) {",
            "\t\t\tfor (int mask = 0; mask < n; ++mask) {",
            "\t\t\t\tif (!(mask & i)) {",
            "\t\t\t\t\tT u = a[mask], v = a[mask ^ i];",
            "\t\t\t\t\ta[mask] = u + v;",
            "\t\t\t\t\ta[mask ^ i] = u - v;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (rev) {",
            "\t\t\tT inv = T(1) / n;",
            "\t\t\tfor (int mask = 0; mask < n; ++mask) a[mask] *= inv;",
            "\t\t}",
            "\t}",
            "\ttemplate <class T> vector <T> or_convolution(vector <T> f, vector <T> g) {",
            "\t\tint n = 1;",
            "\t\twhile (n < (int) max(f.size(), g.size())) n <<= 1;",
            "\t\tf.resize(n); g.resize(n);",
            "\t\tzeta_transform(f);",
            "\t\tzeta_transform(g);",
            "\t\tfor (int i = 0; i < n; ++i) f[i] *= g[i];",
            "\t\tmobius_transform(f);",
            "\t\treturn f;",
            "\t}",
            "\ttemplate <class T> vector <T> and_convolution(vector <T> f, vector <T> g) {",
            "\t\tint n = 1;",
            "\t\twhile (n < (int) max(f.size(), g.size())) n <<= 1;",
            "\t\tf.resize(n); g.resize(n);",
            "\t\tzeta_transform(f, true);",
            "\t\tzeta_transform(g, true);",
            "\t\tfor (int i = 0; i < n; ++i) f[i] *= g[i];",
            "\t\tmobius_transform(f, true);",
            "\t\treturn f;",
            "\t}",
            "\ttemplate <class T> vector <T> xor_convolution(vector <T> f, vector <T> g) {",
            "\t\tint n = 1;",
            "\t\twhile (n < (int) max(f.size(), g.size())) n <<= 1;",
            "\t\tf.resize(n); g.resize(n);",
            "\t\tfft(f); fft(g);",
            "\t\tfor (int i = 0; i < n; ++i) f[i] *= g[i];",
            "\t\tfft(f, true);",
            "\t\treturn f;",
            "\t}",
            "} using namespace SUBSET_CONVOLUTION;",
            ""
        ],
        "description": "SUBSET_CONVOLUTION"
    },
    "STRONGLY_CONNECTED_COMPONENT": {
        "scope": "cpp",
        "prefix": "STRONGLY_CONNECTED_COMPONENT",
        "body": [
            "template <class E> struct csr {",
            "\tvector <int> st;",
            "\tvector <E> lst;",
            "\texplicit csr(int n, const vector <pair <int, E>> &edges): st(n + 1), lst(edges.size()) {",
            "\t\tfor (auto e: edges) st[e.first + 1]++;",
            "\t\tfor (int i = 1; i <= n; i++) st[i] += st[i - 1];",
            "\t\tauto cnt = st;",
            "\t\tfor (auto e: edges) lst[cnt[e.first]++] = e.second;",
            "\t}",
            "};",
            "",
            "struct StronglyConnectedComponent {",
            "\tint n;",
            "\tvector <pair <int, int>> edges;",
            "\tvector <int> low, num;",
            "\tStronglyConnectedComponent(int _n) : n(_n) {}",
            "\tvoid add(int from, int to) { edges.emplace_back(from, to); }",
            "\tpair <int, vector <int>> scc_ids() {",
            "\t\tauto g = csr<int>(n, edges);",
            "\t\tint t = 0, group_num = 0;",
            "\t\tlow.resize(n);",
            "\t\tnum.assign(n, -1);",
            "\t\tvector <int> visited, ids(n);",
            "\t\tvisited.reserve(n);",
            "\t\tauto dfs = [&] (auto self, int u) -> void {",
            "\t\t\tlow[u] = num[u] = t++;",
            "\t\t\tvisited.push_back(u);",
            "\t\t\tfor (int i = g.st[u]; i < g.st[u + 1]; i++) {",
            "\t\t\t\tint v = g.lst[i];",
            "\t\t\t\tif (num[v] == -1) {",
            "\t\t\t\t\tself(self, v);",
            "\t\t\t\t\tlow[u] = min(low[u], low[v]);",
            "\t\t\t\t} else low[u] = min(low[u], num[v]);",
            "\t\t\t}",
            "\t\t\tif (low[u] == num[u]) {",
            "\t\t\t\tint v;",
            "\t\t\t\tdo {",
            "\t\t\t\t\tv = visited.back(); visited.pop_back();",
            "\t\t\t\t\tnum[v] = n;",
            "\t\t\t\t\tids[v] = group_num;",
            "\t\t\t\t} while (v != u);",
            "\t\t\t\tgroup_num++;",
            "\t\t\t}",
            "\t\t};",
            "\t\tfor (int i = 0; i < n; i++) if (num[i] == -1) dfs(dfs, i);",
            "\t\tfor (auto &x: ids) x = group_num - 1 - x;",
            "\t\treturn {group_num, ids};",
            "\t}",
            "\tvector <vector <int>> scc() {",
            "\t\tauto [group_num, ids] = scc_ids();",
            "\t\tvector<int> cnt(group_num);",
            "\t\tfor (int x: ids) cnt[x]++;",
            "\t\tvector<vector<int>> groups(group_num);",
            "\t\tfor (int i = 0; i < group_num; i++) groups[i].reserve(cnt[i]);",
            "\t\tfor (int i = 0; i < n; i++) groups[ids[i]].push_back(i);",
            "\t\treturn groups;",
            "\t}",
            "};",
            ""
        ],
        "description": "STRONGLY_CONNECTED_COMPONENT"
    },
    "MANACHER": {
        "scope": "cpp",
        "prefix": "MANACHER",
        "body": [
            "template <typename T> vector <int> manacher(int n, const T &s) {",
            "\tif (!n) return vector<int>();",
            "\tvector <int> res(2 * n - 1);",
            "\tint l = -1, r = -1;",
            "\tfor (int z = 0; z < 2 * n - 1; z++) {",
            "\t\tint i = (z + 1) >> 1;",
            "\t\tint j = z >> 1;",
            "\t\tint p = (i >= r ? 0 : min(r - i, res[2 * (l + r) - z]));",
            "\t\twhile (j + p + 1 < n && i - p - 1 >= 0 && s[j + p + 1] == s[i - p - 1]) ++p;",
            "\t\tif (j + p > r) l = i - p, r = j + p;",
            "\t\tres[z] = p;",
            "\t}",
            "\treturn res;",
            "\t// res[2 * i] = odd radius in position i",
            "\t// res[2 * i + 1] = even radius between positions i and i + 1",
            "}",
            "template <typename T> vector<int> manacher(const T &s) { return manacher(s.size(), s); }",
            ""
        ],
        "description": "MANACHER"
    },
    "MAX_FLOW": {
        "scope": "cpp",
        "prefix": "MAX_FLOW",
        "body": [
            "namespace MAX_FLOW {",
            "template <class T> struct Edge {",
            "\tint from, to;",
            "\tT cap, flow;",
            "\tint nxt;",
            "\tEdge(int from = 0, int to = 0, T cap = 0, int nxt = -1): from(from), to(to), cap(cap), flow(0), nxt(nxt) {}",
            "};",
            "template <class T> struct PushRelabel {",
            "\tint n, max_level;",
            "\tvector <Edge <T>> edges;",
            "\tvector <vector <int>> lst;",
            "\tvector <int> head, level, cnt;",
            "\tvector <T> excess;",
            "\tvector <bool> active;",
            "\tPushRelabel(int n = 0): n(n), lst(n), head(n, -1), level(n), cnt(n + 1), excess(n), active(n) {}",
            "\tint add(int from, int to, T cap, bool bi = false) {",
            "\t\tint id = edges.size();",
            "\t\tedges.emplace_back(from, to, cap, head[from]);",
            "\t\thead[from] = id;",
            "\t\tedges.emplace_back(to, from, bi ? cap : 0, head[to]);",
            "\t\thead[to] = id + 1;",
            "\t\treturn id;",
            "\t}",
            "\tvoid enqueue(int u) {",
            "\t\tif (!active[u] && excess[u] && level[u] < n) {",
            "\t\t\tactive[u] = true;",
            "\t\t\tlst[level[u]].push_back(u);",
            "\t\t\tmax_level = max(max_level, level[u]);",
            "\t\t}",
            "\t}",
            "\tT max_flow(int s, int t) {",
            "\t\tfor (Edge <T> &e: edges) e.flow = 0;",
            "\t\tmax_level = 0;",
            "\t\tfor (int i = 0; i < n; ++i) lst[i].clear();",
            "\t\tfill(level.begin(), level.end(), 0);",
            "\t\tfill(excess.begin(), excess.end(), 0);",
            "\t\tfill(cnt.begin(), cnt.end(), 0);",
            "\t\tfill(active.begin(), active.end(), false);",
            "\t\tfor (int i = head[s]; i != -1; i = edges[i].nxt) excess[s] += edges[i].cap;",
            "\t\tcnt[0] = n;",
            "\t\tenqueue(s);",
            "\t\tactive[t] = true;",
            "\t\twhile (max_level >= 0) {",
            "\t\t\tif (!lst[max_level].empty()) {",
            "\t\t\t\tint u = lst[max_level].back();",
            "\t\t\t\tlst[max_level].pop_back();",
            "\t\t\t\tactive[u] = false;",
            "\t\t\t\tfor (int i = head[u]; i != -1 && excess[u]; i = edges[i].nxt) {",
            "\t\t\t\t\tT d = min(excess[u], edges[i].cap - edges[i].flow);",
            "\t\t\t\t\tif (d && level[u] == level[edges[i].to] + 1) {",
            "\t\t\t\t\t\tedges[i].flow += d; edges[i ^ 1].flow -= d;",
            "\t\t\t\t\t\texcess[edges[i].to] += d; excess[u] -= d;",
            "\t\t\t\t\t\tenqueue(edges[i].to);",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\tif (excess[u]) {",
            "\t\t\t\t\tif (cnt[level[u]] == 1) {",
            "\t\t\t\t\t\tint k = level[u];",
            "\t\t\t\t\t\tfor (int u = 0; u < n; ++u) if (level[u] >= k) {",
            "\t\t\t\t\t\t\t--cnt[level[u]];",
            "\t\t\t\t\t\t\tlevel[u] = n;",
            "\t\t\t\t\t\t\t++cnt[level[u]];",
            "\t\t\t\t\t\t\tenqueue(u);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t} else {",
            "\t\t\t\t\t\t--cnt[level[u]];",
            "\t\t\t\t\t\tlevel[u] = n;",
            "\t\t\t\t\t\tfor (int i = head[u]; i != -1; i = edges[i].nxt)",
            "\t\t\t\t\t\t\tif (edges[i].cap != edges[i].flow) level[u] = min(level[u], level[edges[i].to] + 1);",
            "\t\t\t\t\t\t++cnt[level[u]];",
            "\t\t\t\t\t\tenqueue(u);",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t} else max_level--;",
            "\t\t}",
            "\t\treturn excess[t];",
            "\t}",
            "};",
            "template <class T> struct Dinic {",
            "\tstatic constexpr T inf = numeric_limits<T>::max();",
            "\tint n, ss, tt;",
            "\tvector <Edge <T>> edges;",
            "\tvector <int> head, level, ptr, q;",
            "\tDinic(int n = 0): n(n), head(n, -1), level(n), ptr(n), q(n) {}",
            "\tint add(int from, int to, T cap, bool bi = false) {",
            "\t\tint id = edges.size();",
            "\t\tedges.emplace_back(from, to, cap, head[from]);",
            "\t\thead[from] = id;",
            "\t\tedges.emplace_back(to, from, bi ? cap : 0, head[to]);",
            "\t\thead[to] = id + 1;",
            "\t\treturn id;",
            "\t}",
            "\tbool bfs(void) {",
            "\t\tfill(level.begin(), level.end(), n + 1);",
            "\t\tq[0] = ss; level[ss] = 0;",
            "\t\tfor (int l = 0, r = 1; l < r; ) {",
            "\t\t\tint u = q[l++];",
            "\t\t\tfor (int i = head[u]; i != -1; i = edges[i].nxt) if (edges[i].cap != edges[i].flow) {",
            "\t\t\t\tint v = edges[i].to;",
            "\t\t\t\tif (level[v] == n + 1) {",
            "\t\t\t\t\tlevel[v] = level[u] + 1;",
            "\t\t\t\t\tif (v == tt) return true;",
            "\t\t\t\t\tq[r++] = v;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "\tT dfs(int u, T pushed) {",
            "\t\tif (u == ss) return pushed;",
            "\t\tT flow = 0;",
            "\t\tfor (int &j = ptr[u]; j != -1; j = edges[j].nxt) {",
            "\t\t\tint i = j ^ 1;",
            "\t\t\tif (edges[i].cap - edges[i].flow == 0 || level[edges[i].from] >= level[u]) continue;",
            "\t\t\tT tr = dfs(edges[i].from, min(pushed - flow, edges[i].cap - edges[i].flow));",
            "\t\t\tif (!tr) continue;",
            "\t\t\tedges[i].flow += tr;",
            "\t\t\tedges[j].flow -= tr;",
            "\t\t\tflow += tr;",
            "\t\t\tif (flow == pushed) return flow;",
            "\t\t}",
            "\t\tlevel[u] = n;",
            "\t\treturn flow;",
            "\t}",
            "\tT max_flow(int s, int t) {",
            "\t\tss = s; tt = t;",
            "\t\tfor (Edge <T> &e: edges) e.flow = 0;",
            "\t\tT flow = 0;",
            "\t\tq[0] = ss;",
            "\t\tfor (int L = 30; L >= 0; --L) {",
            "\t\t\twhile (true) {",
            "\t\t\t\tfill(level.begin(), level.end(), 0);",
            "\t\t\t\tint l = 0, r = level[s] = 1;",
            "\t\t\t\twhile (l < r && !level[t]) {",
            "\t\t\t\t\tint u = q[l++];",
            "\t\t\t\t\tfor (int i = head[u]; i != -1; i = edges[i].nxt) {",
            "\t\t\t\t\t\tif (!level[edges[i].to] && (edges[i].cap - edges[i].flow) >> L) {",
            "\t\t\t\t\t\t\tq[r++] = edges[i].to;",
            "\t\t\t\t\t\t\tlevel[edges[i].to] = level[u] + 1;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\tif (!level[t]) break;",
            "\t\t\t\tcopy(head.begin(), head.end(), ptr.begin());",
            "\t\t\t\tflow += dfs(t, inf);",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn flow;",
            "\t}",
            "};",
            "template <class Cap, class Cost> struct CEdge {",
            "\tint from, to;",
            "\tCap cap, flow;",
            "\tCost cost;",
            "\tint nxt;",
            "\tCEdge(int from = 0, int to = 0, Cap cap = 0, Cost cost = 0, int nxt = 0): from(from), to(to), cap(cap), flow(0), cost(cost), nxt(nxt) {}",
            "};",
            "template <typename Cap, typename Cost> struct MinCostFlow {",
            "\tstatic constexpr Cap inf_cap = numeric_limits<Cap>::max();",
            "\tstatic constexpr Cost inf_cost = numeric_limits<Cost>::max() >> 1;",
            "\tint n;",
            "\tvector <CEdge <Cap, Cost>> edges;",
            "\tvector <Cost> d, pot;",
            "\tpriority_queue <pair <Cost, int>> q;",
            "\tvector <int> trace, head;",
            "\tMinCostFlow(int n_ = 0) : n(n_), d(n), pot(n, 0), trace(n), head(n, -1) {}",
            "\tint add(int from, int to, Cap cap, Cost cost) {",
            "\t\tint id = edges.size();",
            "\t\tedges.emplace_back(from, to, cap, cost, head[from]);",
            "\t\thead[from] = id;",
            "\t\tedges.emplace_back(to, from, 0, -cost, head[to]);",
            "\t\thead[to] = id + 1;",
            "\t\treturn id;",
            "\t}",
            "\tvoid expath(int st) {",
            "\t\tfill(d.begin(), d.end(), inf_cost);",
            "\t\twhile (!q.empty()) q.pop();",
            "\t\td[st] = 0;",
            "\t\tq.push({pot[st], st});",
            "\t\twhile (!q.empty()) {",
            "\t\t\tauto [du, u] = q.top(); q.pop();",
            "\t\t\tif (du != pot[u] - d[u]) continue;",
            "\t\t\tfor (int i = head[u]; i != -1; i = edges[i].nxt) {",
            "\t\t\t\tint v = edges[i].to;",
            "\t\t\t\tif (edges[i].cap != edges[i].flow && d[u] + edges[i].cost < d[v]) {",
            "\t\t\t\t\td[v] = d[u] + edges[i].cost;",
            "\t\t\t\t\ttrace[v] = i;",
            "\t\t\t\t\tq.push({pot[v] - d[v], v});",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tswap(d, pot);",
            "\t}",
            "\tpair <Cap, Cost> max_flow(int s, int t) {",
            "\t\tCap flow = 0;",
            "\t\tCost cost = 0;",
            "\t\tbool ok = true;",
            "\t\tfor (auto &e: edges) if (e.cap != e.flow && e.cost + pot[e.from] - pot[e.to] < 0) {",
            "\t\t\tok = false;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif (ok) expath(s);",
            "\t\telse {",
            "\t\t\tvector <int> deg(n, 0);",
            "\t\t\tfor (int u = 0; u < n; ++u)",
            "\t\t\t\tfor (int i = head[u]; i != -1; i = edges[i].nxt)",
            "\t\t\t\t\tif (edges[i].cap != edges[i].flow) ++deg[edges[i].to];",
            "\t\t\tvector <int> que;",
            "\t\t\tfor (int i = 0; i < n; ++i) if (!deg[i]) que.push_back(i);",
            "\t\t\tfor (int b = 0; b < (int) que.size(); ++b) {",
            "\t\t\t\tfor (int i = head[que[b]]; i != -1; i = edges[i].nxt) if (edges[i].cap != edges[i].flow) {",
            "\t\t\t\t\t--deg[edges[i].to];",
            "\t\t\t\t\tif (!deg[edges[i].to]) que.push_back(edges[i].to);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tfill(pot.begin(), pot.end(), inf_cost);",
            "\t\t\tpot[s] = 0;",
            "\t\t\tif ((int) que.size() == n) {",
            "\t\t\t\tfor (int u: que) if (pot[u] < inf_cost) {",
            "\t\t\t\t\tfor (int i = head[u]; i != -1; i = edges[i].nxt) if (edges[i].cap != edges[i].flow && pot[u] + edges[i].cost < pot[edges[i].to]) {",
            "\t\t\t\t\t\tpot[edges[i].to] = pot[u] + edges[i].cost;",
            "\t\t\t\t\t\ttrace[edges[i].to] = i;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t} else {",
            "\t\t\t\tque.assign(1, s);",
            "\t\t\t\tvector <bool> in_queue(n, false);",
            "\t\t\t\tin_queue[s] = true;",
            "\t\t\t\tfor (int b = 0; b < (int)que.size(); b++) {",
            "\t\t\t\t\tint u = que[b];",
            "\t\t\t\t\tin_queue[u] = false;",
            "\t\t\t\t\tfor (int i = head[u]; i != -1; i = edges[i].nxt) if (edges[i].cap != edges[i].flow && pot[u] + edges[i].cost < pot[edges[i].to]) {",
            "\t\t\t\t\t\tpot[edges[i].to] = pot[u] + edges[i].cost;",
            "\t\t\t\t\t\ttrace[edges[i].to] = i;",
            "\t\t\t\t\t\tif (!in_queue[edges[i].to]) {",
            "\t\t\t\t\t\t\tque.push_back(edges[i].to);",
            "\t\t\t\t\t\t\tin_queue[edges[i].to] = true;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\twhile (pot[t] < inf_cost) {",
            "\t\t\tCap push = inf_cap;",
            "\t\t\tfor (int u = t; u != s; u = edges[trace[u]].from)",
            "\t\t\t\tpush = min(push, edges[trace[u]].cap - edges[trace[u]].flow);",
            "\t\t\tfor (int u = t; u != s; u = edges[trace[u]].from) {",
            "\t\t\t\tedges[trace[u]].flow += push;",
            "\t\t\t\tedges[trace[u] ^ 1].flow -= push;",
            "\t\t\t}",
            "\t\t\tflow += push; cost += push * pot[t];",
            "\t\t\texpath(s);",
            "\t\t}",
            "\t\treturn {flow, cost};",
            "\t}",
            "};",
            "template <bool ToShuffle = false> struct MaxMatching {",
            "\tint n;",
            "\tvector <int> match, gr, cnt;",
            "\tvector <pair <int, int>> edg;",
            "\tMaxMatching(int n = 0): n(n) {}",
            "\tvoid add(int u, int v) { edg.emplace_back(u, v); }",
            "\tstruct Data {",
            "\t\tint used, prev, root, depth;",
            "\t\tData(int used, int prev, int root, int depth): used(used), prev(prev), root(root), depth(depth) {}",
            "\t};",
            "\tvector <pair <int, int>> max_matching() {",
            "\t\tif constexpr (ToShuffle) {",
            "\t\t\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "\t\t\tshuffle(edg.begin(), edg.end(), rng);",
            "\t\t}",
            "\t\tmatch.assign(n, -1);",
            "\t\tgr.resize(edg.size() << 1);",
            "\t\tcnt.assign(n + 1, 0);",
            "\t\tfor (auto [u, v]: edg) ++cnt[u], ++cnt[v];",
            "\t\tfor (int i = 0, c = 0; i <= n; ++i) c += cnt[i], cnt[i] = c;",
            "\t\tfor (int i = edg.size(); i-- > 0; ) {",
            "\t\t\tauto &[u, v] = edg[i];",
            "\t\t\tgr[--cnt[u]] = v;",
            "\t\t\tgr[--cnt[v]] = u;",
            "\t\t}",
            "\t\tvector <Data> data(n, Data(0, 0, 0, 0));",
            "\t\tint used_mark = 0, db_ptr, de_ptr;",
            "\t\tvector <int> dq(n);",
            "\t\twhile (true) {",
            "\t\t\tused_mark++; db_ptr = de_ptr = 0;",
            "\t\t\tfor (int i = 0; i < n; ++i) if (match[i] == -1) {",
            "\t\t\t\tdata[i] = Data(used_mark, -1, i, 0);",
            "\t\t\t\tdq[de_ptr++] = i;",
            "\t\t\t}",
            "\t\t\tint aug_cnt = 0;",
            "\t\t\twhile (db_ptr < de_ptr) {",
            "\t\t\t\tint u = dq[db_ptr++];",
            "\t\t\t\tif (match[data[u].root] != -1) continue;",
            "\t\t\t\tbool aug_found = false;",
            "\t\t\t\tfor (int ti = cnt[u]; ti < cnt[u + 1]; ++ti) {",
            "\t\t\t\t\tint t = gr[ti];",
            "\t\t\t\t\tif (data[t].used == used_mark && data[t].depth == 0 && match[data[t].root] == -1) {",
            "\t\t\t\t\t\taug_cnt++;",
            "\t\t\t\t\t\tmatch[u] = t, match[t] = u;",
            "\t\t\t\t\t\tint len = 1;",
            "\t\t\t\t\t\tfor (int x = u; data[x].prev != -1; x = data[x].prev) {",
            "\t\t\t\t\t\t\tif (data[x].depth == 1) match[x] = data[x].prev, match[data[x].prev] = x;",
            "\t\t\t\t\t\t\tlen++;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tfor (int x = t; data[x].prev != -1; x = data[x].prev) {",
            "\t\t\t\t\t\t\tif (data[x].depth == 1) match[x] = data[x].prev, match[data[x].prev] = x;",
            "\t\t\t\t\t\t\tlen++;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\taug_found = true;",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\tif (aug_found) continue;",
            "\t\t\t\tfor (int ti = cnt[u]; ti < cnt[u + 1]; ++ti) {",
            "\t\t\t\t\tint t = gr[ti];",
            "\t\t\t\t\tif (data[t].used != used_mark) {",
            "\t\t\t\t\t\tint t2 = match[t];",
            "\t\t\t\t\t\tdata[t] = Data(used_mark, u, data[u].root, 1);",
            "\t\t\t\t\t\tdata[t2] = Data(used_mark, t, data[u].root, 0);",
            "\t\t\t\t\t\tdq[de_ptr++] = t2;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif (!aug_cnt) break;",
            "\t\t}",
            "\t\tvector <pair <int, int>> res;",
            "\t\tfor (int i = 0; i < n; ++i) if (i < match[i]) res.push_back({i, match[i]});",
            "\t\treturn res;",
            "\t}",
            "\tpair <vector <int>, vector <int>> minimum_vertex_cover() {",
            "\t\tvector <int> q(n);",
            "\t\tint qb = 0, qe = 0;",
            "\t\tvector <bool> f(n);",
            "\t\tfor (int i = 0; i < n; ++i) if (match[i] == -1) q[qe++] = i;",
            "\t\twhile (qb < qe) {",
            "\t\t\tint u = q[qb++];",
            "\t\t\tfor (int i = cnt[u]; i < cnt[u + 1]; ++i) {",
            "\t\t\t\tint v = gr[i];",
            "\t\t\t\tif (!f[v]) {",
            "\t\t\t\t\tf[v] = true;",
            "\t\t\t\t\tq[qe++] = match[v];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor (int i = 0; i < n; ++i) if (match[i] != -1 && !f[i] && !f[match[i]]) f[i] = true;",
            "\t\tvector <int> L, R;",
            "\t\tfor (int i = 0; i < n; ++i) (f[i] ? L : R).push_back(i);",
            "\t\treturn {L, R};",
            "\t}",
            "};",
            "template <class T> struct Hungarian {",
            "\tint n;",
            "\tvector <vector <T>> c;",
            "\tvector <T> fx, fy, d;",
            "\tvector <int> l, r, arg, trace;",
            "\tint start, finish;",
            "\tstatic constexpr T inf = numeric_limits<T>::max() >> 1;",
            "\tHungarian() {}",
            "\tHungarian(int n1, int n2): n(max(n1, n2)), c(n, vector<T>(n, inf)), fx(n), fy(n), d(n), l(n, -1), r(n, -1), arg(n), trace(n) {}",
            "\tvoid add(int u, int v, T cost) { c[u][v] = min(c[u][v], cost); }",
            "\tT getC(int u, int v) { return c[u][v] - fx[u] - fy[v]; }",
            "\tT max_matching() {",
            "\t\tfor (int u = 0; u < n; ++u) {",
            "\t\t\tfx[u] = c[u][0];",
            "\t\t\tfor (int v = 0; v < n; ++v) fx[u] = min(fx[u], c[u][v]);",
            "\t\t}",
            "\t\tfor (int v = 0; v < n; ++v) {",
            "\t\t\tfy[v] = c[0][v] - fx[0];",
            "\t\t\tfor (int u = 0; u < n; ++u) fy[v] = min(fy[v], c[u][v] - fx[u]);",
            "\t\t}",
            "\t\tvector <int> q(n);",
            "\t\tint qb, qe;",
            "\t\tfor (int u = 0; u < n; ++u) {",
            "\t\t\tstart = u;",
            "\t\t\tqb = qe = 0;",
            "\t\t\tq[qe++] = start;",
            "\t\t\tfill(trace.begin(), trace.end(), -1);",
            "\t\t\tfor (int v = 0; v < n; ++v) d[v] = getC(start, v), arg[v] = start;",
            "\t\t\tfinish = -1;",
            "\t\t\twhile (finish == -1) {",
            "\t\t\t\twhile (qb < qe) {",
            "\t\t\t\t\tint u = q[qb++];",
            "\t\t\t\t\tfor (int v = 0; v < n; ++v) if (trace[v] == -1) {",
            "\t\t\t\t\t\tT w = getC(u, v);",
            "\t\t\t\t\t\tif (!w) {",
            "\t\t\t\t\t\t\ttrace[v] = u;",
            "\t\t\t\t\t\t\tif (r[v] == -1) {",
            "\t\t\t\t\t\t\t\tfinish = v;",
            "\t\t\t\t\t\t\t\tgoto nxt;",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tq[qe++] = r[v];",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tif (d[v] > w) d[v] = w, arg[v] = u;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\tnxt:;",
            "\t\t\t\tif (finish == -1) {",
            "\t\t\t\t\tT delta = inf;",
            "\t\t\t\t\tfor (int v = 0; v < n; ++v) if (trace[v] == -1 && d[v] < delta) delta = d[v];",
            "\t\t\t\t\tfx[start] += delta;",
            "\t\t\t\t\tfor (int v = 0; v < n; ++v) {",
            "\t\t\t\t\t\tif (trace[v] != -1) {",
            "\t\t\t\t\t\t\tint u = r[v];",
            "\t\t\t\t\t\t\tfy[v] -= delta; fx[u] += delta;",
            "\t\t\t\t\t\t} else d[v] -= delta;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tfor (int v = 0; v < n; ++v) if (trace[v] == -1 && !d[v]) {",
            "\t\t\t\t\t\ttrace[v] = arg[v];",
            "\t\t\t\t\t\tif (r[v] == -1) {",
            "\t\t\t\t\t\t\tfinish = v;",
            "\t\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tq[qe++] = r[v];",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tdo {",
            "\t\t\t\tint u = trace[finish], nxt = l[u];",
            "\t\t\t\tl[u] = finish; r[finish] = u;",
            "\t\t\t\tfinish = nxt;",
            "\t\t\t} while (finish != -1);",
            "\t\t}",
            "\t\tT ans = 0;",
            "\t\tfor (int i = 0; i < n; ++i) {",
            "\t\t\tif (c[i][l[i]] != inf) ans += c[i][l[i]];",
            "\t\t\telse l[i] = -1;",
            "\t\t}",
            "\t\treturn ans;",
            "\t}",
            "};",
            "} using namespace MAX_FLOW;",
            ""
        ],
        "description": "MAX_FLOW"
    },
    "GCD": {
        "scope": "cpp",
        "prefix": "GCD",
        "body": [
            "int gcd(int a, int b) {",
            "\tif (!a) return b;",
            "\tif (!b) return a;",
            "\tint az = __builtin_ctz(a);",
            "\tint bz = __builtin_ctz(b);",
            "\tint shift = min(az, bz);",
            "\tb >>= bz;",
            "\twhile (a) {",
            "\t\ta >>= az;",
            "\t\tint diff = b - a;",
            "\t\taz = __builtin_ctz(diff);",
            "\t\tb = min(a, b); a = abs(diff);",
            "\t}",
            "\treturn b << shift;",
            "}",
            "",
            "long long gcdll(long long a, long long b) {",
            "\tif (!a) return b;",
            "\tif (!b) return a;",
            "\tint az = __builtin_ctzll(a);",
            "\tint bz = __builtin_ctzll(b);",
            "\tint shift = min(az, bz);",
            "\tb >>= bz;",
            "\twhile (a) {",
            "\t\ta >>= az;",
            "\t\tlong long diff = b - a;",
            "\t\taz = __builtin_ctzll(diff);",
            "\t\tb = min(a, b); a = abs(diff);",
            "\t}",
            "\treturn b << shift;",
            "}",
            ""
        ],
        "description": "GCD"
    },
}